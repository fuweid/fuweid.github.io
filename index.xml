<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Wei Fu</title>
        <link>https://fuweid.com/</link>
        <copyright>2020 Wei Fu</copyright>
        <lastBuildDate>Sun, 02 Jun 2019 00:00:00 +0000</lastBuildDate>
        <atom:link href="/" rel="self" type="application/rss+xml" />

        
        <item>
          <title>Hola Barcelona</title>
          <link>/post/2019-hola-barcelona/</link>
          <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
          <guid>https://fuweid.com/post/2019-hola-barcelona/</guid>
          <description>&lt;p&gt;前段时间因为 KubeCon 演讲去了趟西班牙-巴塞罗那，忙里偷闲，感受了下西方文化。&lt;/p&gt;
&lt;h3 id=&#34;不再是白本&#34;&gt;不再是「白本」&lt;/h3&gt;
&lt;p&gt;5.18 号从杭州出发，途径香港转机到巴塞罗那。飞机上的娱乐设施还算丰富，「海王」、「绿皮书」等新片都可以观看到。十几个小时的飞机总不能一直看电影，还得兼顾倒时差的任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fuweid.com/img/2019-hola-barcelona/airport-departure.jpeg&#34; alt=&#34;airport-departure&#34;&gt;&lt;/p&gt;
&lt;p&gt;之前没有调整时差的经验，加上平时作息比较规律，十三个小时的飞行过程里相对属于清醒状态。网络要收费，印象中比较贵，基本上干不了别的事情，除了看电影就是睡觉。如果经济允许，可以考虑升舱，坐经济舱飞十几小时简直了。到达 巴塞罗那 是当地时间早上8点，天气还算不错，就是有点过于「凉快」，完全没有夏天的感觉。上了摆渡车，直奔海关。&lt;/p&gt;
&lt;p&gt;当地的海关工作人员整体都不严肃，有些还带着耳机工作，有点不可思议。轮到我的时候，那位海关小哥看了我半天，感觉不像，盖章的时候特别犹豫，而且盖完章之后他应该是后悔了，还用类似验钞机的东西反复扫描我的签注，最后才说「Wei Fu, Welcome」。&lt;/p&gt;
&lt;p&gt;说句实在话，我当时的反应是这签证不会特么是假的吧，因为从广州签证处提交申请到拿到签证只花了「三天」，申请港澳通行证都没有那么快。还好，有惊无险。&lt;/p&gt;
&lt;h3 id=&#34;骑行友好的街道&#34;&gt;骑行友好的街道&lt;/h3&gt;
&lt;p&gt;虽然没有游玩整个 巴塞罗那 ，但是可以感觉到城市的大部分街道都是单行道。我在早高峰的时候打过车，车多但不算堵。&lt;/p&gt;
&lt;p&gt;说到打车，这里的打车算是一件高消费的服务了。我没有用 Uber/MyTaxi 软件打车，大部分都是通过酒店来约车，而这种约车是需要收调度费，大概2-3 欧左右吧。接近4公里左右的路程要 15 欧，贵！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fuweid.com/img/2019-hola-barcelona/street-near-chaozhoulao.jpeg&#34; alt=&#34;street-near-chaozhoulao&#34;&gt;&lt;/p&gt;
&lt;p&gt;可能是养一辆车的费用比较高吧，这座城市的摩托车特别多，几乎随处可见。比较有意思的是摩托车车锁，他们的车锁是锁车把和车身，基本上不需要下蹲去锁车。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fuweid.com/img/2019-hola-barcelona/lock-for-motobike.jpeg&#34; alt=&#34;lock-for-motobike&#34;&gt;&lt;/p&gt;
&lt;p&gt;虽然北京也有自行车道，但是大部分都被私家车占用了，对骑行的人来说极度不友好。这边的街道基本是两车道配一个自行车道，而汽车道和自行车道基本上严格分开，有些地方还有隔离带，对爱骑车的人来说真是太幸福了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fuweid.com/img/2019-hola-barcelona/random-street-1.jpeg&#34; alt=&#34;random-street-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果你打开 Mobike，估计还会有惊喜哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fuweid.com/img/2019-hola-barcelona/mobike-near-kubecon.png&#34; alt=&#34;mobike-near-kubecon&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;地铁还不算太破&#34;&gt;地铁，还不算太破&lt;/h3&gt;
&lt;p&gt;我住的酒店离地铁站不远，走几个街头就可以到达地铁站。在长达 15 个小时日照时间里，在拓展区里步行还算安全，也比较舒服。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fuweid.com/img/2019-hola-barcelona/random-street-2.jpeg&#34; alt=&#34;random-street-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;随处可见的遛狗人士，转角处的饮酒闲谈，还有无法欣赏的涂鸦。建筑都相对破旧，估计这十几年的变化也就是街上跑的私家车了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fuweid.com/img/2019-hola-barcelona/random-street-3.jpeg&#34; alt=&#34;random-street-3&#34;&gt;&lt;/p&gt;
&lt;p&gt;不管是去日本，还是来到 巴塞罗那，这边的地铁和火车一样，发车和到达时间点都是严格规定好的。这有个好处就是，每天都可以踩点出发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fuweid.com/img/2019-hola-barcelona/random-subway-1.jpeg&#34; alt=&#34;random-subway-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;整个城市的地铁覆盖范围还是比较大，就是不同的区域由不同的公司运营，换乘基本上要出站重新购票了。如果不买套票，单程票就要 2.2 欧，贵的一匹。刷票进站后，给人感觉就是简陋，但不算太破。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fuweid.com/img/2019-hola-barcelona/random-subway-2.jpeg&#34; alt=&#34;random-subway-2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;语言no-english&#34;&gt;语言？No English&lt;/h3&gt;
&lt;p&gt;巴塞罗那 选择的时区和德国好像是一样的，都是东一区。在夏天，他们日照时间有 15 小时，到晚上 9 点天还是亮的。&lt;/p&gt;
&lt;p&gt;因为长时间日照的原因，他们物产是比较丰富的。但是想不明白的是，他们这边的特产是「西班牙火腿」。这火腿是腌制好几年而成，吃的时候切的越薄口感越好。主要这是生肉。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fuweid.com/img/2019-hola-barcelona/meat.jpeg&#34; alt=&#34;meat&#34;&gt;&lt;/p&gt;
&lt;p&gt;和当地的「潮州佬」店主聊，他们当地喜欢吃「生」，日料店相对中餐而言要受欢迎些，估计是好吃「生」的食材吧。尝过 Tapa，也看过所谓的海鲜饭，还是觉得国内的菜还吃。&lt;/p&gt;
&lt;p&gt;出去吃饭更要命的是，点菜的时候没有图片，加上有些还没有英文注释，基本就瞎了。看不懂可以问吧，但是这边的人不太会说英语，也不愿意说。你可以想象下，机场里的工作人员会直接对你「No English」。这体验真的比去日本还糟糕。&lt;/p&gt;
&lt;h3 id=&#34;一直在修&#34;&gt;一直在「修」&lt;/h3&gt;
&lt;p&gt;城市比较小，到达的第一天就小转了一圈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fuweid.com/img/2019-hola-barcelona/random-street-4.jpeg&#34; alt=&#34;random-street-4&#34;&gt;&lt;/p&gt;
&lt;p&gt;因为加泰罗尼亚要闹独立，涂鸦就是这边的独特的风景线。从酒店走到港口，街道上的店铺都没开门。问了下当地国人，说这边的人比较懒，周末基本都享受去了，开便利店的基本都是非本地人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fuweid.com/img/2019-hola-barcelona/random-street-5.jpeg&#34; alt=&#34;random-street-5&#34;&gt;&lt;/p&gt;
&lt;p&gt;一路上都有海鸥到处飞，海鸥也不怕人，基本给啥吃啥，爆米花都吃！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fuweid.com/img/2019-hola-barcelona/random-street-6.jpeg&#34; alt=&#34;random-street-6&#34;&gt;&lt;/p&gt;
&lt;p&gt;在港口溜达一会，就去看世界上最著名的「烂尾楼」 - 「圣家族大教堂」。这座大教堂修了 100 年，因为修的时间是在太长了，不知道是不是中间换了几个设计师，教堂每个角度的风格都不太一样。不过这也算是巴塞罗那著名景点了，只可惜当天去的时候没有门票了，没能进去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fuweid.com/img/2019-hola-barcelona/random-street-7.jpeg&#34; alt=&#34;random-street-7&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;最后&#34;&gt;最后&lt;/h3&gt;
&lt;p&gt;这次出国没准备攻略，基本上是很佛系地逛了下，剩下大部分时间都在准备演讲内容。不过怎样，出远门才觉得国内是真TM方便。&lt;/p&gt;
</description>
        </item>
        
        <item>
          <title>工作三年</title>
          <link>/post/2018-3years-career/</link>
          <pubDate>Fri, 13 Apr 2018 00:00:00 +0000</pubDate>
          <guid>https://fuweid.com/post/2018-3years-career/</guid>
          <description>&lt;p&gt;不知不觉就过了三年，但是我还能很清楚地记得当时签卖身契的场景，只能说毕业之后时间过的飞起。这三年没写过什么年度总结，今天打算矫情一把，记下流水账。&lt;/p&gt;
&lt;h3 id=&#34;vimer&#34;&gt;Vimer&lt;/h3&gt;
&lt;p&gt;有一次参加罗老师开发环境的分享会后，我就开始迷上 vim，并结束了 IDE/Sublime 之间的摇摆。从实用角度看，IDE 有着开箱即用的特点，这的确让人无法抗拒。但在平时的工作里，不同语言之间切换是常有的事，而且经常远程调试、常年沉浸在 Terminal 的我，vim 作为编辑器是一个不错的选择。加上韩国小哥 junegunn 开源神器 fzf ，解决了 vim 全文检索巨卡的痛点，这让我毫不犹豫地坚持使用 vim。没试过 fzf 的朋友不妨试试！&lt;/p&gt;
&lt;p&gt;我在习惯 HJKL 的同时，也在尝试回馈社区。还记得刚用 fzf.vim 的时候，当时的全文检索没有预览功能，相比于 Sublime，几乎没法用。所以在参加完公司第二个 Hackathon 之后的那个周末提了人生的第一个 PR。在这期间和韩国小哥 junegunn 来来回回讨论了快一个月，虽然最后失败了，但是我很享受这期间的沟通过程，毕竟能把自己的想法表达清楚是一件难得的事，因为非实时的沟通一旦出现理解偏差，时间成本将会急速上升。&lt;/p&gt;
&lt;p&gt;在后来使用了 vim-delve 插件，并帮助作者修复了几个 bug，也算是回馈社区了~&lt;/p&gt;
&lt;h3 id=&#34;mit-6828&#34;&gt;MIT 6.828&lt;/h3&gt;
&lt;p&gt;在 16 年年初，非计算机专业的我选择了恶补操作系统：MIT 6.828。&lt;/p&gt;
&lt;p&gt;前前后后花了三个周末完成所有基本要求。课程设计者虽然尽可能地避免了琐碎的硬件操作，但是这三个周末还是非常的虐，毕竟 x86 架构有很多历史包袱，需要阅读 Intel x86 的开发文档。。。这三个周末完成的玩具内核让我重新认识了操作系统， 对我后续的工作帮助极大。&lt;/p&gt;
&lt;p&gt;不过你们会相信恶补的原因只是想知道 fork 怎么做到两个返回值 吗？&lt;/p&gt;
&lt;h3 id=&#34;gopher&#34;&gt;Gopher&lt;/h3&gt;
&lt;p&gt;语言切换算是这三年里最大的变化吧。为了看 Docker 的代码而接触 Golang，但是在16年年底的时候公司并没有项目让我去实践，当时的我只能自己啃代码，等到真正实践的时候也差不多到17年年中了。&lt;/p&gt;
&lt;p&gt;去年七八月我偶然发现 PingCAP 有赠马克杯的 TiDB 重构活动，很幸运的是提的三个 PR 都被接受了，这也是我第一次在 Github 上贡献代码。再后来就是 Pouch，因为对容器的喜爱吧，几乎大部分的空闲时间都参与到 Pouch 上来了。&lt;/p&gt;
&lt;p&gt;除了代码以外，还因为 Golang 开源项目结识了一些朋友，不得不说真是名副其实的 G**hub。&lt;/p&gt;
&lt;h3 id=&#34;我的-2018&#34;&gt;我的 2018&lt;/h3&gt;
&lt;p&gt;以上是过去三年来影响最大的三件事，不管怎样，希望还能像过去三年那样保持好奇的心吧。&lt;/p&gt;
</description>
        </item>
        
        <item>
          <title>Goroutine Scheduler Overview</title>
          <link>/post/2018-goroutine-scheduler-overview/</link>
          <pubDate>Tue, 06 Feb 2018 00:00:00 +0800</pubDate>
          <guid>https://fuweid.com/post/2018-goroutine-scheduler-overview/</guid>
          <description>&lt;p&gt;Goroutine 是 Golang 世界里的 &lt;code&gt;Lightweight Thread&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;Golang 在语言层面支持多线程，代码可以通过 &lt;code&gt;go&lt;/code&gt; 关键字来启动 Goroutine ，调用者不需要关心调用栈的大小，函数上下文等等信息就可以完成并发或者并行操作，加快了我们的开发速度。
分析 Goroutine 调度有利于了解和分析 go binary 的工作状况，所以接下来的内容将分析 &lt;code&gt;runtime&lt;/code&gt; 中关于 Goroutine 调度的逻辑。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下内容涉及到的代码是基于 &lt;a href=&#34;https://github.com/golang/go/tree/048c9cfaac&#34;&gt;go1.9rc2&lt;/a&gt; 版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-scheduler-structure&#34;&gt;1. Scheduler Structure&lt;/h3&gt;
&lt;p&gt;整个调度模型由 Goroutine/Processor/Machine 以及全局调度信息 sched 组成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                   Global Runnable Queue

                          runqueue
                ----------------------------
                 | G_10 | G_11 | G_12 | ...
                ----------------------------

                                        P_0 Local Runnable Queue
                +-----+      +-----+       ---------------
                | M_3 | ---- | P_0 |  &amp;lt;===  | G_8 | G_9 |
                +-----+      +-----+       ---------------
                                |
                             +-----+
                             | G_3 |  Running
                             +-----+

                                        P_1 Local Runnable Queue
                +-----+      +-----+       ---------------
                | M_4 | ---- | P_1 |  &amp;lt;===  | G_6 | G_7 |
                +-----+      +-----+       ---------------
                                |
                             +-----+
                             | G_5 |  Running
                             +-----+
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;11-goroutine&#34;&gt;1.1 Goroutine&lt;/h4&gt;
&lt;p&gt;Goroutine 是 Golang 世界里的 &lt;code&gt;线程&lt;/code&gt; ，同样也是可调度的单元。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/runtime2.go
type g struct {
        ....
        m       *m
        sched gobuf
        goid   int64
        ....
}

type gobuf struct {
        sp   uintptr
        pc   uintptr
        ....
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;runtime&lt;/code&gt; 为 Goroutine 引入了类似 PID 的属性 &lt;code&gt;goid&lt;/code&gt; ，使得每一个 Goroutine 都有全局唯一的 &lt;code&gt;goid&lt;/code&gt; 标识。
不过官方并没有提供接口能 &lt;strong&gt;直接&lt;/strong&gt; 访问当前 Goroutine 的 &lt;code&gt;goid&lt;/code&gt;，在这种情况下我们可以通过 &lt;a href=&#34;https://github.com/0x04C2/gid/blob/master/gid_amd64.s#L5&#34;&gt;汇编&lt;/a&gt; 或者 &lt;a href=&#34;https://github.com/0x04C2/gid/blob/master/gid_test.go#L21&#34;&gt;取巧&lt;/a&gt; 的方式得到 &lt;code&gt;goid&lt;/code&gt;，有些第三方 package 会利用 &lt;code&gt;goid&lt;/code&gt; 做一些有趣的事情，比如 &lt;a href=&#34;https://github.com/jtolds/gls&#34;&gt;Goroutine local storage&lt;/a&gt; ，后面会介绍 &lt;code&gt;runtime&lt;/code&gt; 是如何生成唯一的 &lt;code&gt;goid&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;在调度过程中，&lt;code&gt;runtime&lt;/code&gt; 需要 Goroutine 释放当前的计算资源，为了保证下次能恢复现场，执行的上下文现场（指令地址 和 Stack Pointer 等）将会存储在 &lt;code&gt;gobuf&lt;/code&gt; 这个数据结构中。&lt;/p&gt;
&lt;p&gt;整体来说，Goroutine 仅代表任务的内容以及上下文，并不是具体的执行单元。&lt;/p&gt;
&lt;h4 id=&#34;12-machine&#34;&gt;1.2 Machine&lt;/h4&gt;
&lt;p&gt;Machine 是 OS Thread，它负责执行 Goroutine。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/runtime2.go

type m struct {
        ....
        g0      *g     // goroutine with scheduling stack
        curg    *g     // current running goroutine

        tls     [6]uintptr // thread-local storage (for x86 extern register)
        p       puintptr // attached p for executing go code (nil if not executing go code)
        ....
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;runtime&lt;/code&gt; 在做调度工作或者和当前 Goroutine 无关的任务时，Golang 会切换调用栈来进行相关的任务，就好像 Linux 的进程进入系统调用时会切换到内核态的调用栈一样，这么做也是为了避免影响到调度以及垃圾回收的扫描。&lt;/p&gt;
&lt;p&gt;Machine 一般会调用 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/stubs.go#L39&#34;&gt;systemstack 函数&lt;/a&gt; 来切换调用栈。
从名字可以看出，Golang 对外部 go code 的调用栈称之为 &lt;code&gt;user stack&lt;/code&gt; ，而将运行核心 &lt;code&gt;runtime&lt;/code&gt; 部分代码的调用栈称之为 &lt;code&gt;system stack&lt;/code&gt;。
Machine 需要维护这两个调用栈的上下文，所以 &lt;code&gt;m&lt;/code&gt; 中 &lt;code&gt;g0&lt;/code&gt; 用来代表 &lt;code&gt;runtime&lt;/code&gt; 内部逻辑，而 &lt;code&gt;curg&lt;/code&gt; 则是我们平时写的代码，更多详情可以关注 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/HACKING.md#user-stacks-and-system-stacks&#34;&gt;src/runtime/HACKING.md&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;因为调用栈可以来回地切换，Machine 需要知道当前运行的调用栈信息，所以 Golang 会利用 Thread Local Storage 或者指定寄存器来存储当前运行的 &lt;code&gt;g&lt;/code&gt;。
&lt;code&gt;settls&lt;/code&gt; 汇编代码会将 &lt;code&gt;g&lt;/code&gt; 的地址放到 &lt;code&gt;m.tls&lt;/code&gt; 中，这样 Machine 就可以通过 &lt;code&gt;getg&lt;/code&gt; 取出当前运行的 Goroutine。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不同平台 &lt;code&gt;settls&lt;/code&gt; 的行为有一定差别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/sys_linux_amd64.s

// set tls base to DI
TEXT runtime·settls(SB),NOSPLIT,$32
#ifdef GOOS_android
        // Same as in sys_darwin_386.s:/ugliness, different constant.
        // DI currently holds m-&amp;gt;tls, which must be fs:0x1d0.
        // See cgo/gcc_android_amd64.c for the derivation of the constant.
        SUBQ    $0x1d0, DI  // In android, the tls base·
#else
        ADDQ    $8, DI  // ELF wants to use -8(FS)
#endif
        MOVQ    DI, SI
        MOVQ    $0x1002, DI     // ARCH_SET_FS
        MOVQ    $158, AX        // arch_prctl
        SYSCALL
        CMPQ    AX, $0xfffffffffffff001
        JLS     2(PC)
        MOVL    $0xf1, 0xf1  // crash
        RET

// src/runtime/stubs.go

// getg returns the pointer to the current g.
// The compiler rewrites calls to this function into instructions
// that fetch the g directly (from TLS or from the dedicated register).
func getg() *g

// src/runtime/go_tls.h 

#ifdef GOARCH_amd64
#define get_tls(r)      MOVQ TLS, r
#define g(r)    0(r)(TLS*1)
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是 Machine 想要执行一个 Goroutine，必须要绑定 Processor。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;runtime&lt;/code&gt; 内部有些函数执行时会直接绑定 Machine，并不需要 Processor，比如 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L3810&#34;&gt;sysmon&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;13-processor&#34;&gt;1.3 Processor&lt;/h4&gt;
&lt;p&gt;Processor 可以理解成处理器，它会维护着本地 Goroutine 队列 &lt;code&gt;runq&lt;/code&gt; ，并在新的 Goroutine 入队列时分配唯一的 &lt;code&gt;goid&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type p struct {
        ...
        m           muintptr   // back-link to associated m (nil if idle)

        // Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.
        goidcache    uint64
        goidcacheend uint64

        // Queue of runnable goroutines. Accessed without lock.
        runqhead uint32
        runqtail uint32
        runq     [256]guintptr
        ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Processor 的数目代表着 &lt;code&gt;runtime&lt;/code&gt; 能同时处理 Goroutine 的数目，&lt;code&gt;GOMAXPROCS&lt;/code&gt; 环境变量是用来指定 Processor 的数目，默认状态会是 CPU 的个数。&lt;/p&gt;
&lt;p&gt;也正是因为 Processor 的存在，&lt;code&gt;runtime&lt;/code&gt; 并不需要做一个集中式的 Goroutine 调度，每一个 Machine 都会在 Processor 本地队列、Global Runnable Queue 或者其他 Processor 队列中找 Goroutine 执行，减少全局锁对性能的影响，后面会对此展开说明。&lt;/p&gt;
&lt;h4 id=&#34;14-全局调度信息-sched&#34;&gt;1.4 全局调度信息 sched&lt;/h4&gt;
&lt;p&gt;全局调度信息 &lt;code&gt;sched&lt;/code&gt; 会记录当前 Global Runnable Queue、当前空闲的 Machine 和空闲 Processor 的数目等等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;后面说明这 &lt;code&gt;goidgen&lt;/code&gt; 和 &lt;code&gt;nmspinning&lt;/code&gt; 两个字段的作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/runtime2.go

var (
        ...
        sched      schedt
        ...
)

type schedt struct {
        // accessed atomically. keep at top to ensure alignment on 32-bit systems.
        goidgen  uint64

        lock mutex

        midle        muintptr // idle m&#39;s waiting for work
        nmidle       int32    // number of idle m&#39;s waiting for work
        maxmcount    int32    // maximum number of m&#39;s allowed (or die)

        pidle      puintptr // idle p&#39;s
        npidle     uint32
        nmspinning uint32 // See &amp;quot;Worker thread parking/unparking&amp;quot; comment in proc.go.

        // Global runnable queue.
        runqhead guintptr
        runqtail guintptr
        runqsize int32
        ....
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2-create-a-goroutine&#34;&gt;2. Create a Goroutine&lt;/h3&gt;
&lt;p&gt;下面那段代码非常简单，在 &lt;code&gt;main&lt;/code&gt; 函数中产生 Goroutine 去执行 &lt;code&gt;do()&lt;/code&gt; 这个函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  main cat -n main.go
     1  package main
     2
     3  func do() {
     4          // nothing
     5  }
     6
     7  func main() {
     8          go do()
     9  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们编译上述代码并反汇编看看 &lt;code&gt;go&lt;/code&gt; 关键字都做了什么。
可以看到源代码的第 8 行 &lt;code&gt;go do()&lt;/code&gt; 编译完之后会变成 &lt;code&gt;runtime.newproc&lt;/code&gt; 方法，下面我们来看看 &lt;code&gt;runtime.newproc&lt;/code&gt; 都做了些什么。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  main uname -m -s
Linux x86_64
➜  main go build
➜  main go tool objdump -s &amp;quot;main.main&amp;quot; main
TEXT main.main(SB) /root/workspace/main/main.go
  main.go:7             0x450a60                64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX
  main.go:7             0x450a69                483b6110                CMPQ 0x10(CX), SP
  main.go:7             0x450a6d                7630                    JBE 0x450a9f
  main.go:7             0x450a6f                4883ec18                SUBQ $0x18, SP
  main.go:7             0x450a73                48896c2410              MOVQ BP, 0x10(SP)
  main.go:7             0x450a78                488d6c2410              LEAQ 0x10(SP), BP
  main.go:8             0x450a7d                c7042400000000          MOVL $0x0, 0(SP)
  main.go:8             0x450a84                488d05e5190200          LEAQ 0x219e5(IP), AX
  main.go:8             0x450a8b                4889442408              MOVQ AX, 0x8(SP)
  main.go:8             0x450a90                e88bb4fdff              CALL runtime.newproc(SB)  &amp;lt;==== I&#39;m here.
  main.go:9             0x450a95                488b6c2410              MOVQ 0x10(SP), BP
  main.go:9             0x450a9a                4883c418                ADDQ $0x18, SP
  main.go:9             0x450a9e                c3                      RET
  main.go:7             0x450a9f                e88c7dffff              CALL runtime.morestack_noctxt(SB)
  main.go:7             0x450aa4                ebba                    JMP main.main(SB)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;21-创建-do-的执行上下文&#34;&gt;2.1 创建 do() 的执行上下文&lt;/h4&gt;
&lt;p&gt;平时写代码的时候会发现，Goroutine 执行完毕之后便消失了。那么 &lt;code&gt;do()&lt;/code&gt; 这个函数执行完毕之后返回到哪了呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  main go tool objdump -s &amp;quot;main.do&amp;quot; main
TEXT main.do(SB) /root/workspace/main/main.go
  main.go:5             0x450a50                c3                      RET
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据 Intel 64 IA 32 开发指南上 &lt;code&gt;Chaptor 6.3 CALLING PROCEDURES USING CALL AND RET&lt;/code&gt; 的说明，&lt;code&gt;RET&lt;/code&gt; 会将栈顶的指令地址弹出到 &lt;code&gt;IP&lt;/code&gt; 寄存器上，然后继续执行 &lt;code&gt;IP&lt;/code&gt; 寄存器上的指令。
为了保证 Machine 执行完 Goroutine 之后，能够正常地完成一些清理工作，我们需要在构建 Goroutine 的执行上下文时指定 &lt;code&gt;RET&lt;/code&gt; 的具体地址。&lt;/p&gt;
&lt;p&gt;下面的代码段会将准备好的调用栈内存保存到 &lt;code&gt;newg.sched&lt;/code&gt; 中，其中 &lt;code&gt;gostartcallfn&lt;/code&gt; 函数会把 &lt;code&gt;do()&lt;/code&gt; 函数添加到 &lt;code&gt;newg.sched.pc&lt;/code&gt; ，并将 &lt;code&gt;goexit&lt;/code&gt; 函数地址推入栈顶 &lt;code&gt;newg.sched.sp&lt;/code&gt;。
所以 Goroutine 执行完毕之后，Machine 会跳到 &lt;code&gt;goexit&lt;/code&gt; 函数中做一些清理工作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/proc.go @ func newproc1

if narg &amp;gt; 0 {
        memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), uintptr(narg)
        ....
}

newg.sched.sp = sp
newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function
newg.sched.g = guintptr(unsafe.Pointer(newg))
gostartcallfn(&amp;amp;newg.sched, fn)
newg.gopc = callerpc
newg.startpc = fn.fn
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;想了解 Intel 指令的更多细节，请查看 &lt;a href=&#34;https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html&#34;&gt;Intel® 64 and IA-32 Architectures Developer&amp;rsquo;s Manual: Vol. 1&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;22-全局唯一的-goid&#34;&gt;2.2 全局唯一的 goid&lt;/h4&gt;
&lt;p&gt;除了创建执行上下文以外，&lt;code&gt;runtime&lt;/code&gt; 还会为 Goroutine 指定一个全局唯一的 id。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/proc.go

const (
        // Number of goroutine ids to grab from sched.goidgen to local per-P cache at once.
        // 16 seems to provide enough amortization, but other than that it&#39;s mostly arbitrary number.
        _GoidCacheBatch = 16
)

// src/runtime/proc.go @ func newproc1

if _p_.goidcache == _p_.goidcacheend {
        // Sched.goidgen is the last allocated id,
        // this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].
        // At startup sched.goidgen=0, so main goroutine receives goid=1.
        _p_.goidcache = atomic.Xadd64(&amp;amp;sched.goidgen, _GoidCacheBatch)
        _p_.goidcache -= _GoidCacheBatch - 1
        _p_.goidcacheend = _p_.goidcache + _GoidCacheBatch
}
newg.goid = int64(_p_.goidcache)
_p_.goidcache++
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;全局调度信息 &lt;code&gt;sched.goidgen&lt;/code&gt; 是专门用来做发号器，Processor 每次可以从发号器那拿走 &lt;code&gt;_GoidCacheBatch&lt;/code&gt; 个号，然后内部采用自增的方式来发号，这样就保证了每一个 Goroutine 都可以拥有全局唯一的 &lt;code&gt;goid&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从全局调度信息那里取号的时候用原子操作来保证并发操作的正确性，而内部发号时却采用非原子操作，这是因为一个 Processor 只能被一个 Machine 绑定上，所以这里 &lt;code&gt;_p_.goidcache&lt;/code&gt; 自增不需要要原子操作也能保证它的正确性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;23-local-vs-global-runnable-queue&#34;&gt;2.3 Local vs Global Runnable Queue&lt;/h4&gt;
&lt;p&gt;当 Goroutine 创建完毕之后，它是放在当前 Processor 的 Local Runnable Queue 还是全局队列里？&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L4289&#34;&gt;runqput&lt;/a&gt; 这个函数会尝试把 &lt;code&gt;newg&lt;/code&gt; 放到本地队列上，如果本地队列满了，它会将本地队列的前半部分和 &lt;code&gt;newg&lt;/code&gt; 迁移到全局队列中。剩下的事情就等待 Machine 自己去拿任务了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/proc.go @ func newproc1

runqput(_p_, newg, true)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;24-小结&#34;&gt;2.4 小结&lt;/h4&gt;
&lt;p&gt;看到这里，一般都会有以下几个疑问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;main 函数是不是也是一个 Goroutine ？&lt;/li&gt;
&lt;li&gt;Machine 怎么去取 Goroutine 来执行?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;goexit&lt;/code&gt; 做完清理工作之后就让 Machine 退出吗？还是继续使用这个 Machine?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么就继续往下读吧~&lt;/p&gt;
&lt;h3 id=&#34;3-main-is-a-goroutine&#34;&gt;3. main is a Goroutine&lt;/h3&gt;
&lt;p&gt;我们写的 &lt;code&gt;main&lt;/code&gt; 函数在程序启动时，同样会以 Goroutine 身份被 Machine 执行，下面会查看 go binary 启动时都做了什么。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  main uname -m -s
Linux x86_64
➜  main go build --gcflags &amp;quot;-N -l&amp;quot;
➜  main gdb main
(gdb) info file
Symbols from &amp;quot;/root/workspace/main/main&amp;quot;.
Local exec file:
        `/root/workspace/main/main&#39;, file type elf64-x86-64.
        Entry point: 0x44bb80
        0x0000000000401000 - 0x0000000000450b13 is .text
        0x0000000000451000 - 0x000000000047a6bc is .rodata
        0x000000000047a7e0 - 0x000000000047afd4 is .typelink
        0x000000000047afd8 - 0x000000000047afe0 is .itablink
        0x000000000047afe0 - 0x000000000047afe0 is .gosymtab
        0x000000000047afe0 - 0x00000000004a96c8 is .gopclntab
        0x00000000004aa000 - 0x00000000004aaa38 is .noptrdata
        0x00000000004aaa40 - 0x00000000004ab5b8 is .data
        0x00000000004ab5c0 - 0x00000000004c97e8 is .bss
        0x00000000004c9800 - 0x00000000004cbe18 is .noptrbss
        0x0000000000400fc8 - 0x0000000000401000 is .note.go.buildid
(gdb) info symbol 0x44bb80
_rt0_amd64_linux in section .text
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;入口函数是 &lt;code&gt;_rt0_amd64_linux&lt;/code&gt;，需要说明的是，不同平台的入口函数名称会有所不同，全局搜索该方法之后，发现该方法会调用 &lt;code&gt;runtime.rt0_go&lt;/code&gt; 汇编。&lt;/p&gt;
&lt;p&gt;省去了大量和硬件相关的细节后，&lt;code&gt;rt0_go&lt;/code&gt; 做了大量的初始化工作，&lt;code&gt;runtime.args&lt;/code&gt; 读取命令行参数、&lt;code&gt;runtime.osinit&lt;/code&gt; 读取 CPU 数目，&lt;code&gt;runtime.schedinit&lt;/code&gt; 初始化 Processor 数目，最大的 Machine 数目等等。&lt;/p&gt;
&lt;p&gt;除此之外，我们还看到了两个奇怪的 &lt;code&gt;g0&lt;/code&gt; 和 &lt;code&gt;m0&lt;/code&gt; 变量。&lt;code&gt;m0&lt;/code&gt; Machine 代表着当前初始化线程，而 &lt;code&gt;g0&lt;/code&gt; 代表着初始化线程 &lt;code&gt;m0&lt;/code&gt; 的 &lt;code&gt;system stack&lt;/code&gt;，似乎还缺一个 &lt;code&gt;p0&lt;/code&gt; ？
实际上所有的 Processor 都会放到 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/runtime2.go#L722&#34;&gt;allp&lt;/a&gt; 里。&lt;code&gt;runtime.schedinit&lt;/code&gt; 会在调用 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L3507&#34;&gt;procresize&lt;/a&gt; 时为 &lt;code&gt;m0&lt;/code&gt; 分配上 &lt;code&gt;allp[0]&lt;/code&gt; 。所以到目前为止，初始化线程运行模式是符合上文提到的 G/P/M 模型的。&lt;/p&gt;
&lt;p&gt;大量的初始化工作做完之后，会调用 &lt;code&gt;runtime.newproc&lt;/code&gt; 为 &lt;code&gt;mainPC&lt;/code&gt; 方法生成一个 Goroutine。
虽然 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L106&#34;&gt;mainPC&lt;/a&gt; 并不是我们平时写的那个 main 函数，但是它会调用我们写的 main 函数，所以 main 函数是会以 Goroutine 的形式运行。&lt;/p&gt;
&lt;p&gt;有了 Goroutine 之后，那么 Machine 怎么执行呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/asm_amd64.s

TEXT runtime·rt0_go(SB),NOSPLIT,$0
         ...

// set the per-goroutine and per-mach &amp;quot;registers&amp;quot;
        // save m-&amp;gt;g0 = g0
        MOVQ    CX, m_g0(AX)
        // save m0 to g0-&amp;gt;m
        MOVQ    AX, g_m(CX)

        ...
        CALL    runtime·args(SB)
        CALL    runtime·osinit(SB)
        CALL    runtime·schedinit(SB)

        // create a new goroutine to start program
        MOVQ    $runtime·mainPC(SB), AX        // entry
        PUSHQ   AX
        PUSHQ   $0      // arg size
        CALL    runtime·newproc(SB)

        ...
        // start this M
        CALL    runtime·mstart(SB)  &amp;lt;=== I&#39;m here!

        MOVL    $0xf1, 0xf1  // crash
        RET
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;4-machine-----work-stealing&#34;&gt;4. Machine &amp;mdash; Work Stealing&lt;/h3&gt;
&lt;p&gt;在上一节查看 &lt;code&gt;rt0_go&lt;/code&gt; 汇编代码的时候，发现最后一段代码 &lt;code&gt;CALL runtime.mstart(SB)&lt;/code&gt; 是用来启动 Machine。&lt;/p&gt;
&lt;p&gt;因为在 Golang 的世界里，任务的执行需要 Machine 本身自己去获取。
每个 Machine 运行前都会绑定一个 Processor，Machine 会逐步消耗完当前 Processor 队列。
为了防止某些 Machine 没有事情可做，某些 Machine 忙死，所以 &lt;code&gt;runtime&lt;/code&gt; 会做了两件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前 Processor 队列已满，Machine 会将本地队列的部分 Goroutine 迁移到 Global Runnable Queue 中;&lt;/li&gt;
&lt;li&gt;Machine 绑定的 Processor 没有可执行的 Goroutine 时，它会去 Global Runnable Queue、Net Network 和其他 Processor 的队列中抢任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种调度模式叫做 &lt;a href=&#34;https://en.wikipedia.org/wiki/Work_stealing&#34;&gt;Work Stealing&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;41-如何执行-goroutine&#34;&gt;4.1 如何执行 Goroutine？&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/proc.go

func mstart() {
        ...
        } else if _g_.m != &amp;amp;m0 {
                acquirep(_g_.m.nextp.ptr()) // 绑定 Processor
                _g_.m.nextp = 0
        }
        schedule()
}

mstart() =&amp;gt; schedule() =&amp;gt; execute() =&amp;gt; xxx() =&amp;gt; goexit()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;runtime.mstart&lt;/code&gt; 函数会调用 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L2195&#34;&gt;schedule&lt;/a&gt; 函数去寻找可执行的 Goroutine，查找顺序大致是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Local Runnable Queue&lt;/li&gt;
&lt;li&gt;Global Runnable Queue&lt;/li&gt;
&lt;li&gt;Net Network&lt;/li&gt;
&lt;li&gt;Other Processor&amp;rsquo;s Runnable Queue&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;需找可执行的 Goroutine 的逻辑都在 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L1919&#34;&gt;findrunnable&lt;/a&gt; 里。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;找到任何一个可执行的 Goroutine 之后，会调用 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L1886&#34;&gt;execute&lt;/a&gt; 去切换到 &lt;code&gt;g.sched&lt;/code&gt; 相应的调用栈，这样 Machine 就会执行我们代码里创建 Goroutine。&lt;/p&gt;
&lt;p&gt;执行完毕之后会 &lt;code&gt;RET&lt;/code&gt; 到 &lt;code&gt;goexit&lt;/code&gt;, &lt;code&gt;goexit&lt;/code&gt; 会调用 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L2366&#34;&gt;goexit0&lt;/a&gt; 进行清理工作，
然后再进入 &lt;code&gt;schedule&lt;/code&gt; 模式。如果这个时候释放了当前 Machine，那么每次执行 Goroutine 都要创建新的 OS-Thread，这样的代价略大。
所以 Machine 会不断地拿任务执行，直到没有任务。
当 Machine 没有可执行的任务时，它会在 &lt;code&gt;findrunnable&lt;/code&gt; 中调用 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L1653&#34;&gt;stopm&lt;/a&gt; 进入休眠状态。&lt;/p&gt;
&lt;p&gt;那么谁来激活这些休眠状态的 Machine ？&lt;/p&gt;
&lt;h4 id=&#34;42-wake-up&#34;&gt;4.2 Wake Up&lt;/h4&gt;
&lt;p&gt;常见的激活时机就是新的 Goroutine 创建出来的时候。我们回头看看 &lt;code&gt;runtime.newproc&lt;/code&gt; 返回前都做了什么。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/proc.go @ func newproc1

if atomic.Load(&amp;amp;sched.npidle) != 0 &amp;amp;&amp;amp; atomic.Load(&amp;amp;sched.nmspinning) == 0 &amp;amp;&amp;amp; runtimeInitTime != 0 {
        wakep()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当 Machine 找不到可执行的 Goroutine 时，但是还在努力地寻找可执行的 Goroutine，这段时间它属于 &lt;code&gt;spinning&lt;/code&gt; 的状态。
它实在是找不到了，它才回释放当前 Processor 进入休眠状态。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;atomic.Load(&amp;amp;sched.npidle) != 0 &amp;amp;&amp;amp; atomic.Load(&amp;amp;sched.nmspinning) == 0&lt;/code&gt; 指的是有空闲的 Processor 而没有 &lt;code&gt;spinning&lt;/code&gt; 状态的 Machine。
这个时候可能是有休眠状态的 Machine，可能是程序刚启动的时候并没有足够的 Machine。当遇到这种情况，当前 Machine 会执行 &lt;code&gt;wakep&lt;/code&gt;，让程序能快速地消化 Goroutine。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在初始化过程中，为 &lt;code&gt;runtime.main&lt;/code&gt; 函数创建的第一个 Goroutine 并不需要调用 &lt;code&gt;wakep&lt;/code&gt;，所以在该判断条件里 &lt;code&gt;runtimeInitTime != 0&lt;/code&gt; 会失败。
&lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L123&#34;&gt;runtimeInitTime&lt;/a&gt; 会在 &lt;code&gt;runtime.main&lt;/code&gt; 函数中被赋值，表明正式开始执行任务啦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;wakep&lt;/code&gt; 首先会查看有没有空闲的 Machine，如果找到而且状态合理，那么就会激活它。如果没有找到，那么会创建一个新的 &lt;code&gt;spinning&lt;/code&gt; Machine。&lt;/p&gt;
&lt;p&gt;在 Golang 世界里，新创建的 Machine 可以认为它属于 &lt;code&gt;spinning&lt;/code&gt;，因为创建 OS-Thread 有一定代价，一旦创建出来了它就要去干活。
除此之外，Golang 创建新的线程并不会直接交付任务给它，而是让它调用 &lt;code&gt;runtime.mstart&lt;/code&gt; 方法自己去找活做。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/proc.go

func wakep() {
        // be conservative about spinning threads
        if !atomic.Cas(&amp;amp;sched.nmspinning, 0, 1) {
                return
        }
        startm(nil, true)
}

func mspinning() {
        // startm&#39;s caller incremented nmspinning. Set the new M&#39;s spinning.
        getg().m.spinning = true
}

func startm(_p_ *p, spinning bool) {
        lock(&amp;amp;sched.lock)
        if _p_ == nil {
                _p_ = pidleget()
                if _p_ == nil {
                        unlock(&amp;amp;sched.lock)
                        if spinning {
                                // The caller incremented nmspinning, but there are no idle Ps,
                                // so it&#39;s okay to just undo the increment and give up.
                                if int32(atomic.Xadd(&amp;amp;sched.nmspinning, -1)) &amp;lt; 0 {
                                        throw(&amp;quot;startm: negative nmspinning&amp;quot;)
                                }
                        }
                        return
                }
        }
        mp := mget()
        unlock(&amp;amp;sched.lock)
        if mp == nil {
                var fn func()
                if spinning {
                        // The caller incremented nmspinning, so set m.spinning in the new M.
                        fn = mspinning
                }
                newm(fn, _p_)
                return
        }
        ...
        mp.spinning = spinning
        mp.nextp.set(_p_)
        notewakeup(&amp;amp;mp.park)
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;在 Linux 平台上，&lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L1626&#34;&gt;newm&lt;/a&gt; 会调用 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/os_linux.go#L144&#34;&gt;newosproc&lt;/a&gt; 来产生新的 OS-Thread。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;5-preemptive&#34;&gt;5. Preemptive&lt;/h3&gt;
&lt;p&gt;Machine 会在全局范围内查找 Goroutine 来执行，似乎还缺少角色去通知 Machine 释放当前 Goroutine，总不能执行完毕再切换吧。
我们知道操作系统会根据时钟周期性地触发系统中断来进行调度，Golang 是用户态的线程调度，那它怎么通知 Machine 呢？&lt;/p&gt;
&lt;p&gt;回忆上文, 提到了有些 Machine 执行任务前它并不需要绑定 Processor，它们都做什么任务呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/proc.go

func main() {
        ...
        systemstack(func() {
                newm(sysmon, nil)
        })
        ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 &lt;code&gt;runtime.main&lt;/code&gt; 函数中会启动新的 OS-Thread 去执行 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L3813&#34;&gt;sysmon&lt;/a&gt; 函数。
该函数会以一个上帝视角去查看 Goroutine/Machine/Processor 的运行情况，并会调用 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L3940&#34;&gt;retake&lt;/a&gt; 去让 Machine 释放正在运行的 Goroutine。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/proc.go

// forcePreemptNS is the time slice given to a G before it is
// preempted.
const forcePreemptNS = 10 * 1000 * 1000 // 10ms

func retake(now int64) uint32 {
        for i := int32(0); i &amp;lt; gomaxprocs; i++ {
                _p_ := allp[i]
                if _p_ == nil {
                        continue
                }
                pd := &amp;amp;_p_.sysmontick
                s := _p_.status

                ...
                } else if s == _Prunning {
                        // Preempt G if it&#39;s running for too long.
                        t := int64(_p_.schedtick)
                        if int64(pd.schedtick) != t {
                                pd.schedtick = uint32(t)
                                pd.schedwhen = now
                                continue
                        }
                        if pd.schedwhen+forcePreemptNS &amp;gt; now {
                                continue
                        }
                        preemptone(_p_)
                }
        }
        ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Processor 在 Machine 上执行时间超过 10ms，Machine 会给调用 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L4024&#34;&gt;preemptone&lt;/a&gt;
给当前 Goroutine 加上标记：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/proc.go

func preemptone(_p_ *p) bool {
        ...
        gp.preempt = true

        // Every call in a go routine checks for stack overflow by
        // comparing the current stack pointer to gp-&amp;gt;stackguard0.
        // Setting gp-&amp;gt;stackguard0 to StackPreempt folds
        // preemption into the normal stack overflow check.
        gp.stackguard0 = stackPreempt
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到它并不是直接发信号给 Machine 让它立即释放，而是让 Goroutine 自己释放，那它什么时候会释放？&lt;/p&gt;
&lt;p&gt;Golang 创建新的 Goroutine 时，都会分配有限的调用栈空间，按需进行拓展或者收缩。
所以在执行下一个函数时，它会检查调用栈是否溢出。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  main go tool objdump -s &amp;quot;main.main&amp;quot; main
TEXT main.main(SB) /root/workspace/main/main.go
  main.go:7             0x450a60                64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX
  main.go:7             0x450a69                483b6110                CMPQ 0x10(CX), SP
  main.go:7             0x450a6d                7630                    JBE 0x450a9f    &amp;lt;= I&#39;m here!!
  main.go:7             0x450a6f                4883ec18                SUBQ $0x18, SP
  main.go:7             0x450a73                48896c2410              MOVQ BP, 0x10(SP)
  main.go:7             0x450a78                488d6c2410              LEAQ 0x10(SP), BP
  main.go:8             0x450a7d                c7042400000000          MOVL $0x0, 0(SP)
  main.go:8             0x450a84                488d05e5190200          LEAQ 0x219e5(IP), AX
  main.go:8             0x450a8b                4889442408              MOVQ AX, 0x8(SP)
  main.go:8             0x450a90                e88bb4fdff              CALL runtime.newproc(SB)
  main.go:9             0x450a95                488b6c2410              MOVQ 0x10(SP), BP
  main.go:9             0x450a9a                4883c418                ADDQ $0x18, SP
  main.go:9             0x450a9e                c3                      RET
  main.go:7             0x450a9f                e88c7dffff              CALL runtime.morestack_noctxt(SB)
  main.go:7             0x450aa4                ebba                    JMP main.main(SB)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;gp.stackguard0 = stackPreempt&lt;/code&gt; 设置会让检查失败，进入 &lt;code&gt;runtime.morestack_noctxt&lt;/code&gt; 函数。
它发现是因为 &lt;code&gt;runtime.retake&lt;/code&gt; 造成，Machine 会保存当前 Goroutine 的执行上下文，重新进入 &lt;code&gt;runtime.schedule&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你可能会问，如果这个 Goroutine 里面没有函数调用怎么办？请查看这个 &lt;a href=&#34;https://github.com/golang/go/issues/11462&#34;&gt;issues/11462&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;一般情况下，这样的函数不是死循环，就是很快就退出了，实际开发中这种的类型函数不会太多。&lt;/p&gt;
&lt;h3 id=&#34;6-关于线程数目&#34;&gt;6. 关于线程数目&lt;/h3&gt;
&lt;p&gt;Processor 的数目决定 go binary 能同时处理多少 Goroutine 的能力，感觉 Machine 的数目应该不会太多。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  scheduler cat -n main.go
     1  package main
     2
     3  import (
     4          &amp;quot;log&amp;quot;
     5          &amp;quot;net/http&amp;quot;
     6          &amp;quot;syscall&amp;quot;
     7  )
     8
     9  func main() {
    10          http.HandleFunc(&amp;quot;/sleep&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
    11                  tspec := syscall.NsecToTimespec(1000 * 1000 * 1000)
    12                  if err := syscall.Nanosleep(&amp;amp;tspec, &amp;amp;tspec); err != nil {
    13                          panic(err)
    14                  }
    15          })
    16
    17          http.HandleFunc(&amp;quot;/echo&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
    18                  w.Write([]byte(&amp;quot;hello&amp;quot;))
    19          })
    20
    21          log.Fatal(http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil))
    22  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Golang 提供了 &lt;code&gt;GODEBUG&lt;/code&gt; 环境变量来观察当前 Goroutine/Processor/Machine 的状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  scheduler go build
➜  scheduler GODEBUG=schedtrace=2000 ./scheduler
SCHED 0ms: gomaxprocs=4 idleprocs=1 threads=6 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0]
SCHED 2008ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 4016ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;GODEBUG=schedtrace=2000&lt;/code&gt; 会开启 &lt;code&gt;schedtrace&lt;/code&gt; 模式，它会让 &lt;code&gt;sysmon&lt;/code&gt; 中调用 &lt;a href=&#34;https://github.com/golang/go/blob/048c9cfaacb6fe7ac342b0acd8ca8322b6c49508/src/runtime/proc.go#L4046&#34;&gt;schedtrace&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/proc.go

func schedtrace(detailed bool) {
        ...
        print(&amp;quot;SCHED &amp;quot;, (now-starttime)/1e6, &amp;quot;ms: gomaxprocs=&amp;quot;, gomaxprocs, &amp;quot; idleprocs=&amp;quot;, sched.npidle, &amp;quot; threads=&amp;quot;, sched.mcount, &amp;quot; spinningthreads=&amp;quot;, sched.nmspinning, &amp;quot; idlethreads=&amp;quot;, sched.nmidle, &amp;quot; runqueue=&amp;quot;, sched.runqsize)
        ...
}

gomaxprocs:      当前 Processor 的数目
idleprocs:       空闲 Processor 的数目
threads:         共创建了多少个 Machine
spinningthreads: spinning 状态的 Machine
nmidle:          休眠状态的 Machine 数目
runqueue:        Global Runnable Queue 队列长度
[x, y, z..]:     每个 Processor 的 Local Runnable Queue 队列长度
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面我们会通过 &lt;a href=&#34;https://github.com/wg/wrk&#34;&gt;wrk&lt;/a&gt; 对 sleep 和 echo 这两个 endpoint 进行压力测试，并关注 Machine 的数目变化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  scheduler GODEBUG=schedtrace=2000 ./scheduler &amp;gt; echo_result 2&amp;gt;&amp;amp;1 &amp;amp;
[1] 6015
➜  scheduler wrk -t12 -c400 -d30s http://localhost:8080/echo
Running 30s test @ http://localhost:8080/echo
  12 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    51.15ms  104.96ms   1.31s    89.35%
    Req/Sec     4.97k     4.48k   20.53k    74.84%
  1780311 requests in 30.08s, 205.44MB read
Requests/sec:  59178.76
Transfer/sec:      6.83MB
➜  scheduler head -n 20 echo_result
SCHED 0ms: gomaxprocs=4 idleprocs=1 threads=6 spinningthreads=2 idlethreads=0 runqueue=0 [0 0 0 0]
SCHED 2000ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 4005ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 6008ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 8014ms: gomaxprocs=4 idleprocs=0 threads=12 spinningthreads=0 idlethreads=6 runqueue=195 [20 53 6 32]
SCHED 10018ms: gomaxprocs=4 idleprocs=0 threads=12 spinningthreads=0 idlethreads=6 runqueue=272 [65 16 5 37]
SCHED 12021ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=218 [97 5 52 7]
SCHED 14028ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=41 [2 1 25 3]
SCHED 16029ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=178 [10 31 45 38]
SCHED 18033ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=144 [15 92 47 0]
SCHED 20034ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=195 [1 7 4 41]
SCHED 22035ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=159 [88 14 41 5]
SCHED 24038ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=231 [47 19 53 41]
SCHED 26046ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=6 [1 0 1 10]
SCHED 28049ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=133 [61 13 97 53]
SCHED 30049ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=220 [13 49 29 28]
SCHED 32058ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=138 [40 93 63 50]
SCHED 34062ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=266 [51 9 38 31]
SCHED 36068ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=189 [1 3 46 14]
SCHED 38084ms: gomaxprocs=4 idleprocs=4 threads=13 spinningthreads=0 idlethreads=10 runqueue=0 [0 0 0 0]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试 &lt;code&gt;localhost:8080/echo&lt;/code&gt; 30s 之后，发现当前线程数目为 13。接下来再看看 &lt;code&gt;localhost:8080/sleep&lt;/code&gt; 的情况。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  scheduler GODEBUG=schedtrace=1000 ./scheduler &amp;gt; sleep_result 2&amp;gt;&amp;amp;1 &amp;amp;
[1] 8284
➜  scheduler wrk -t12 -c400 -d30s http://localhost:8080/sleep
Running 30s test @ http://localhost:8080/sleep
  12 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency     1.01s    13.52ms   1.20s    86.57%
    Req/Sec    83.06     89.44   320.00     79.12%
  11370 requests in 30.10s, 1.26MB read
Requests/sec:    377.71
Transfer/sec:     42.79KB
➜  scheduler cat sleep_result
SCHED 0ms: gomaxprocs=4 idleprocs=1 threads=6 spinningthreads=2 idlethreads=0 runqueue=0 [0 0 0 0]
SCHED 1000ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 2011ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 3013ms: gomaxprocs=4 idleprocs=4 threads=282 spinningthreads=0 idlethreads=1 runqueue=0 [0 0 0 0]
SCHED 4020ms: gomaxprocs=4 idleprocs=4 threads=400 spinningthreads=0 idlethreads=1 runqueue=0 [0 0 0 0]
SCHED 5028ms: gomaxprocs=4 idleprocs=4 threads=401 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0]
SCHED 6037ms: gomaxprocs=4 idleprocs=4 threads=401 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0]
SCHED 7038ms: gomaxprocs=4 idleprocs=4 threads=402 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 8039ms: gomaxprocs=4 idleprocs=4 threads=402 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 9046ms: gomaxprocs=4 idleprocs=4 threads=402 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 10049ms: gomaxprocs=4 idleprocs=4 threads=402 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 11056ms: gomaxprocs=4 idleprocs=4 threads=402 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 12058ms: gomaxprocs=4 idleprocs=4 threads=402 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 13058ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 14062ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 15064ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 16066ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 17068ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 18072ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 19083ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 20084ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 21086ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 22088ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 23096ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 24100ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 25100ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 26100ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 27103ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 28110ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 33131ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=396 runqueue=0 [0 0 0 0]
SCHED 34137ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=400 runqueue=0 [0 0 0 0]
SCHED 35140ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=400 runqueue=0 [0 0 0 0]
SCHED 36150ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=400 runqueue=0 [0 0 0 0]
SCHED 37155ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=400 runqueue=0 [0 0 0 0]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;压力测试完毕之后，创建的线程明显比 &lt;code&gt;localhost:8080/echo&lt;/code&gt; 多不少。在压测过程中采用 &lt;code&gt;gdb attach&lt;/code&gt; + &lt;code&gt;thread apply all bt&lt;/code&gt; 查看这些线程都在做什么:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
Thread 152 (Thread 0x7f4744fb1700 (LWP 27863)):
#0  syscall.Syscall () at /usr/local/go/src/syscall/asm_linux_amd64.s:27
#1  0x000000000047151f in syscall.Nanosleep (time=0xc42119ac90,
#2  0x000000000060f042 in main.main.func1 (w=..., r=0xc4218d8900)
#3  0x00000000005e8974 in net/http.HandlerFunc.ServeHTTP (f=
#4  0x00000000005ea020 in net/http.(*ServeMux).ServeHTTP (
#5  0x00000000005eafa4 in net/http.serverHandler.ServeHTTP (sh=..., rw=...,
#6  0x00000000005e7a5d in net/http.(*conn).serve (c=0xc420263360, ctx=...)
#7  0x0000000000458e31 in runtime.goexit ()
#8  0x000000c420263360 in ?? ()
#9  0x00000000007cf100 in crypto/elliptic.p224ZeroModP63 ()
#10 0x000000c421180ec0 in ?? ()
#11 0x0000000000000000 in ?? ()
Thread 151 (Thread 0x7f47457b2700 (LWP 27862)):
#0  syscall.Syscall () at /usr/local/go/src/syscall/asm_linux_amd64.s:27
#1  0x000000000047151f in syscall.Nanosleep (time=0xc4206bcc90,
#2  0x000000000060f042 in main.main.func1 (w=..., r=0xc4218cd300)
#3  0x00000000005e8974 in net/http.HandlerFunc.ServeHTTP (f=
#4  0x00000000005ea020 in net/http.(*ServeMux).ServeHTTP (
#5  0x00000000005eafa4 in net/http.serverHandler.ServeHTTP (sh=..., rw=...,
#6  0x00000000005e7a5d in net/http.(*conn).serve (c=0xc42048afa0, ctx=...)
#7  0x0000000000458e31 in runtime.goexit ()
#8  0x000000c42048afa0 in ?? ()
#9  0x00000000007cf100 in crypto/elliptic.p224ZeroModP63 ()
#10 0x000000c4204fd080 in ?? ()
#11 0x0000000000000000 in ?? ()
...
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Red Hat 系列的机器可以直接使用 &lt;code&gt;pstack&lt;/code&gt; 去 Dump 当前主进程内部的调用栈情况，可惜 Ubuntu 64 Bit 没有这样的包，只能自己写一个脚本去调用 &lt;code&gt;gdb&lt;/code&gt; 来 Dump。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;截取两个线程的调用栈信息，发现它们都在休眠状态，几乎都卡在 &lt;code&gt;/usr/local/go/src/syscall/asm_linux_amd64.s&lt;/code&gt; 上。如果都阻塞了，那么它是怎么处理新来的请求？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/syscall/asm_linux_amd64.s

TEXT    ·Syscall(SB),NOSPLIT,$0-56
        CALL    runtime·entersyscall(SB)
        MOVQ    a1+8(FP), DI
        MOVQ    a2+16(FP), SI
        MOVQ    a3+24(FP), DX
        MOVQ    $0, R10
        MOVQ    $0, R8
        MOVQ    $0, R9
        MOVQ    trap+0(FP), AX	// syscall entry
        SYSCALL
        CMPQ    AX, $0xfffffffffffff001
        JLS     ok
        MOVQ    $-1, r1+32(FP)
        MOVQ    $0, r2+40(FP)
        NEGQ    AX
        MOVQ    AX, err+48(FP)
        CALL    runtime·exitsyscall(SB)
        RET
ok:
        MOVQ    AX, r1+32(FP)
        MOVQ    DX, r2+40(FP)
        MOVQ    $0, err+48(FP)
        CALL    runtime·exitsyscall(SB)
        RET
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Syscall&lt;/code&gt; 会调用 &lt;code&gt;runtime.entersyscall&lt;/code&gt; 会将当前 Processor 的状态设置为 &lt;code&gt;_Psyscall&lt;/code&gt;。
当进入系统调用时间过长时，&lt;code&gt;retake&lt;/code&gt; 函数在这些 &lt;code&gt;_Psyscall&lt;/code&gt; Processor 的状态改为 &lt;code&gt;_Pidle&lt;/code&gt;，防止长时间地占用 Processor 导致整体不工作。&lt;/p&gt;
&lt;p&gt;进入空闲状态的 Processor 可能会被 &lt;code&gt;wakep&lt;/code&gt; 函数创建出来的新进程绑定上，然而新的 Goroutine 可能还会陷入长时间的系统调用，这一来就进入恶性循环，导致 go binary 创建出大量的线程。&lt;/p&gt;
&lt;p&gt;当然，Golang 会限制这个线程数目。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/proc.go

func checkmcount() {
        // sched lock is held
        if sched.mcount &amp;gt; sched.maxmcount {
                print(&amp;quot;runtime: program exceeds &amp;quot;, sched.maxmcount, &amp;quot;-thread limit\n&amp;quot;)
                throw(&amp;quot;thread exhaustion&amp;quot;)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当 Machine 从内核态回来之后，会进入 &lt;code&gt;runtime.exitsyscall&lt;/code&gt;。
如果执行时间很短，它会尝试地夺回之前的 Processor ；或者是尝试绑定空闲的 Processor，一旦绑定上了 Processor ，它便会继续运行当前的 Goroutine。
如果都失败了，Machine 因为没有可绑定的 Processor 而将当前的 Goroutine 放回到全局队列中，将自己进入休眠状态，等待其他 Machine 来唤醒。&lt;/p&gt;
&lt;p&gt;一般情况下，go binary 不会创建特别多的线程，但是上线的代码还是需要做一下压测，了解一下代码的实际情况。
一旦真的创建大量的线程了，Golang 目前的版本是不会回收这些空闲的线程。
不过好在 Go10/Go11 会改进这一缺点，详情请查看 &lt;a href=&#34;https://github.com/golang/go/issues/14592&#34;&gt;issues/14592&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;7-总结&#34;&gt;7. 总结&lt;/h3&gt;
&lt;p&gt;本文粗粒度地介绍了 Golang Goroutine Scheduler 的工作流程，并没有涉及到垃圾回收，Netpoll 以及 Channel Send/Receive 对调度的影响，希望能让读者有个大体的认识。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;runtime.mstart&lt;/code&gt; 内部的细节很多，而且很多并发操作都建立在无锁的基础上，这样能减少锁对性能的影响，感兴趣的朋友可以根据上文提到的函数一步一步地查看，应该会有不少的收获。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;8-reference&#34;&gt;8. Reference&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://talks.golang.org/2012/waza.slide&#34;&gt;Rob Pike&amp;rsquo;s 2012 Concurrency is not Parallelism&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/asm&#34;&gt;A Quick Guide to Go&amp;rsquo;s Assembler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.mmq8lm48qfcw&#34;&gt;Scalable Go Scheduler Design Doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://software.intel.com/en-us/blogs/2014/05/10/debugging-performance-issues-in-go-programs&#34;&gt;Debugging performance issues in Go programs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
          <title>Protobuf 3.0 编码</title>
          <link>/post/2017-protobuf-3-encoding/</link>
          <pubDate>Wed, 15 Nov 2017 00:00:00 +0000</pubDate>
          <guid>https://fuweid.com/post/2017-protobuf-3-encoding/</guid>
          <description>&lt;p&gt;Protobuf 是 G 厂开源的序列化数据的方法，可用来通信或者存储数据。它采用 IDL 描述数据接口，使得不同语言编写的程序可以根据同一接口通信。不同编程语言也可以根据 IDL 的描述来生成对应数据结构，该数据结构用来编解码。为此，G 厂为主流开发语言都提供代码生成器（即 protoc ）。&lt;/p&gt;
&lt;p&gt;为了更好地了解一些细节，本文将主要描述 Protobuf 3.0 的编码规则。
Protobuf 里面主要采用 Varint 和 Zig-Zag 的方式来对整型数字进行编码。在理解 Protobuf 之前，需要先了解这两种编码方式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Protobuf 采用是 Little Endian 的方式编码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-varints&#34;&gt;1. Varints&lt;/h3&gt;
&lt;p&gt;int64, int32, uint64, uint32 都有固定的二进制位数。&lt;/p&gt;
&lt;p&gt;如果将这些数字序列化成二进制流的时候，需要额外空间告知接收方数据的长度。对于采用 int64, uint64 这两种类型的数据而言，如果大部分时间都只是使用较小的数值，那么会极大地浪费传输带宽和存储空间。针对这两个问题，Protobuf 采用 Varints 的编码方式。&lt;/p&gt;
&lt;p&gt;Varints 将源数据按照 &lt;strong&gt;7 bit&lt;/strong&gt; 分组，每 &lt;strong&gt;7 bit&lt;/strong&gt; 加 &lt;strong&gt;MSB (Most Significant Bit)&lt;/strong&gt; 标识位来组成一个字节，其中 MSB 标识位用来判断是否存在后序分组。如果出现多组的情况，那么低有效位比特组优先。&lt;/p&gt;
&lt;p&gt;64 有效位为 7 bit，不需要额外的字节，所以 MSB 比特位为 0。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;64 = 0100 0000
  =&amp;gt; 0100 0000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;16657 有效位为 15 bit，需要分成三组字节，前两组字节为了提示还存在后续字节，所以前两组字节的 MSB 比特位为 1。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;16657 = 0100 0001 0001 0001
  =&amp;gt;  001 0001 ++ 000 0010 ++ 000 0001 (reverse the groups of 7 bits)
  =&amp;gt;  1001 0001 1000 0010 0000 0001
  =&amp;gt;  0x91 0x82 0x01
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于负数的最高有效位为 1，int32 类型的负数固定需要 5 字节，而 int64 的负数需要 10 字节，基本上告别了空间效益。所以 Varints 在编码负数时，需要引入 Zig-Zag 编码解决压缩问题。&lt;/p&gt;
&lt;h3 id=&#34;2-zig-zag&#34;&gt;2. Zig-Zag&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Signed Original&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Encoded As&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2147483647&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4294967294&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-2147483648&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4294967295&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Zig-Zag 编码可以将负数转化成正数，如上表所示。根据上述表格可以很快地得出结论，负数 &lt;code&gt;n&lt;/code&gt; 编码后的值为 &lt;code&gt;2 * abs(n) - 1&lt;/code&gt;，而正数，编码后为 &lt;code&gt;2 * n&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;实际上，Zig-Zag 会采用以下方式来进行编解码。为了简单起见，接下来将使用 &lt;strong&gt;int8&lt;/strong&gt; 类型分析 Zig-Zag 编解码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;encode(n):
  int64 =&amp;gt; (n &amp;lt;&amp;lt; 1) ^ (n &amp;gt;&amp;gt; 63)
  int32 =&amp;gt; (n &amp;lt;&amp;lt; 1) ^ (n &amp;gt;&amp;gt; 31)
  int64 =&amp;gt; (n &amp;lt;&amp;lt; 1) ^ (n &amp;gt;&amp;gt; 15)
  int8  =&amp;gt; (n &amp;lt;&amp;lt; 1) ^ (n &amp;gt;&amp;gt; 7)

decode(n): 
  (n &amp;gt;&amp;gt;&amp;gt; 1) ^ - (n &amp;amp; 1)

NOTE: 
  &amp;lt;&amp;lt;, &amp;gt;&amp;gt; Arithmetic Shift
  &amp;gt;&amp;gt;&amp;gt;       Logical Shift
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;21-encode&#34;&gt;2.1 Encode&lt;/h4&gt;
&lt;p&gt;Zig-Zag 会将最高符号位算数位移到 &lt;strong&gt;LSB（Least significant bit）&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;positive: (n &amp;gt;&amp;gt; 7) =&amp;gt; 0x00
negative: (n &amp;gt;&amp;gt; 7) =&amp;gt; 0xFF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;任何数值与 &lt;code&gt;0x00&lt;/code&gt; 异或都等到本身，而与 &lt;code&gt;0xFF&lt;/code&gt; 异或会现成按位取反。
根据补码互补的原理，一个数 &lt;code&gt;A&lt;/code&gt; 与 &lt;code&gt;0xFF&lt;/code&gt; 异或就变成 &lt;code&gt;-A - 1&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A ^ 0xFF = ~A = -A - 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此，负数经过运算之后变成 &lt;code&gt;- 2 * n - 1&lt;/code&gt;。而正数经过运算只是简单扩大两倍而已，将会 &lt;code&gt;2 * n&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-2 =&amp;gt; 3

  1111 1100 (1111 1110 &amp;lt;&amp;lt; 1)
^ 1111 1111 (1111 1110 &amp;gt;&amp;gt; 7)
-----------------
  0000 0011 (-2 &amp;lt;&amp;lt; 1) ^ (-2 &amp;gt;&amp;gt; 7)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;22-decode&#34;&gt;2.2 Decode&lt;/h4&gt;
&lt;p&gt;Zig-Zag 编码的时候将最高符号位移位到了 LSB，解码的时候需要还原到 MSB。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;positive: - (n &amp;amp; 1) = 0  =&amp;gt; 0x00
negative: - (n &amp;amp; 1) = -1 =&amp;gt; 0xFF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;n &amp;gt;&amp;gt;&amp;gt; 1&lt;/code&gt; 逻辑右移的过程相当于做了除以 2 的操作，所有奇数的逻辑右移都可以得到 &lt;code&gt;n / 2 = (n - 1)/2&lt;/code&gt;，根据解码的表达式可以得到以下推断。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n &amp;amp; 1 == 0:
  (n &amp;gt;&amp;gt;&amp;gt; 1) ^ -(n &amp;amp; 1) = (n &amp;gt;&amp;gt;&amp;gt; 1) = n / 2

n &amp;amp; 1 == 1:
  (n &amp;gt;&amp;gt;&amp;gt; 1) ^ -(n &amp;amp; 1) = ~(n &amp;gt;&amp;gt;&amp;gt; 1) = - (n &amp;gt;&amp;gt;&amp;gt; 1) - 1 = - (n + 1) / 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;255&lt;/code&gt; 解码之后的结果为 &lt;code&gt;-128&lt;/code&gt;。如果解码过程是通过先加后除的方式，将会出现溢出错误。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;255 =&amp;gt; -128

  0111 1111 (1111 1111 &amp;gt;&amp;gt;&amp;gt; 1)
^ 1111 1111 (-(1111 1111 &amp;amp; 1))
-----------------
  1000 0000 (255 &amp;gt;&amp;gt;&amp;gt; 1) ^ -(255 &amp;amp; 1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Protobuf 在编码负数的时候，它提供了 Zig-Zag 编码的可能，可在此基础上在使用 Varints 来达到压缩效果。&lt;/p&gt;
&lt;h3 id=&#34;3-message&#34;&gt;3. Message&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;message Simple {
  //
  //     _ declared type
  //    /      _ field name
  //   /      /     _ field number, alias tag
  //  /      /     /
  int64 o_int64 = 16;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Protobuf Message 是一系列的 Key-Value 二进制数据流。在编码过程中，仅仅使用 &lt;strong&gt;field number&lt;/strong&gt; 和 &lt;strong&gt;wire type&lt;/strong&gt; 为 Key，而 &lt;strong&gt;declared type&lt;/strong&gt; 和 &lt;strong&gt;field name&lt;/strong&gt; 会辅助解码来判断数据的具体类型，其中 wire type 有以下几种类型。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Wire Type&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Meaning&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Used For&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Varint&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;int32, int64, uint32, uint64, sint32, sint64, bool, enum&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64-bit&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;fixed64, sfixed64, double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Length-delimited&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;string, bytes, embedded messages, packed repeated fields&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Start Group&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;groups (deprecated)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;End Group&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;groups (deprecated)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32-bit&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;fixed32, sfixed64, float&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;每一个 Key 都是 &lt;code&gt;(field number &amp;lt;&amp;lt; 3 | wire type)&lt;/code&gt; 的 Varint 编码值。&lt;/p&gt;
&lt;p&gt;现在按照 Simple 的约定发送来以下数据。接下来，我们将作为人工解码器来分析这份数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;80 01 96 01
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先 Protobuf Message 编码之后是一系列的 Key-Value，因此首字节属于 Key 的一部分。Key 首字节 &lt;code&gt;80&lt;/code&gt; 的 MSB 标志位为 1，说明 Key 除了 &lt;code&gt;80&lt;/code&gt; 外还有后序字节。根据上文 Varints 的介绍，可以得到 Key 中 field number(&lt;code&gt;16&lt;/code&gt;) 和 wire type(&lt;code&gt;0&lt;/code&gt;)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;80 01

1000 0000 0000 0001
   =&amp;gt; 000 0000 ++ 000 0001  (drop the msb)
   =&amp;gt; 1000 0000             (reverse the groups of 7 bits)
   =&amp;gt; (0001 0000 &amp;lt;&amp;lt; 3) | 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;按照同样方式，Value 数据为 &lt;code&gt;96 01&lt;/code&gt;。经过 Varints 解码后为 150，所以 &lt;code&gt;80 01 96 01&lt;/code&gt; 代表着 &lt;code&gt;Simple.o_int64 = 150&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;96 01

1001 0110 0000 0001
  =&amp;gt; 001 0110 ++ 000 0001    (drop the msb)
  =&amp;gt; 1001 0110               (reverse the groups of 7 bits)
  =&amp;gt; 128 + 16 + 4 + 2 = 150
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;4-wire-type&#34;&gt;4. Wire Type&lt;/h3&gt;
&lt;h4 id=&#34;41-varint---sint32sint64&#34;&gt;4.1 Varint - sint32/sint64&lt;/h4&gt;
&lt;p&gt;对于负数而言，前序比特 1 不能带来压缩上效益，所以 Protobuf 提供 &lt;code&gt;sint32&lt;/code&gt;，&lt;code&gt;sint64&lt;/code&gt; 类型来使用 Zig-Zag 提高压缩率。&lt;/p&gt;
&lt;h4 id=&#34;42-32-bit--64-bit&#34;&gt;4.2 32-bit / 64-bit&lt;/h4&gt;
&lt;p&gt;这两部分 wire type 会使用固定长度去传输数据，其中 &lt;code&gt;64-bit&lt;/code&gt; 采用 8 字节传输，而 &lt;code&gt;32-bit&lt;/code&gt; 采用 4 字节传输。&lt;/p&gt;
&lt;h4 id=&#34;43-length-delimited&#34;&gt;4.3 Length-delimited&lt;/h4&gt;
&lt;p&gt;Length-delimited 会引入 &lt;strong&gt;payload size&lt;/strong&gt; 来辅助说明后序字节数，其中 &lt;strong&gt;payload size&lt;/strong&gt; 的编码采用 Varints 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;strings/bytes&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;message SimpleString {
  string o_string = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将 &lt;code&gt;o_string&lt;/code&gt; 设置成 &lt;code&gt;Hello, world!&lt;/code&gt;，会得到以下数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0A 0D 48 65 6C 6C 6F 2C 20 77 6F 72 6C 64 21
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Key &lt;code&gt;0A&lt;/code&gt; 可以推断出 field number(&lt;code&gt;1&lt;/code&gt;) 和 wire type(&lt;code&gt;2&lt;/code&gt;)。payload size(&lt;code&gt;0D&lt;/code&gt;) 解码之后为 13 ，后序 13 个字节将代表 &lt;code&gt;o_string&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;embedded messages&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;message SimpleEmbedded {
  Simple o_embedded = 1; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将 &lt;code&gt;o_embedded.o_int64&lt;/code&gt; 设置成 150，会得到以下数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0A 04 80 01 96 01
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Key &lt;code&gt;0A&lt;/code&gt; 可以推断出 field number(&lt;code&gt;1&lt;/code&gt;) 和 wire type(&lt;code&gt;2&lt;/code&gt;)。payload size(&lt;code&gt;04&lt;/code&gt;)  解码之后为 4 ，后序 4 个字节将代表 &lt;code&gt;o_embedded&lt;/code&gt;。整个过程基本和 SimpleString 一致，只不过 &lt;code&gt;o_embedded&lt;/code&gt; 还需要进一步的解码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;packed repeated fields&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Protobuf 3.0 对于 repeated field 默认都采用了 packed 的形式。不过在介绍 packed 特性前，有必要说明一下 unpacked 的编码结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;message SimpleInt64 {
  int64 o_int64 = 1;
}

message SimpleUnpacked {
  repeated int64 o_ids = 1 [packed = false];
}

message SimplePacked {
  repeated int64 o_ids = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将 &lt;code&gt;SimpleUnpacked.o_ids&lt;/code&gt; 设置成 &lt;code&gt;1,2&lt;/code&gt; 数组，会得到以下数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;08 01 08 02

08 // field number = 1, wire type = 0
01 // value = 1 
08 // field number = 1, wire type = 0
02 // value = 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Protobuf 编码 unpacked repeated fields 时，并不会将 repeated fields 看成是一个整体，而是单独编码每一个元素。所以在解码 unpacked repeated fileds 时，需要将相同 field number 的数据合并到一起。&lt;/p&gt;
&lt;p&gt;从另外一个角度看，Protobuf 允许将相同 Key 的数据合并到一起。&lt;code&gt;08 01 08 02&lt;/code&gt; 数据可以看成是 &lt;code&gt;SimpleInt64.o_int64 = 1&lt;/code&gt; 和 &lt;code&gt;SimpleInt64.o_int64 = 2&lt;/code&gt; 编码合并的结果。&lt;/p&gt;
&lt;p&gt;让我们来看看 packed repeated fields 编码结果。同样将 &lt;code&gt;SimplePacked.o_ids&lt;/code&gt; 设置成 &lt;code&gt;1,2&lt;/code&gt; 数组，却得到不同的数据，因为 Protobuf 编码时将 &lt;code&gt;o_ids&lt;/code&gt; 看成是一个整体。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0A 02 01 02

0A // field number = 1, wire type = 2
02 // payload size = 2
01 // first elem = 1
02 // second elem = 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Protobuf 3.0 packed 的行为仅仅支持基础数据类型，即 &lt;code&gt;Varint/64-bit/32-bit&lt;/code&gt; 三种 wire type。&lt;/p&gt;
&lt;p&gt;packed 和 unpacked 编码面对长度为 0 的数据时，它并不会输出任何二进制数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;个人认为基础数据类型所占用字节数少，整体字节数相对可控，引入 payload size 能带来压缩效益。一旦使用 embedded message 之后，每一个元素的大小将不可控，可能只有少量元素，但是整体字节数将会很大，payload size 需要大量的字节表示。面对这种场景，unpacked repeated fields 单独编码的方式会带来压缩效益，即使包含了重复的 Key 信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;5-start-groupend-group&#34;&gt;5. Start Group/End Group&lt;/h3&gt;
&lt;p&gt;由于 Protobuf 放弃使用 &lt;code&gt;Start Group&lt;/code&gt; 和 &lt;code&gt;End Group&lt;/code&gt;，在此也不再介绍。&lt;/p&gt;
&lt;h3 id=&#34;6-reference&#34;&gt;6. Reference&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/encoding&#34;&gt;Protocol Buffers Encoding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
          <title>Go Interface &amp; Duck Typing</title>
          <link>/post/2017-go-interface-duck-typing/</link>
          <pubDate>Mon, 05 Jun 2017 00:00:00 +0000</pubDate>
          <guid>https://fuweid.com/post/2017-go-interface-duck-typing/</guid>
          <description>&lt;p&gt;Go 不需要像 Java 那样显式地使用 &lt;strong&gt;implement&lt;/strong&gt; 说明某一数据类型实现了 interface，只要某一数据类型实现了 interface 所定义的方法名签，那么就称该数据类型实现了 interface。interface 的语言特性可以容易地做到接口定义和具体实现解耦分离，并将注意力转移到如何使用 interface ，而不是方法的具体实现，我们也称这种程序设计为 Duck Typing。文本将描述 Go 是如何通过 interface 来实现 Duck Typing。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文提供的源代码都是基于 go1.7rc6 版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-duck-typing&#34;&gt;1. Duck Typing&lt;/h3&gt;
&lt;p&gt;了解实现原理之前，我们可以简单过一下 Go 的 Duck Typing 示例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

type Ducker interface { Quack() }

type Duck struct {}
func (_ Duck) Quack() { println(&amp;quot;Quaaaaaack!&amp;quot;) }

type Person struct {} 
func (_ Person) Quack() { println(&amp;quot;Aha?!&amp;quot;) }

func inTheForest(d Ducker) { d.Quack() }

func main() {
	inTheForest(Duck{})
	inTheForest(Person{})
}

// result:
// Quaaaaaack!
// Aha?!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在示例中，&lt;code&gt;inTheForest&lt;/code&gt; 函数使用了 &lt;code&gt;Ducker&lt;/code&gt; 的 &lt;code&gt;Quack()&lt;/code&gt; 方法，而 &lt;code&gt;Quack()&lt;/code&gt; 方法的具体实现由实参所决定。根据 Go interface 的定义，&lt;code&gt;Duck&lt;/code&gt; 和 &lt;code&gt;Person&lt;/code&gt; 两种数据类型都有 &lt;code&gt;Quack()&lt;/code&gt; 方法，说明这两种数据类型都实现了 &lt;code&gt;Ducker&lt;/code&gt; 。当实参分别为这两种类型的数据时，&lt;code&gt;inTheForest&lt;/code&gt; 函数表现出『多态』。&lt;/p&gt;
&lt;p&gt;在这没有继承关系的情况下，Go 可以通过 interface 的 Duck Typing 特性来实现『多态』。作为一个静态语言，Go 是如何实现 Duck Typing 这一特性？&lt;/p&gt;
&lt;h3 id=&#34;2-interface-data-structure&#34;&gt;2. interface data structure&lt;/h3&gt;
&lt;p&gt;interface 是 Go 数据类型系统中的一员。在分析运行机制之前，有必要先了解 interface 的数据结构。&lt;/p&gt;
&lt;h4 id=&#34;21-empty-interface&#34;&gt;2.1 empty interface&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/runtime2.go
type eface struct {
    _type *_type
    data  unsafe.Pointer
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当一个 interface 没有定义方法签名时，那么我们称之为 empty interface。它由 &lt;code&gt;_type&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt; 组成，其中 &lt;code&gt;data&lt;/code&gt; 表示 interface 具体实现的数据，而 &lt;code&gt;_type&lt;/code&gt; 是 &lt;code&gt;data&lt;/code&gt; 对应数据的类型元数据。因为没有定义方法签名，所以任何类型都『实现』empty interface。换句话来说，empty interface 可以接纳任何类型的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

func main() {
    i := 1
    var eface interface{} = i
    
    println(eface)
}

// gdb info
// (gdb) i locals
// i = 1
// eface = {
//   _type = 0x55ec0 &amp;lt;type.*+36000&amp;gt;,
//   data = 0xc420045f18
// }
// (gdb) x/x eface.data
// 0xc420045f18:   0x00000001
// (gdb) x/x &amp;amp;i
// 0xc420045f10:   0x00000001
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在使用 gdb 来查看 &lt;code&gt;eface&lt;/code&gt; 数据结构的过程中，我们会发现比较特别的一点：&lt;code&gt;eface.data&lt;/code&gt; 和 &lt;code&gt;i&lt;/code&gt; 的地址不同。一般情况下，将一个数据赋值给 interface 时，程序会为数据生成一份副本，并将副本的地址赋给 &lt;code&gt;data&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/cmd/compile/internal/gc/subr.go
// Can this type be stored directly in an interface word?
// Yes, if the representation is a single pointer.
func isdirectiface(t *Type) bool {
    switch t.Etype {
    case TPTR32,
        TPTR64,
        TCHAN,
        TMAP,
        TFUNC,
        TUNSAFEPTR:
        return true

    case TARRAY:
        // Array of 1 direct iface type can be direct.
        return t.NumElem() == 1 &amp;amp;&amp;amp; isdirectiface(t.Elem())

    case TSTRUCT:
        // Struct with 1 field of direct iface type can be direct.
        return t.NumFields() == 1 &amp;amp;&amp;amp; isdirectiface(t.Field(0).Type)
    }

    return false
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当一个数据的类型符合 &lt;code&gt;isdirectiface&lt;/code&gt; 的判定时，那么程序不会生成副本，而是直接将实际地址赋给 &lt;code&gt;data&lt;/code&gt; 。由于这部分内存分配优化和 &lt;strong&gt;reflect&lt;/strong&gt; 实现有关，在此就不做展开描述了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;reflect 要想在运行时解析数据的方法和属性，它就需要知道数据以及类型元数据。而 empty interface 正好能满足这一需求，这也正是 reflect 的核心方法 &lt;code&gt;ValueOf&lt;/code&gt; 和 &lt;code&gt;TypeOf&lt;/code&gt; 的形参是 empty interface 的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Duck Typing 的使用上，empty interface 使用频率比较高的场景是 Type Switch, Type Assertion，接下来会介绍这些使用场景。&lt;/p&gt;
&lt;h4 id=&#34;22-non-empty-interface&#34;&gt;2.2 non-empty interface&lt;/h4&gt;
&lt;p&gt;相对于 empty interface 而言，有方法签名的 interface 的数据结构要复杂一些。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/runtime2.go
type iface struct {
    tab  *itab
    data unsafe.Pointer
}

type itab struct {
    inter  *interfacetype
    _type  *_type
    link   *itab
    bad    int32
    unused int32
    fun    [1]uintptr // variable sized
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;iface&lt;/code&gt; 包含两个字段 &lt;code&gt;tab&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt;。和 empty interface 一样，&lt;code&gt;data&lt;/code&gt; 表示具体实现的数据。&lt;code&gt;tab&lt;/code&gt; 不再是简单的 &lt;code&gt;_type&lt;/code&gt;，不仅维护了（&lt;code&gt;interfacetype&lt;/code&gt;，&lt;code&gt;_type&lt;/code&gt;）匹配的信息，还维护了具体方法实现的列表入口 &lt;code&gt;fun&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中 &lt;code&gt;interfacetype&lt;/code&gt; 是相应 interface 类型的元数据。
而 &lt;code&gt;fun&lt;/code&gt; 字段是一个变长数组的 header ，它代表着具体方法数组的头指针，程序通过&lt;code&gt;fun&lt;/code&gt;去定位具体某一方法实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来看看下面这一段程序。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

type Ducker interface {
        Quack()
        Feathers()
}

type Duck struct{ x int }

func (_ Duck) Quack() { println(&amp;quot;Quaaaaaack!&amp;quot;) }

func (_ Duck) Feathers() { println(&amp;quot;The duck has white and gray feathers.&amp;quot;) }

func inTheForest(d Ducker) {
        d.Quack()
        d.Feathers()
}

func main() {
        inTheForest(Duck{x: 1})
}

// gdb info at func inTheForest
(gdb) p d
$2 = {
  tab = 0x97100 &amp;lt;Duck,main.Ducker&amp;gt;,
  data = 0xc42000a118
}
(gdb) x/2xg d.tab.fun
0x97120 &amp;lt;go.itab.main.Duck,main.Ducker+32&amp;gt;:     0x00000000000022f0      0x0000000000002230
(gdb) i symbol 0x00000000000022f0
main.(*Duck).Feathers in section .text
(gdb) i symbol 0x0000000000002230
main.(*Duck).Quack in section .text
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 &lt;code&gt;inTheForest&lt;/code&gt; 函数里，&lt;code&gt;d.tab.fun&lt;/code&gt; 数组包含了 &lt;code&gt;Duck&lt;/code&gt; 的 &lt;code&gt;Quack&lt;/code&gt; 以及 &lt;code&gt;Feathers&lt;/code&gt; 的方法地址，因此在 &lt;code&gt;d.Quack()&lt;/code&gt; 和 &lt;code&gt;d.Feathers()&lt;/code&gt; 分别使用了 &lt;code&gt;Duck&lt;/code&gt; 的 &lt;code&gt;Quack&lt;/code&gt; 和 &lt;code&gt;Feathers&lt;/code&gt; 方法的具体实现。假如这个时候，传入的不是 &lt;code&gt;Duck&lt;/code&gt; ，而是其他实现了 &lt;code&gt;Ducker&lt;/code&gt; 的数据类型，那么 &lt;code&gt;d.tab.fun&lt;/code&gt; 将会包含相应类型的具体方法实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;d.tab.fun 不会包含 interface 定义以外的方法地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不难发现，&lt;code&gt;itab.fun&lt;/code&gt; 包含了具体方法的实现，程序在运行时通过 &lt;code&gt;itab.fun&lt;/code&gt; 来决议具体方法的调用，这也是实现 Duck Typing 的核心逻辑。那么问题来了，&lt;code&gt;itab&lt;/code&gt; 是什么时候生成的？&lt;/p&gt;
&lt;h3 id=&#34;3-itab&#34;&gt;3. itab&lt;/h3&gt;
&lt;p&gt;当数据类型 &lt;code&gt;Duck&lt;/code&gt; 实现了 &lt;code&gt;Ducker&lt;/code&gt; 中的所有方法时，编译器才会生成 &lt;code&gt;itab&lt;/code&gt;，并将 &lt;code&gt;Duck&lt;/code&gt; 对 &lt;code&gt;Ducker&lt;/code&gt; 的具体实现绑定到 &lt;code&gt;itab.fun&lt;/code&gt; 上，否则编译不通过。&lt;code&gt;itab.fun&lt;/code&gt; 很像 C++ 中的虚函数表。而 Go 没有继承关系，一个 interface 就可能会对应 N 种可能的具体实现，这种 M:N 的情况太多，没有必要去为所有可能的结果生成 &lt;code&gt;itab&lt;/code&gt;。因此，编译器只会生成部分 &lt;code&gt;itab&lt;/code&gt;，剩下的将会在运行时生成。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C++ 通过继承关系，在编译期间就生成类的虚函数表。在运行状态下，通过指针来查看虚函数表来定位具体方法实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当一个数据类型实现 interface 中所声明的所有方法签名，那么 &lt;code&gt;iface&lt;/code&gt; 就可以携带该数据类型对 interface 的具体实现，否则将会 panic 。这部分判定需要 &lt;code&gt;_type&lt;/code&gt; 和 &lt;code&gt;interfacetype&lt;/code&gt; 元数据，而这部分数据在编译器已经为运行时准备好了，那么判定和生成 &lt;code&gt;itab&lt;/code&gt; 就只要照搬编译器里那一套逻辑即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/iface.go
var (
    ifaceLock mutex // lock for accessing hash
    hash      [hashSize]*itab
)

func itabhash(inter *interfacetype, typ *_type) uint32 {...}
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {...}
func additab(m *itab, locked, canfail bool) {...}

// src/runtime/runtime2.go
type itab struct {
    inter  *interfacetype
    _type  *_type
    link   *itab
    bad    int32
    unused int32
    fun    [1]uintptr // variable sized
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了保证运行效率，程序会在运行时会维护全局的 &lt;code&gt;itab&lt;/code&gt; hash 表，&lt;code&gt;getitab&lt;/code&gt; 会在全局 hash 表中查找相应的 &lt;code&gt;itab&lt;/code&gt;。当 &lt;code&gt;getitab&lt;/code&gt; 发现没有相应的 &lt;code&gt;itab&lt;/code&gt; 时，它会调用 &lt;code&gt;additab&lt;/code&gt; 来添加新的 &lt;code&gt;itab&lt;/code&gt;。在插入新的 &lt;code&gt;itab&lt;/code&gt; 之前，&lt;code&gt;additab&lt;/code&gt; 会验证 &lt;code&gt;_type&lt;/code&gt; 对应的类型是否都实现了 &lt;code&gt;interfacetype&lt;/code&gt; 声明的方法集合。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;运行时通过 &lt;code&gt;itabhash&lt;/code&gt; 负责生成 hash 值，并使用单链表来解决冲突问题，其中 &lt;code&gt;itab.link&lt;/code&gt; 可用来实现链表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么问题又来了，&lt;code&gt;_type&lt;/code&gt; 有 N 个方法，&lt;code&gt;interfacetype&lt;/code&gt; 有 M 个方法签名，验证匹配的最坏可能性就是需要 N * M 次遍历。除此之外，&lt;code&gt;additab&lt;/code&gt; 在写之前需要加锁，这两方面都会影响性能。&lt;/p&gt;
&lt;h4 id=&#34;31-additab-的效率问题&#34;&gt;3.1 additab 的效率问题&lt;/h4&gt;
&lt;p&gt;为了减少验证的时间，编译期间会对方法名进行排序，这样最坏的可能也就需要 N + M 次遍历即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;细心的朋友可能会发现，在上一个例子中 &lt;code&gt;d.tab.fun&lt;/code&gt; 中的方法是按照字符串大小排序的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/iface.go
func additab(m *itab, locked, canfail bool) {
    inter := m.inter
    typ := m._type
    x := typ.uncommon()

    // both inter and typ have method sorted by name,
    // and interface names are unique,
    // so can iterate over both in lock step;
    // the loop is O(ni+nt) not O(ni*nt).
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;32-锁的效率问题&#34;&gt;3.2 锁的效率问题&lt;/h4&gt;
&lt;p&gt;关于锁的问题，在实现 &lt;code&gt;getitab&lt;/code&gt; 的时候，引入了两轮查询的策略。因为 &lt;code&gt;itab&lt;/code&gt; 数据比较稳定，引入两轮查询可以减少锁带来的影响。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/iface.go
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
    ....
    // look twice - once without lock, once with.
    // common case will be no lock contention.
    var m *itab
    var locked int
    for locked = 0; locked &amp;lt; 2; locked++ {
        if locked != 0 {
            lock(&amp;amp;ifaceLock)
        }
        ...
     }
     ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;itab&lt;/code&gt; 的生成和查询或多或少带有运行时的开销。然而 &lt;code&gt;itab&lt;/code&gt; 不仅提供了静态语言的类型检查，还提供了动态语言的灵活特性。只要不滥用 interface，&lt;code&gt;itab&lt;/code&gt; 还是可以提供不错的编程体验。&lt;/p&gt;
&lt;h3 id=&#34;4-type-switch--type-assertion&#34;&gt;4. Type Switch &amp;amp; Type Assertion&lt;/h3&gt;
&lt;p&gt;开发者会使用 interface 的 Type Switch 和 Type Assertion 来进行『类型转化』。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

type Ducker interface { Feathers() }

type Personer interface { Feathers() }

type Duck struct{}

func (_ Duck) Feathers() { /* do nothing */ }

func example(e interface{}) {
	if _, ok := e.(Personer); ok {
		println(&amp;quot;I&#39;m Personer&amp;quot;)
	}
	
	if _, ok := e.(Ducker); ok {
		println(&amp;quot;I&#39;m Ducker&amp;quot;)
	}
}

func main() {
     var d Ducker = Duck{}
     example(d)
}

// result:
// I&#39;m Personer
// I&#39;m Ducker
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据之前对 &lt;code&gt;itab&lt;/code&gt; 的分析，其实 &lt;code&gt;e.(Personer)&lt;/code&gt; 和 &lt;code&gt;e.(Ducker)&lt;/code&gt; 这两个断言做的就是切换 &lt;code&gt;itab.inter&lt;/code&gt; 和 &lt;code&gt;itab.fun&lt;/code&gt; ，并不是动态语言里的『类型转化』。那么断言的函数入口在哪？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go tool objdump -s &#39;main.example&#39; ./main
        main.go:15      0x2050  65488b0c25a0080000      GS MOVQ GS:0x8a0, CX
        main.go:15      0x2059  483b6110                CMPQ 0x10(CX), SP
        main.go:15      0x205d  0f86eb000000            JBE 0x214e
        main.go:15      0x2063  4883ec38                SUBQ $0x38, SP
        main.go:15      0x2067  48896c2430              MOVQ BP, 0x30(SP)
        main.go:15      0x206c  488d6c2430              LEAQ 0x30(SP), BP
        main.go:16      0x2071  488d05c8840500          LEAQ 0x584c8(IP), AX
        main.go:16      0x2078  48890424                MOVQ AX, 0(SP)
        main.go:16      0x207c  488b442448              MOVQ 0x48(SP), AX
        main.go:16      0x2081  488b4c2440              MOVQ 0x40(SP), CX
        main.go:16      0x2086  48894c2408              MOVQ CX, 0x8(SP)
        main.go:16      0x208b  4889442410              MOVQ AX, 0x10(SP)
        main.go:16      0x2090  48c744241800000000      MOVQ $0x0, 0x18(SP)
     =&amp;gt; main.go:16      0x2099  e892840000              CALL runtime.assertE2I2(SB)
        main.go:16      0x209e  0fb6442420              MOVZX 0x20(SP), AX
        main.go:16      0x20a3  8844242f                MOVB AL, 0x2f(SP)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过 &lt;code&gt;objdump&lt;/code&gt; 发现一个很特别的方法：&lt;code&gt;runtime.assertE2I2&lt;/code&gt;。&lt;code&gt;assertE2I2&lt;/code&gt; 是一个断言函数，它负责判断一个 empty interface 里的数据能否转化成一个 non-empty interface，名字最后那个 &lt;code&gt;2&lt;/code&gt; 代表着有两个返回值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一参数是转化后的结果&lt;/li&gt;
&lt;li&gt;第二参数是断言结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来看看 &lt;code&gt;assertE2I2&lt;/code&gt; 的源码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// src/runtime/iface.go
func assertE2I2(inter *interfacetype, e eface, r *iface) bool {
    if testingAssertE2I2GC {
        GC()
    }
    t := e._type
    if t == nil {
        if r != nil {
            *r = iface{}
        }
        return false
    }
    tab := getitab(inter, t, true)
    if tab == nil {
        if r != nil {
            *r = iface{}
        }
        return false
    }
    if r != nil {
        r.tab = tab
        r.data = e.data
    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该函数会拿出 empty interface 中的 &lt;code&gt;_type&lt;/code&gt; 和 &lt;code&gt;interfacetype&lt;/code&gt; 在 &lt;code&gt;getitab&lt;/code&gt; 中做查询和匹配验证。如果验证通过，&lt;code&gt;r&lt;/code&gt; 会携带转化后的结果，并返回 &lt;code&gt;true&lt;/code&gt;。否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;src/runtime/iface.go&lt;/code&gt; 中还有很多类似 &lt;code&gt;assertE2I2&lt;/code&gt; 的函数，在这里就不一一阐述了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// T: 具体的数据类型_type
// E: empty interface
// I:  non-empty interface

// src/runtime/iface.go
func assertE2I(inter *interfacetype, e eface, r *iface) {...}
func assertI2I2(inter *interfacetype, i iface, r *iface) bool {..}
func assertI2E(inter *interfacetype, i iface, r *eface) {...}
func assertI2E2(inter *interfacetype, i iface, r *eface) bool {...}
func assertE2T2(t *_type, e eface, r unsafe.Pointer) bool {..}
func assertE2T(t *_type, e eface, r unsafe.Pointer) {..}
func assertI2T2(t *_type, i iface, r unsafe.Pointer) bool {...}
func assertI2T(t *_type, i iface, r unsafe.Pointer) {...}

func convI2I(inter *interfacetype, i iface) (r iface) {...}
func convI2E(i iface) (r eface) {...}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;5-最后&#34;&gt;5. 最后&lt;/h3&gt;
&lt;p&gt;interface 的 Duck Typing 可以用来实现『多态』、代码的模块化。但是这毕竟有运行时的开销，interface 的滥用和声明大量的方法签名还是会影响到性能。&lt;/p&gt;
&lt;h3 id=&#34;6-reference&#34;&gt;6. Reference&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34;&gt;Duke Typing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://coolshell.cn/articles/12165.html&#34;&gt;C++ 虚函数表解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://research.swtch.com/interfaces&#34;&gt;Go Data Structures: Interfaces&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
          <title>让你的 shell 脚本变得可控</title>
          <link>/post/2017-control-your-shell-script/</link>
          <pubDate>Mon, 20 Mar 2017 00:00:00 +0800</pubDate>
          <guid>https://fuweid.com/post/2017-control-your-shell-script/</guid>
          <description>&lt;p&gt;刚开始接触 shell 脚本的时候，最痛苦的地方在于出了问题，却不容易定位问题。&lt;/p&gt;
&lt;p&gt;shell 脚本遇到错误，“大部分” 情况下都会继续执行剩下的命令，最后返回 Zero &lt;a href=&#34;https://en.wikipedia.org/wiki/Exit_status&#34;&gt;Exit Code&lt;/a&gt;  并不代表着结果正确。&lt;/p&gt;
&lt;p&gt;这让人很难发现问题，它不像其他脚本语言，遇到 &lt;code&gt;语法错误&lt;/code&gt; 和 &lt;code&gt;typo&lt;/code&gt; 等错误时便会立即退出。&lt;/p&gt;
&lt;p&gt;如果想要写出容易维护、容易 debug 的 shell 脚本，我们就需要让 shell 脚本变得可控。&lt;/p&gt;
&lt;h3 id=&#34;set--e&#34;&gt;set -e&lt;/h3&gt;
&lt;p&gt;默认情况下，shell 脚本遇到错误并不会立即退出，它还是会继续执行剩下的命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat example
#!/usr/bin/env bash
# set -e

sayhi # this command is not available.
echo &amp;quot;sayhi&amp;quot;
[root@localhost ~]# ./example
./example: line 4: sayhi: command not found
sayhi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们知道 Linux/Unix 用户等于系统的时候，内核会加载 &lt;code&gt;.bashrc&lt;/code&gt; 或者 &lt;code&gt;.bash_profile&lt;/code&gt; 里的配置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不同 shell 版本会使用不同的 rc/profile 文件，比如 zsh 版本的 rc 文件名是 .zshrc。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单设想下，假如 shell 脚本遇到错误就退出，那么只要这些文件里有 typo 等错误，该用户就永远登陆不了系统。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在此，并没有考究默认行为的设计缘由，只是想表达 shell 脚本默认行为会让脚本变得不可控。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;set -e&lt;/code&gt; 能会让 shell 脚本遇到 Non-Zero Exit Code 时，会立即停止执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat example
#!/usr/bin/env bash
set -e

sayhi # this command is not available.
echo &amp;quot;sayhi&amp;quot;
[root@localhost ~]# ./example
./example: line 4: sayhi: command not found
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;set--u&#34;&gt;set -u&lt;/h3&gt;
&lt;p&gt;初始化后再使用变量，这是好的编程习惯。&lt;/p&gt;
&lt;p&gt;但在默认情况下，shell 脚本使用未初始化的变量并不会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat example
#!/usr/bin/env bash
# set -u

echo &amp;quot;Hi, ${1}&amp;quot;
[root@localhost ~]# ./example
Hi,
[root@localhost ~]# echo $?
0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若脚本设置 &lt;code&gt;set -u&lt;/code&gt; ，一旦使用没有初始化的变量或者 &lt;code&gt;positional parameter&lt;/code&gt; 时，脚本将立即返回 1 Exit Code。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat example
#!/usr/bin/env bash
set -u

echo &amp;quot;Hi, ${1}&amp;quot;
[root@localhost ~]# ./example
./example: line 4: 1: unbound variable
[root@localhost ~]# echo $?
1
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;需要说明的是，对于预定义的 &lt;code&gt;$@&lt;/code&gt;, &lt;code&gt;$*&lt;/code&gt; 等这些变量，是可以正常使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了避免使用未初始化的变量，常使用 &lt;code&gt;${VAR:-DEFAULT}&lt;/code&gt; 来设置默认值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env bash
set -u

# ${VAR:-DEFAULT} evals to DEFAULT if VAR undefined.
foo=${nonexisting:-ping}

echo &amp;quot;${foo}&amp;quot; # =&amp;gt; ping

bar=&amp;quot;pong&amp;quot;

foo=${bar:-ping}

echo &amp;quot;${foo}&amp;quot; # =&amp;gt; pong

# DEFAULT can be empty
empty=${nonexisting:-}

echo &amp;quot;${empty}&amp;quot; # =&amp;gt; &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;set--o-pipefail&#34;&gt;set -o pipefail&lt;/h3&gt;
&lt;p&gt;在默认情况下，&lt;code&gt;pipeline&lt;/code&gt; 会采用最后一个命令的 Exit Code 作为最终返回的 Exit Code。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat example
#!/usr/bin/env bash
# set -o pipefail

grep string /non-existing-file | sort
[root@localhost ~]# ./example
grep: /non-existing-file: No such file or directory
[root@localhost ~]# echo $?
0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;明明报错了，为什么还会返回 Zero Exit Code?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;grep&lt;/code&gt; 一个并不存在的文件会返回 2 Exit Code。&lt;code&gt;grep&lt;/code&gt; 不仅会输出错误信息到 &lt;code&gt;STDERR&lt;/code&gt; 上，还会输出空的字符串到 &lt;code&gt;STDOUT&lt;/code&gt;。对于 &lt;code&gt;sort&lt;/code&gt; 命令而言，空字符串是合法的输入，所以最后命令返回 Zero Exit Code。&lt;/p&gt;
&lt;p&gt;这样错误信息并不能很好地帮助我们改善脚本，返回的 Exit Code 应该要尽可能地反映错误现场。&lt;/p&gt;
&lt;p&gt;和前面两个设置一样，&lt;code&gt;set -o pipefail&lt;/code&gt; 会让 shell 脚本在 &lt;code&gt;pipeline&lt;/code&gt; 过程遇到错误便立即返回相应错误的 Exit Code。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat example
#!/usr/bin/env bash
set -o pipefail

grep string /non-existing-file | sort
[root@localhost ~]# ./example
grep: /non-existing-file: No such file or directory
[root@localhost ~]# echo $?
2
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;non-zero-exit-code-is-expected&#34;&gt;non-zero exit code is expected&lt;/h3&gt;
&lt;p&gt;这三个配置太过于苛刻，某些情况下还需要放宽这些限制：当程序可以接受 non-zero exit code 时。&lt;/p&gt;
&lt;p&gt;这里有两种常用的方式去放宽限制：&lt;/p&gt;
&lt;h4 id=&#34;set-&#34;&gt;set +&lt;/h4&gt;
&lt;p&gt;这里有一个脚本是用来产生长度为 64 的随机字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@localhost ~]# cat example
#!/usr/bin/env bash
set -euo pipefail

str=$(cat /dev/urandom | tr -dc &#39;0-9A-Za-z&#39; | head -c 64)

echo &amp;quot;${str}&amp;quot;

[root@localhost ~]# ./example
[root@localhost ~]# echo $?
141
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该脚本有一个问题，就是 &lt;code&gt;head&lt;/code&gt; 命令在获取到第 64 个字节之后，会关闭 &lt;code&gt;STDIN&lt;/code&gt;，但是 &lt;code&gt;pipe&lt;/code&gt; 还在不断地输出，导致内核不得不抛出 &lt;code&gt;SIGPIPE&lt;/code&gt; 来终止命令。&lt;/p&gt;
&lt;p&gt;因为设置 &lt;code&gt;set -o pipefail&lt;/code&gt; 了 ，整个脚本因为 &lt;code&gt;SIGPIPE&lt;/code&gt; 会退出。&lt;/p&gt;
&lt;p&gt;假设该脚本剩下命令还很多，不能整体去掉 &lt;code&gt;pipefail&lt;/code&gt; ，那么我们就局部放弃这个限制好了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat example
#!/usr/bin/env bash
# exit immediately if non-zero exit code/unset variable/pipe error
set -euo pipefail

# loosen up
set +o pipefail
str=$(cat /dev/urandom | tr -dc &#39;0-9A-Za-z&#39; | head -c 64)
set -o pipefail

echo &amp;quot;${str}&amp;quot;

[root@localhost ~]# ./example
pvScFHDZrdjlI091rQbruyEPM9e6iTN59IyzaKcCJwiCxYmiSNRmkFOfp0YuXi1C
[root@localhost ~]# echo $?
0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同理，只要设置上 &lt;code&gt;set +e&lt;/code&gt; 或者 &lt;code&gt;set +u&lt;/code&gt; 时，就会放宽相应的限制。&lt;/p&gt;
&lt;p&gt;记得 &lt;strong&gt;有借有还，再借不难&lt;/strong&gt; 就好了。&lt;/p&gt;
&lt;h4 id=&#34;短路运算&#34;&gt;短路运算&lt;/h4&gt;
&lt;p&gt;现在有一个脚本，该脚本用来统计文件 &lt;code&gt;file&lt;/code&gt; 中有多少行是包含了 &lt;code&gt;string&lt;/code&gt; 这个字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@localhost ~]# cat example
#!/usr/bin/env bash
set -euo pipefail

count=$(grep -c string ./file)

echo &amp;quot;${count}&amp;quot;

[root@localhost ~]# ./example
[root@localhost ~]# echo $?
1
[root@localhost ~]# cat ./file
example
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为文件 &lt;code&gt;file&lt;/code&gt; 中并不包含 &lt;code&gt;string&lt;/code&gt; 这一字符串，所以 &lt;code&gt;grep&lt;/code&gt; 返回 1 Exit Code。&lt;/p&gt;
&lt;p&gt;假设遇到没有匹配上的文件，该脚本应该显示零，而不是错误。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$(cmd || true)&lt;/code&gt; 短路运算会让该命令永远都正常执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat example
#!/usr/bin/env bash
set -euo pipefail

count=$(grep -c string ./file || true)

echo &amp;quot;${count}&amp;quot;

[root@localhost ~]# ./example
0
[root@localhost ~]# echo $?
0
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;思考&#34;&gt;思考&lt;/h3&gt;
&lt;p&gt;shell 脚本能帮助我们轻松地完成自动化的任务，这是它的优势。&lt;/p&gt;
&lt;p&gt;但是劣势也比较明显，就是 shell 脚本的返回值。我们来看看下面的一个例子。&lt;/p&gt;
&lt;p&gt;相对于 &lt;code&gt;if/else&lt;/code&gt;, 短路运算可以让代码变得简洁。&lt;/p&gt;
&lt;p&gt;但是一旦最终的判断结果为否，那么该短路运算将会返回 Non-Zero Exit Code。&lt;/p&gt;
&lt;p&gt;假如有一个脚本的最后一条命令是短路运算。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat ./echo_filename
#!/usr/bin/env bash
set -euo pipefail

file=${1:-}

[[ -f &amp;quot;${file}&amp;quot; ]] &amp;amp;&amp;amp; echo &amp;quot;File: ${file}&amp;quot;
[root@localhost ~]# ./echo_filename
[root@localhost ~]# echo $?
1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果没有传参数，那么短路运算将会返回 1 Exit Code，这个结果也将作为整个脚本的返回结果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要说明的是，虽然短路运算返回的 Non-Zero Exit Code，但 &lt;code&gt;set -e&lt;/code&gt; 不会因为它而退出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后我们再看看使用 &lt;code&gt;if/else&lt;/code&gt; 的结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# cat echo_filename
#!/usr/bin/env bash
set -euo pipefail

file=${1:-}

if [[ -f &amp;quot;${file}&amp;quot; ]]; then
    echo &amp;quot;File: ${file}&amp;quot;
fi
[root@localhost ~]# ./echo_filename
[root@localhost ~]# echo $?
0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从逻辑上来分析，即使不传参数，呈现的应该是空字符串，并返回 Zero Exit Code。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;if/else&lt;/code&gt; 语句相对于短路运算要合理。&lt;/p&gt;
&lt;p&gt;我们别小看这一区别，如果这里有脚本调用 &lt;code&gt;echo_filename&lt;/code&gt;，那么使用短路运算将会导致调用该脚本的脚本停止工作。&lt;/p&gt;
&lt;p&gt;归根结底，是因为 shell 脚本并不像其他语言那样支持返回多种数据类型，它只能返回数字的 Exit Code。&lt;/p&gt;
&lt;p&gt;这就代表着脚本的程序设计必须要考虑返回正确的 Exit Code，这样 &lt;code&gt;set -euo pipefail&lt;/code&gt; 才能让脚本变得更加可控。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于 &lt;code&gt;set&lt;/code&gt; 更多的内容，请前往 &lt;a href=&#34;https://www.gnu.org/software/bash/manual/bashref.html#The-Set-Builtin&#34;&gt;Link&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
          <title>shebang - #!</title>
          <link>/post/2017-shebang-compatibility-version/</link>
          <pubDate>Sun, 19 Mar 2017 00:00:00 +0800</pubDate>
          <guid>https://fuweid.com/post/2017-shebang-compatibility-version/</guid>
          <description>&lt;p&gt;写脚本的时候通常会在脚本的开头加上 &lt;a href=&#34;https://en.wikipedia.org/wiki/Shebang_(Unix)&#34;&gt;shebang&lt;/a&gt;, 系统会将这段内容作为解释器指令，比如 bash shell 脚本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$&amp;gt; cat example
#!/usr/bin/bash
echo &amp;quot;HaHa&amp;quot;

$&amp;gt; chmod +x ./example

$&amp;gt; ./example
HaHa
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只要为脚本添加了可执行的属性，那么内核在执行脚本的时候，会调用 shebang 描述的解释器来执行脚本。
&lt;code&gt;./exmaple&lt;/code&gt; 其实等价于 &lt;code&gt;/usr/bin/bash ./example&lt;/code&gt;。shebang 描述的解释器需要写其绝对路径或者相对路径，因为内核并不会在用户设置的 &lt;code&gt;PATH&lt;/code&gt; 里找解释器。关于 shebang，讨论最多的应该是 &lt;strong&gt;兼容性&lt;/strong&gt; 和 &lt;strong&gt;版本控制&lt;/strong&gt; 问题。&lt;/p&gt;
&lt;h3 id=&#34;兼容性&#34;&gt;兼容性&lt;/h3&gt;
&lt;p&gt;Linux 和 Unix 在存放解释器的具体路径不太一致，比如 Linux 会放到 &lt;code&gt;/usr/bin/&lt;/code&gt; 中，而 openBSD 会放到 &lt;code&gt;/usr/local/bin/&lt;/code&gt; 中。不同包管理器在安装解释器的时候，存放的位置也不尽相同。
当你在 Mac  上写了 shell  脚本，测试并提交到代码库。
结果等到部署的那一天，执行脚本的时候发现找不到解释器了。
为了解决这个问题，可以通过 &lt;code&gt;env&lt;/code&gt; 来解决，因为它在 Linux 和 Unix 存放的位置相同。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$&amp;gt; cat exmaple
&lt;span class=&#34;c1&#34;&gt;#!/usr/bin/env bash&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;HaHa&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;env&lt;/code&gt; 会在用户设置的 &lt;code&gt;PATH&lt;/code&gt; 中查找解释器第一次出现的具体路径。
虽然办法比较 tricky，但是这种方式能解决脚本解释器的兼容性问题。&lt;/p&gt;
&lt;h3 id=&#34;版本控制&#34;&gt;版本控制&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;env&lt;/code&gt; 会在用户配置的 &lt;code&gt;PATH&lt;/code&gt; 中查找解释器第一次出现的具体路径。
这个机制就说明这存在两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同用户配置的 &lt;code&gt;PATH&lt;/code&gt; 内容不同，导致找到的解释器版本会出现不一致&lt;/li&gt;
&lt;li&gt;很难通过 &lt;code&gt;env&lt;/code&gt; 的方式来做到版本控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以有些人坚持不用 &lt;code&gt;/usr/bin/env cmd&lt;/code&gt; 这种方式。&lt;/p&gt;
&lt;h3 id=&#34;思考&#34;&gt;思考&lt;/h3&gt;
&lt;p&gt;从部署的角度看，线上机器的环境都是一致的，而且都是通过自动化脚本去安装各种依赖。
版本控制较细，这种情况下，不太建议采用 &lt;code&gt;env&lt;/code&gt; 这种方式。如果从开发者的角度看，
还是希望脚本能做到兼容，毕竟开发者的环境千差万别，&lt;code&gt;env&lt;/code&gt;  基本上能解决这一大痛点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不用 &lt;code&gt;env&lt;/code&gt; 这种方式，就得确保测试环境和线上机器是一致的，通常 Docker 和 虚拟机都能解决这样的问题。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
          <title>Netfilter 初探</title>
          <link>/post/2017-netfilter-beginning/</link>
          <pubDate>Fri, 17 Mar 2017 00:00:00 +0800</pubDate>
          <guid>https://fuweid.com/post/2017-netfilter-beginning/</guid>
          <description>&lt;p&gt;Linux 内核在 2.4.x 版本中正式引入 &lt;a href=&#34;http://www.netfilter.org/&#34;&gt;Netfilter&lt;/a&gt; 模块，该模块负责网络数据包过滤和 &lt;a href=&#34;https://en.wikipedia.org/wiki/Network_address_translation&#34;&gt;Network Address Translation&lt;/a&gt;。
Netfilter 代表着一系列的 Hook ，被内核嵌入到 TCP/IP 协议栈中，数据包在穿梭协议栈时，Hook 会检查数据包，从而达到访问控制的作用。&lt;/p&gt;
&lt;h3 id=&#34;规则链&#34;&gt;规则链&lt;/h3&gt;
&lt;p&gt;Netfilter 模块默认定义了五种类型的 Hook：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PREROUTING&lt;/li&gt;
&lt;li&gt;INPUT&lt;/li&gt;
&lt;li&gt;FORWARD&lt;/li&gt;
&lt;li&gt;OUTPUT&lt;/li&gt;
&lt;li&gt;POSTROUTING&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Netfilter 里，Hook 也称为 Chain，规则链&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以从数据包的来源和走向入手来进行分析这条五条规则链的设计。
首先，数据包按照来源可以分成 Incoming 和 Outgoing 这两种类型。
Incoming 数据包是指其他网卡发来的数据包。这类数据包可能直接奔向用户态的程序，
也有可能被内核转发到其他机器或者其他网卡上，这需要内核做路由判定。&lt;/p&gt;
&lt;p&gt;而 Outgoing 数据包是用户态程序准备要发送的数据包。
数据包到达内核之后，内核会为它选择合适的网卡和端口，在此之后便会一层层地穿过协议栈，内核在此过程之中会做出路由判定。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般情况下，客户端所使用的高端口号。在 Linux 下，我们可以通过 &lt;code&gt;cat /proc/sys/net/ipv4/ip_local_port_range&lt;/code&gt; 查看系统会随机使用的端口号范围。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要注意的是，如果这是内网和外网之间的通信，内核会使用到 NAT 技术来对地址进行转化。
对于 Incoming 数据包而言，内核路由前需要对数据包进行 Destination NAT 转化。
同理，数据包在路由之后也需要做 Source NAT 转化。&lt;/p&gt;
&lt;p&gt;根据上面的分析，可以得到以下结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Incoming 数据包的目的地就在本地：PREROUTING -&amp;gt; INPUT&lt;/li&gt;
&lt;li&gt;Incoming 数据包需要转发：PREROUTING -&amp;gt; FORWARD -&amp;gt; POSTROUTING&lt;/li&gt;
&lt;li&gt;Outgoing 数据包：OUTPUT -&amp;gt; POSTROUTING&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同走向的数据包都必定会通过以上五个环节中的部分环节，只要系统管理员在五个环节中设置关卡，就可以做到系统的访问控制。&lt;/p&gt;
&lt;h3 id=&#34;功能表&#34;&gt;功能表&lt;/h3&gt;
&lt;p&gt;为了更好地管理访问控制规则，Netfilter 制定 &lt;strong&gt;功能表&lt;/strong&gt; 来定义和区分不同功能的规则。&lt;/p&gt;
&lt;p&gt;Netfilter 一共有五种功能表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;raw: 当内核启动 &lt;code&gt;ip_conntrack&lt;/code&gt; 模块以后，所有信息都会被追踪，raw 却是用来设置不追踪某些数据包&lt;/li&gt;
&lt;li&gt;mangle: 用来设置或者修改数据包的 IP 头信息&lt;/li&gt;
&lt;li&gt;nat: 用来设置主机的 NAT 规则，用来修改数据包的源地址和目的地址&lt;/li&gt;
&lt;li&gt;filter: 通常情况下，用来制定接收、转发、丢弃和拒绝数据包的规则&lt;/li&gt;
&lt;li&gt;security: 安全相关&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;由于 filter 和 nat 基本能满足大部分的访问控制需求，加上篇幅的原因，接下来只会介绍 filter 和 nat 这两张功能表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不同的功能表有内置的规则链。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filter: INPUT／OUTPUT ／FORWARD&lt;/li&gt;
&lt;li&gt;nat: PREROUTING ／INPUT／OUTPUT／POSTROUTING&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux 内核 2.6.34 开始给 nat 功能表引入了 INPUT 规则链，具体详情请查看 &lt;a href=&#34;http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c68cd6cc21eb329c47ff020ff7412bf58176984e&#34;&gt;Commit&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不同来源的数据包的走向不同，触发的规则链也不同。&lt;/p&gt;
&lt;h4 id=&#34;incoming-数据包&#34;&gt;Incoming 数据包&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;+----------------------+                               +-------------------------------------+
| chain: PREROUTING    |                               | chain: INPUT                        |
|                      |      +==================+     |                                     |      +===============+
| table:               | --&amp;gt;  + Routing Decision + --&amp;gt; | table:                              | --&amp;gt;  + Local Process +
| raw -&amp;gt; mangle -&amp;gt; nat |      +=========+========+     | mangle -&amp;gt; filter -&amp;gt; security -&amp;gt; nat |      +===============+
+----------------------+                |              +-------------------------------------+
                                        |
                                        v
                        +------------------------------+     +---------------------+
                        | chain: FORWARD               |     | chain: POSTROUTING  |
                        |                              |     |                     |     +=========+
                        | table:                       | --&amp;gt; | table:              | --&amp;gt; + Network +
                        | mangle -&amp;gt; filter -&amp;gt; security |     | mangle -&amp;gt; nat       |     +=========+
                        +------------------------------+     +---------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;为了能使 FORWARD 生效，请确保 &lt;code&gt;cat /proc/sys/net/ipv4/ip_forward&lt;/code&gt; 为1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;outgoing-数据包&#34;&gt;Outgoing 数据包&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;+===============+     +==================+     +----------------------+     +==================+     +--------------------+      +----------------------+     +=========+
+ Local Process + --&amp;gt; + Routing Decision + --&amp;gt; | chain: OUTPUT        | --&amp;gt; + Routing Decision + --&amp;gt; | chain: OUTPUT      | --&amp;gt;  | chain: POSTROUTING   | --&amp;gt; + Network +
+===============+     +=========+========+     |                      |     +=========+========+     |                    |      |                      |     +=========+
                                               | table:               |                              | table:             |      | table:               |
                                               | raw -&amp;gt; mangle -&amp;gt; nat |                              | filter -&amp;gt; security |      | mangle -&amp;gt; nat        |
                                               +----------------------+                              +--------------------+      +----------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一个路由判定主要是收集数据发送前的必要信息，比如所要使用的网卡、IP 地址以及端口号。
当数据包触发了协议栈中的规则链时，内核将会遍历不同的功能表（顺序如上图所示），比如 Incoming 数据包触发 PREROUTING 规则链时，内核会先执行 raw 功能表中的 PREROUTING 规则链，其次 mangle 功能表，最后才是 nat 功能表。
Netfilter 还允许系统管理员创建自己的规则链，这样可以在内置的规则链中进一步划分规则。&lt;/p&gt;
&lt;h3 id=&#34;规则&#34;&gt;规则&lt;/h3&gt;
&lt;p&gt;功能表包含了多条规则链，而每一条规则链包含多条规则。&lt;/p&gt;
&lt;p&gt;规则包含了 &lt;strong&gt;匹配标准&lt;/strong&gt; 和 &lt;strong&gt;具体动作&lt;/strong&gt;。内核会依次遍历规则链中的规则。&lt;/p&gt;
&lt;p&gt;当数据包满足某一条规则的匹配标准时，内核将会执行规则所制定的具体动作。&lt;/p&gt;
&lt;p&gt;比如系统管理员设置了“来自a.b.c.d的连接可以接收”这样的一条规则，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;来自a.b.c.d的连接&lt;/strong&gt; 指的是 匹配标准&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接收&lt;/strong&gt; 是 具体动作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当具体动作只是用来 &lt;strong&gt;记录日志&lt;/strong&gt; 或者 &lt;strong&gt;标记数据包&lt;/strong&gt; 时，表明该动作不具有 &lt;strong&gt;终结&lt;/strong&gt; 特性，内核还是会继续遍历规则链中剩下的规则。否则，当内核匹配上了具有终结特性动作的规则时，内核执行完具体动作之后，将停止遍历剩下的规则。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;具体动作分为 终结 和 非终结 两种类型，其中非终结类型使用较多的一种是跳到自定义的规则链上遍历规则。&lt;/p&gt;
&lt;p&gt;所谓终结特性是指不会影响到数据包的命运。所以条件越苛刻的规则应该放越前面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当规则链中没有规则，或者是数据包没有满足任何一条终结特性的规则时，内核将会采用规则链的 &lt;strong&gt;策略&lt;/strong&gt; 来决定是否接收该数据包。&lt;/p&gt;
&lt;p&gt;策略一共有两种：接收和丢弃。从另外一个角度看，规则链的策略体现出访问控制策略的设计：&lt;strong&gt;通&lt;/strong&gt; 和 &lt;strong&gt;堵&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于通策略而言，整个系统的大门是关闭着的，只有系统管理员赋予你权限才能访问。而堵则是整个系统的大门都是敞开着的，而规则将用来限制一些用户的访问。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自定义的规则链并不存在策略，当出现没有规则匹配或者数据包不满足规则时，将会跳回上一级，类似于函数调用栈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;iptables&#34;&gt;iptables&lt;/h3&gt;
&lt;p&gt;iptables 是 Netfilter 模块提供的命令接口，系统管理员可以通过它来配置各种访问控制规则。在定义规则时，可以参考以下模版。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# list rules in one table
# iptables -t table -nvL

# 查看 nat 功能表下规则
# iptables -t nat -nvL

# append new rule
# iptables [-t table] -A chain matchCretira -j action

# 系统管理员要限制来自 a.b.c.d IP 地址的访问
iptables -t filter -A INPUT -s a.b.c.d/n -j REJECT

# delete rule
# iptables [-t table] -D chain ruleNum

# 需要删除 filter/OUTPUT 的第二条规则
iptables -t filter -D OUTPUT 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;常用的具体动作有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filter 功能表：ACCEPT／DROP／REJECT／RETURN／LOG&lt;/li&gt;
&lt;li&gt;nat 功能表：SNAT／DNAT／REJECT／MASQUERADE／LOG&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;man iptables&lt;/code&gt; 能提供很多信息。但说明文档始终没有更新 nat 功能表添加了 INPUT 规则链。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;初体验&#34;&gt;初体验&lt;/h3&gt;
&lt;p&gt;为了保护本地环境以及模拟多节点环境，以下实验过程都在虚拟机上运行，并在虚拟机上利用Docker 来模拟多节点的环境。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# docker version | grep &#39;Version:&#39; -B 1
Client:
 Version:         1.12.5
--
Server:
 Version:         1.12.5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;整个网络模型如下图所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+---------------------------------------+
| +----------------+ +----------------+ |
| | Container #1   | | Container #2   | |
| | IP: 172.17.0.2 | | IP: 172.17.0.3 | |
| +-------------+--+ +--+-------------+ |
|               |       |               |
|               v       v               |
|           +---+-------+----+          |
|           | Bridge docker0 |          |
|           | IP: 172.17.0.1 |          |
|           +-------++-------+          |
| The               ||                  |
| Box     +--------------------+        |
+---------| Host-Only  Adapter |--------+
          | IP: 192.168.33.100 |
          +--------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;整个网络将虚拟机作为防火墙，初始状态下，不开放任何端口，将 filter 的三条内置链的策略为 DROP。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# iptables -t filter -P INPUT DROP
# iptables -t filter -P OUTPUT DROP
# iptables -t filter -P FOPWARD DROP
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置完以后，你会发现你连 ping 都 ping 不通了。。。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wfu at wfu-mac in ~/workspace/docs
$ ping -c 3 192.168.33.100
PING 192.168.33.100 (192.168.33.100): 56 data bytes
Request timeout for icmp_seq 0
Request timeout for icmp_seq 1

--- 192.168.33.100 ping statistics ---
3 packets transmitted, 0 packets received, 100.0% packet loss
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来的任务是能在 Mac 本地访问虚拟机里的 Docker Container，其中 Container 的启动方式如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# docker run -it -d ubuntu-nw python -m SimpleHTTPServer 8000
3301547d70b356223688fd9e38a1925ba90028084a44775bf79422be624c486b

# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
3301547d70b3        ubuntu-nw           &amp;quot;python -m SimpleHTTP&amp;quot;   9 seconds ago       Up 8 seconds                            boring_borg
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;开放22端口&#34;&gt;开放22端口&lt;/h3&gt;
&lt;p&gt;这台虚拟机默认是没有开启桌面。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# stty size
25 80
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在25 * 80这样的窗口里操作系统实在是太痛苦了。
在不启动桌面的情况，有必要通过远程登陆来改善下体验。&lt;/p&gt;
&lt;p&gt;虚拟机上已经预先装好了ssh server，只需要开放22端口即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# iptables -t filter -A INPUT -d 192.168.33.100 -p tcp --dport 22 -j ACCEPT
# iptables -t filter -A OUTPUT -s 192.168.33.100 -p tcp --sport 22 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么需要两条命令？&lt;/p&gt;
&lt;p&gt;回顾之前的内容，数据包穿过 INPUT 规则链后会被本地程序所消费。该数据包的生命周期就结束了，访问者接收到的数据包是本地程序所产生，这两者需要区分开。
第一条命令是系统管理员发给访问者的数据包的通行证，数据包到达 ssh server 之后就不复存在了，通行证也就不存在了。
ssh server 产生的数据包系统并不认识，它在穿过 OUTPUT 规则链时，如果没有通行证的话，就会被内核“吃掉”，永远都回不到访问者。
这需要两边都打通才能形成一个回路。&lt;/p&gt;
&lt;p&gt;好了，马上登陆虚拟机。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wfu at wfu-mac in ~/workspace/docs
$ ssh root@192.168.33.100
root@192.168.33.100&#39;s password:
Last login: Fri Mar  3 18:04:55 2017 from 192.168.33.1
[root@localhost ~]# stty size
72 278
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;可以在必要的时候记录日志。&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;iptables -t filter -I INPUT 1 -p icmp -j LOG --log-prefix &#39;filter-input:&#39;&lt;/code&gt;，只要 &lt;a href=&#34;https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol&#34;&gt;ICMP&lt;/a&gt; 数据包触发了 filter 功能表中的 INPUT 规则链，那么系统将会记录下该数据包的基本信息。&lt;/p&gt;
&lt;p&gt;然后通过 &lt;code&gt;tail -f /var/log/messages&lt;/code&gt; 来查看日志。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;如何访问容器&#34;&gt;如何访问容器&lt;/h3&gt;
&lt;p&gt;在创建 Container 的时候，如果不制定 Network 类型，那么 Daemon 会自动将 Container 挂到 docker0 下面，并形成了一个 &lt;code&gt;172.17.0.0/16&lt;/code&gt; 子网。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
6786e7d4c36a        bridge              bridge              local
f16e611d5715        host                host                local
912ae96541e9        none                null                local

# docker network inspect bridge
[
    {
        &amp;quot;Name&amp;quot;: &amp;quot;bridge&amp;quot;,
        &amp;quot;Id&amp;quot;: &amp;quot;6786e7d4c36acbd9d359289f90bd737bfcb21e74a5e467769e45fa9f732954f2&amp;quot;,
        &amp;quot;Scope&amp;quot;: &amp;quot;local&amp;quot;,
        &amp;quot;Driver&amp;quot;: &amp;quot;bridge&amp;quot;,
        &amp;quot;EnableIPv6&amp;quot;: false,
        &amp;quot;IPAM&amp;quot;: {
            &amp;quot;Driver&amp;quot;: &amp;quot;default&amp;quot;,
            &amp;quot;Options&amp;quot;: null,
            &amp;quot;Config&amp;quot;: [
                {
                    &amp;quot;Subnet&amp;quot;: &amp;quot;172.17.0.0/16&amp;quot;,
                    &amp;quot;Gateway&amp;quot;: &amp;quot;172.17.0.1&amp;quot;
                }
            ]
        },
        &amp;quot;Internal&amp;quot;: false,
        &amp;quot;Containers&amp;quot;: {},
        &amp;quot;Options&amp;quot;: {
            &amp;quot;com.docker.network.bridge.default_bridge&amp;quot;: &amp;quot;true&amp;quot;,
            &amp;quot;com.docker.network.bridge.enable_icc&amp;quot;: &amp;quot;true&amp;quot;,
            &amp;quot;com.docker.network.bridge.enable_ip_masquerade&amp;quot;: &amp;quot;true&amp;quot;,
            &amp;quot;com.docker.network.bridge.host_binding_ipv4&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
            &amp;quot;com.docker.network.bridge.name&amp;quot;: &amp;quot;docker0&amp;quot;,
            &amp;quot;com.docker.network.driver.mtu&amp;quot;: &amp;quot;1500&amp;quot;
        },
        &amp;quot;Labels&amp;quot;: {}
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而 Mac 和 虚拟机在 &lt;code&gt;192.168.33.0/24&lt;/code&gt; 子网内，想要在 Mac 访问虚拟机上的 Container，需要用 Destination NAT 转发请求，所以只需要关注 &lt;code&gt;PREROUTING&lt;/code&gt;／&lt;code&gt;FORWARD&lt;/code&gt; 这两条规则链即可。&lt;/p&gt;
&lt;p&gt;Docker Daemon 启动以后会自动在 Netfilter 添加访问控制规则。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# iptables -t nat -nvL
Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
    0     0 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL

Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 1 packets, 128 bytes)
 pkts bytes target     prot opt in     out     source               destination
    0     0 DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL

Chain POSTROUTING (policy ACCEPT 1 packets, 128 bytes)
 pkts bytes target     prot opt in     out     source               destination
    0     0 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0

Chain DOCKER (2 references)
 pkts bytes target     prot opt in     out     source               destination
    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PREROUTING 规则链只有一条规则，只要目的地址是本地地址，就跳到 DOCKER 这条自定义规则链中。
DOCKER 规则链中，只要数据包到达 docker0 网卡，就直接返回到上一层。&lt;/p&gt;
&lt;p&gt;Mac 发来的数据包不会直接到达 docker0 网卡，而是 enp0s8 网卡。所以需要在 DOCKER 规则链中添加对来自 &lt;code&gt;192.168.33.0/24&lt;/code&gt; 的 Destination NAT 规则。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nat 功能表中 OUTPUT 规则链是用来对本地数据进行 DNAT／REDIRECT 操作，因为系统内部的通信一般情况不会穿过 PREROUTING。而在 DOCKER 规则链中添加对外部地址的 DNAT 规则并不会在 OUTPUT 规则链中被匹配。&lt;/p&gt;
&lt;p&gt;一旦通信双方通过 nat 功能表建立连接，内核将不会使用 nat 功能表上的规则过滤该连接上的数据包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: enp0s8: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 08:00:27:20:9f:cb brd ff:ff:ff:ff:ff:ff
    inet 192.168.33.100/24 brd 192.168.33.255 scope global enp0s8
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fe20:9fcb/64 scope link
       valid_lft forever preferred_lft forever
3: docker0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noqueue state DOWN
    link/ether 02:42:c3:e1:87:ab brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 scope global docker0
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数据包经过 PREROUTING 规则链之后，被路由到了 FORWARD 规则链。&lt;/p&gt;
&lt;p&gt;数据包在 enp0s3 网卡与 docker0 网卡的转发，会匹配到 FORWARD 规则链的第3和第4条规则，这里不需要额外的配置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# iptables -t filter -xnvL
Chain INPUT (policy ACCEPT 9 packets, 548 bytes)
    pkts      bytes target     prot opt in     out     source               destination

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
    pkts      bytes target     prot opt in     out     source               destination
     108    13856 DOCKER-ISOLATION  all  --  *      *       0.0.0.0/0            0.0.0.0/0
      58     3736 DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0
       0        0 ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED
      50    10120 ACCEPT     all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0
       0        0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0

Chain OUTPUT (policy ACCEPT 7 packets, 744 bytes)
    pkts      bytes target     prot opt in     out     source               destination

Chain DOCKER (1 references)
    pkts      bytes target     prot opt in     out     source               destination

Chain DOCKER-ISOLATION (1 references)
    pkts      bytes target     prot opt in     out     source               destination
     108    13856 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据上面的分析，我们只需要添加下面一条规则，便可访问该 Container。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# iptables -t nat -A DOCKER -p tcp -i enp0s8 -d 192.168.33.100 --dport 80 -j DNAT --to-destination 172.17.0.2:8000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;访问结果如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wfu at wfu-mac in ~/workspace/docs
$ curl 192.168.33.100
&amp;lt;!DOCTYPE html PUBLIC &amp;quot;-//W3C//DTD HTML 3.2 Final//EN&amp;quot;&amp;gt;&amp;lt;html&amp;gt;
&amp;lt;title&amp;gt;Directory listing for /&amp;lt;/title&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h2&amp;gt;Directory listing for /&amp;lt;/h2&amp;gt;
&amp;lt;hr&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;.dockerenv&amp;quot;&amp;gt;.dockerenv&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;bin/&amp;quot;&amp;gt;bin/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;boot/&amp;quot;&amp;gt;boot/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;dev/&amp;quot;&amp;gt;dev/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;etc/&amp;quot;&amp;gt;etc/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;home/&amp;quot;&amp;gt;home/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;lib/&amp;quot;&amp;gt;lib/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;lib64/&amp;quot;&amp;gt;lib64/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;media/&amp;quot;&amp;gt;media/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;mnt/&amp;quot;&amp;gt;mnt/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;opt/&amp;quot;&amp;gt;opt/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;proc/&amp;quot;&amp;gt;proc/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;root/&amp;quot;&amp;gt;root/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;run/&amp;quot;&amp;gt;run/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;sbin/&amp;quot;&amp;gt;sbin/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;srv/&amp;quot;&amp;gt;srv/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;sys/&amp;quot;&amp;gt;sys/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;tmp/&amp;quot;&amp;gt;tmp/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;usr/&amp;quot;&amp;gt;usr/&amp;lt;/a&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;var/&amp;quot;&amp;gt;var/&amp;lt;/a&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;hr&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;docker run -it -d ubuntu-nw -p 80:8000 python -m SimpleHTTPServer 8000&lt;/code&gt; 能帮我们完成这次访问，可以观察 Docker Daemon 都为我们做了什么。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
