<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>containerd 1.7: Image Transfer Service | fuweid</title><meta name=keywords content><meta name=description content="镜像下载流程调整"><meta name=author content><link rel=canonical href=https://fuweid.com/post/2023-containerd-17-transfer-service/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://fuweid.com/favicon.jpg><link rel=icon type=image/png sizes=16x16 href=https://fuweid.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fuweid.com/favicon-32x32.png><link rel=apple-touch-icon href=https://fuweid.com/apple-touch-icon.png><link rel=mask-icon href=https://fuweid.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-1C7VLVHN52"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1C7VLVHN52",{anonymize_ip:!1})}</script><meta property="og:title" content="containerd 1.7: Image Transfer Service"><meta property="og:description" content="镜像下载流程调整"><meta property="og:type" content="article"><meta property="og:url" content="https://fuweid.com/post/2023-containerd-17-transfer-service/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-03-13T01:20:45+08:00"><meta property="article:modified_time" content="2023-03-13T01:20:45+08:00"><meta property="og:site_name" content="fuweid"><meta name=twitter:card content="summary"><meta name=twitter:title content="containerd 1.7: Image Transfer Service"><meta name=twitter:description content="镜像下载流程调整"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fuweid.com/post/"},{"@type":"ListItem","position":2,"name":"containerd 1.7: Image Transfer Service","item":"https://fuweid.com/post/2023-containerd-17-transfer-service/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"containerd 1.7: Image Transfer Service","name":"containerd 1.7: Image Transfer Service","description":"镜像下载流程调整","keywords":[],"articleBody":"从 HELM Chart 成功对接容器镜像仓库开始，到近两年 OCI 社区 artifacts 标准化的落地推广，现在 OCI Registry as Storage 已经是事实标准，不同业务场景的数据存储都可以对接 OCI registry 的分发协议。同时，这几年容器镜像的安全供应链需求徒增，以及各大云厂商对容器镜像 lazy-loading 探索力度在加大，OCI 社区在 artifacts 标准的基础上为容器镜像引入 referrers 定义：在保证前后兼容的情况下，每一个容器镜像都可以通过关联的 artifacts 来拓展自身的属性，如下图所示，用户可以通过 referrers 关联特性为 net-monitor:v1 镜像提供了镜像签名和 SBOM 信息。当然，容器镜像 lazy-loading 属性也可以与之相关联，比如阿里云的 overlaybd，蚂蚁金服的 nydus 以及亚马逊的 soci。\nNOTE: 图片取自 Feynman Zhou 发表的 Azure Container Registry: the first cloud registry to support the OCI Specifications 1.1 文章。\n可预见的是，各大云厂商的镜像仓库都会跟进这一标准，安全供应链以及容器镜像加速的增值服务也会因此得到大面积推广。而作为容器镜像的消费端，为了支持这一特性，containerd 社区的想法是引入组合型插件 Image Transfer Service，将镜像分发和打包处理都抽象成数据流的转发，并统一收编在服务端处理。\nPull 需要新的抽象 在 containerd 1.7 版本之前，镜像数据处理的绝大部分操作都集中在客户端。containerd 设计偏向于把服务端做薄，服务端仅做底层资源的 CRUD；而客户端则采用类似 Backends For Frontend 理念来为复杂流程封装接口，如下图所示 Pull 镜像的函数接口。下载镜像涉及到镜像地址解析、密钥管理、并发下载以及解压处理，但该流程仅适用于下载标准格式的镜像，任何调整都容易产生不适。\nNOTE: containerd CRI 插件属于 containerd 进程的一部分，因此 CRI 插件在使用 Pull 函数接口时，镜像数据在 content/diff/snapshotter service 之间传递不走 grpc 协议，仅是内部函数调用。\n让我们来简单回顾下当初 containerd 是如何支持容器镜像 lazy-loading 特性。\n由于容器镜像打包采用了不可检索的 tar 格式，因此目前市面上开源的镜像 lazy-loading 方案都涉及到镜像格式的改造，比如阿里云基于块设备的 overlaybd、蚂蚁金服基于文件系统的 nydus，以及 containerd 社区基于可检索 gzip 构建的 stargz。而格式的变化意味着 tar 解压流程不适合这类镜像(上图里的 apply diff 阶段)，为了适配这一特性，containerd 在 GA 之后首次修改了 snapshotter 元数据的管理逻辑 Support target snapshot references on prepare：即在解压镜像时，它会告知 snapshotter 插件这是为解压镜像而准备的可写层。\n容器镜像的制作过程大多都是将容器的可写层提交成镜像的只读层，因此 containerd snapshotter 实现里并不会区分可写层是为谁准备的。而上述特性可以让 lazy-loading snapshotter 感知到这是在下镜像阶段，它可以通过返回 已存在 错误来告知客户端：该镜像层已经下载并解压过了，请处理下一层吧。在不大改流程的情况下，这也算是支持 lazy-loading 特性。\n但这种方案仅支持匿名用户访问的镜像。基于安全的考虑，下镜像过程并不会将用户密钥信息传递给 snapshotter；而 lazy-loading 需要时刻保证数据可访问，否则业务容器在读取 rootfs 时将会出现 IO 阻塞。直到目前为止，containerd 社区依旧在讨论如何管理用户密钥信息: Enable remote snapshotter to receive creds from containerd CRI plugin。除此之外，容器镜像 lazy-loading 特性还要求用户手动替换或者集群管理员通过 webhook 来修改 pod 里的镜像信息。从产品侧的角度看，这种端到端的集成体验极差。\n安全供应链相关的特性也面临相同问题：Datadog 开发者提出 Plugin to CRI for image digest verification，他们希望 containerd 能在下载镜像阶段进行镜像校验，而不是在集群的 webhook 里。但目前的 Pull 流程是无法感知镜像的辅助信息，更谈不上校验。考虑到镜像辅助信息的多样性，Pull 函数接口的 Optional 配置方法无法满足插件化需求。\nImage Transfer Service 镜像数据的来源可以是镜像仓库、本地镜像 tar.gz 或者是本地解压后的存储等。不同的来源之间可以相互流动，比如下载流程可以理解成 镜像仓库 -\u003e 本地对象存储 (containerd content service) -\u003e 本地解压后的存储 (containerd snapshot service)，相反的流转将变成上传镜像；甚至还可以通过简单的数据转发，实现镜像在不同仓库之间迁移。containerd 通过引入 Image Transfer service 来将 Pull/Push 抽象成数据迁移流程，而 transfer service 本身是插件化的，在相同数据流向的情况下，containerd 支持定制化开发。\ntype Transferer interface { Transfer(ctx context.Context, source interface{}, destination interface{}, opts ...Opt， ) error } 如上图所示，Transfer objects 代表着数据源，数据流向是 Registry 到 Image Store，目前已在 1.7 版本里支持的迁移能力如下表所示。其中数据转发过程可能会和客户端交互，比如推送当前的传输状态，或者客户端提供密钥信息做鉴权等等。这些交互过程都通过 streaming service 来实现: 客户端在发起数据传输时，它会向 streaming service 申请数据交互通道，这些通道将会共享给 Transfer object，并由具体的 Transfer object 实现来决定如何交互。\nSource Destination Description Registry Image Store “pull” Image Store Registry “push” Object stream (Archive) Image Store “import” Image Store Object stream (Archive) “export” Image Store Image Store “tag” 对于 lazy-loading 和安全供应链场景，镜像的数据流向应该如下表所示。在后续的实现里，fetch 操作将会负责拉取镜像相关的 referrers，并在目标数据源中做相应的处理，比如安全供应链的数据源会校验数据的合法性，而 lazy-loading 场景下的关注点将会是 如何通过 referrers 来获得真正的镜像格式，后续的进展可以关注 OCI Referrers API support。\nSource Destination Description Registry Content Store(Object Stream) “fetch” Content Store(Object Stream) Mount/Snapshot “unpack” Content Store(Object Stream) Image Store “tag” 除此之外，镜像的密钥管理也将会插件化，只是现在如何同 lazy-loading snapshotter 交互还未确定，后续的进展可以关注 [transfer] credential manager plugin。\n统一镜像处理逻辑 虽然 containerd CRI 插件使用了 Pull 函数方法来处理镜像下载，但是它有不少优化特性，比如可根据流量来自动取消下载 feature: support image pull progress timeout，通过共享机制来避免重复下载 CRI: improve image pulling performance，或者是优化 lazy-loading snapshotter 集成体验 Export remote snapshotter label handler 等。这些处理在 nerdctl 也有类似的实现，transfer service 的出现可以很好的统一类似的处理逻辑。\n需要说明的是，transfer service 出现并不意味着放弃客户端下载的支持，类似 buildkit 这样项目有自身镜像管理需求，transfer service 不一定适合它们，这些项目依旧会使用 containerd 提供的 Pull 函数接口。\n把镜像下载到虚拟机里？？ 有部分厂家会使用机密计算和普通安全容器来提供多住户的 Kubernetes 产品，为了保证容器数据安全，这些场景有在 Guest OS 内下镜像的需求。为了支持这一特性，containerd ttrpc 支持了 streaming 能力 Introduce streaming。配合上 transfer service，containerd 2.0 大概率会把下载请求转发给 Guest OS 内的控制器，如下图所示。这部分转发逻辑也还在设计阶段，预计会在 Sandbox API 定稿后出提供。\n最后 个人一直很喜欢 containerd 插件机制，所以整体下来会比较期待 transfer service 在插件管理上的演进。\n这一篇就先这样吧，有问题欢迎私信。\n下一篇打算聊一下 containerd 垃圾回收机制。\n","wordCount":"388","inLanguage":"en","datePublished":"2023-03-13T01:20:45+08:00","dateModified":"2023-03-13T01:20:45+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://fuweid.com/post/2023-containerd-17-transfer-service/"},"publisher":{"@type":"Organization","name":"fuweid","logo":{"@type":"ImageObject","url":"https://fuweid.com/favicon.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fuweid.com/ accesskey=h title="fuweid.com (Alt + H)">fuweid.com</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fuweid.com/>Home</a>&nbsp;»&nbsp;<a href=https://fuweid.com/post/>Posts</a></div><h1 class=post-title>containerd 1.7: Image Transfer Service</h1><div class=post-description>镜像下载流程调整</div><div class=post-meta><span title='2023-03-13 01:20:45 +0800 HKT'>March 13, 2023</span></div></header><div class=post-content><p>从 HELM Chart 成功对接容器镜像仓库开始，到近两年 OCI 社区 <a href=https://github.com/opencontainers/artifacts>artifacts</a> 标准化的落地推广，现在 OCI Registry as Storage 已经是事实标准，不同业务场景的数据存储都可以对接 OCI registry 的分发协议。同时，这几年容器镜像的安全供应链需求徒增，以及各大云厂商对容器镜像 lazy-loading 探索力度在加大，OCI 社区在 artifacts 标准的基础上为容器镜像引入 <a href=https://github.com/opencontainers/image-spec/pull/934>referrers</a> 定义：在保证前后兼容的情况下，每一个容器镜像都可以通过关联的 artifacts 来拓展自身的属性，如下图所示，用户可以通过 referrers 关联特性为 net-monitor:v1 镜像提供了镜像签名和 SBOM 信息。当然，容器镜像 lazy-loading 属性也可以与之相关联，比如阿里云的 <a href=https://github.com/containerd/overlaybd>overlaybd</a>，蚂蚁金服的 <a href=https://github.com/dragonflyoss/image-service>nydus</a> 以及亚马逊的 <a href=https://github.com/awslabs/soci-snapshotter>soci</a>。</p><p><img loading=lazy src=/img/2023-containerd-17-transfer-service/oci-image-referrers-example.png alt=from-oras-referrers-demo></p><blockquote><p>NOTE: 图片取自 Feynman Zhou 发表的 <a href=https://techcommunity.microsoft.com/t5/apps-on-azure-blog/azure-container-registry-the-first-cloud-registry-to-support-the/ba-p/3708998>Azure Container Registry: the first cloud registry to support the OCI Specifications 1.1</a> 文章。</p></blockquote><p>可预见的是，各大云厂商的镜像仓库都会跟进这一标准，安全供应链以及容器镜像加速的增值服务也会因此得到大面积推广。而作为容器镜像的消费端，为了支持这一特性，containerd 社区的想法是引入组合型插件 Image Transfer Service，将镜像分发和打包处理都抽象成数据流的转发，并统一收编在服务端处理。</p><h2 id=pull-需要新的抽象>Pull 需要新的抽象<a hidden class=anchor aria-hidden=true href=#pull-需要新的抽象>#</a></h2><p>在 containerd 1.7 版本之前，镜像数据处理的绝大部分操作都集中在客户端。containerd 设计偏向于把服务端做薄，服务端仅做底层资源的 CRUD；而客户端则采用类似 Backends For Frontend 理念来为复杂流程封装接口，如下图所示 <a href=https://pkg.go.dev/github.com/containerd/containerd@v1.7.0#Client.Pull>Pull</a> 镜像的函数接口。下载镜像涉及到镜像地址解析、密钥管理、并发下载以及解压处理，但该流程仅适用于下载标准格式的镜像，任何调整都容易产生不适。</p><p><img loading=lazy src=/img/2023-containerd-17-transfer-service/smart-client-pull.png alt=smart-client-pull></p><blockquote><p>NOTE: containerd CRI 插件属于 containerd 进程的一部分，因此 CRI 插件在使用 Pull 函数接口时，镜像数据在 content/diff/snapshotter service 之间传递不走 grpc 协议，仅是内部函数调用。</p></blockquote><p>让我们来简单回顾下当初 containerd 是如何支持容器镜像 lazy-loading 特性。</p><p>由于容器镜像打包采用了不可检索的 tar 格式，因此目前市面上开源的镜像 lazy-loading 方案都涉及到镜像格式的改造，比如阿里云基于块设备的 overlaybd、蚂蚁金服基于文件系统的 nydus，以及 containerd 社区基于可检索 gzip 构建的 <a href=https://github.com/containerd/stargz-snapshotter>stargz</a>。而格式的变化意味着 tar 解压流程不适合这类镜像(上图里的 <strong>apply diff</strong> 阶段)，为了适配这一特性，containerd 在 GA 之后首次修改了 snapshotter 元数据的管理逻辑 <a href=https://github.com/containerd/containerd/pull/3793>Support target snapshot references on prepare</a>：即在解压镜像时，它会告知 snapshotter 插件这是为解压镜像而准备的可写层。</p><p>容器镜像的制作过程大多都是将容器的可写层提交成镜像的只读层，因此 containerd snapshotter 实现里并不会区分可写层是为谁准备的。而上述特性可以让 lazy-loading snapshotter 感知到这是在下镜像阶段，它可以通过返回 <strong>已存在</strong> 错误来告知客户端：<strong>该镜像层已经下载并解压过了，请处理下一层吧</strong>。在不大改流程的情况下，这也算是支持 lazy-loading 特性。</p><p>但这种方案仅支持匿名用户访问的镜像。基于安全的考虑，下镜像过程并不会将用户密钥信息传递给 snapshotter；而 lazy-loading 需要时刻保证数据可访问，否则业务容器在读取 rootfs 时将会出现 IO 阻塞。直到目前为止，containerd 社区依旧在讨论如何管理用户密钥信息: <a href=https://github.com/containerd/containerd/issues/5105>Enable remote snapshotter to receive creds from containerd CRI plugin</a>。除此之外，容器镜像 lazy-loading 特性还要求用户手动替换或者集群管理员通过 webhook 来修改 pod 里的镜像信息。从产品侧的角度看，这种端到端的集成体验极差。</p><p>安全供应链相关的特性也面临相同问题：Datadog 开发者提出 <a href=https://github.com/containerd/containerd/issues/6691>Plugin to CRI for image digest verification</a>，他们希望 containerd 能在下载镜像阶段进行镜像校验，而不是在集群的 webhook 里。但目前的 Pull 流程是无法感知镜像的辅助信息，更谈不上校验。考虑到镜像辅助信息的多样性，Pull 函数接口的 Optional 配置方法无法满足插件化需求。</p><h2 id=image-transfer-service>Image Transfer Service<a hidden class=anchor aria-hidden=true href=#image-transfer-service>#</a></h2><p>镜像数据的来源可以是镜像仓库、本地镜像 tar.gz 或者是本地解压后的存储等。不同的来源之间可以相互流动，比如下载流程可以理解成 <strong>镜像仓库 -> 本地对象存储 (containerd content service) -> 本地解压后的存储 (containerd snapshot service)</strong>，相反的流转将变成上传镜像；甚至还可以通过简单的数据转发，实现镜像在不同仓库之间迁移。containerd 通过引入 <a href=https://github.com/containerd/containerd/issues/7592>Image Transfer service</a> 来将 Pull/Push 抽象成数据迁移流程，而 transfer service 本身是插件化的，在相同数据流向的情况下，containerd 支持定制化开发。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Transferer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>Transfer</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>	    <span class=nx>source</span> <span class=kd>interface</span><span class=p>{},</span>
</span></span><span class=line><span class=cl>		<span class=nx>destination</span> <span class=kd>interface</span><span class=p>{},</span>
</span></span><span class=line><span class=cl>		<span class=nx>opts</span> <span class=o>...</span><span class=nx>Opt</span><span class=err>，</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><img loading=lazy src=/img/2023-containerd-17-transfer-service/overview-transfer-service.png alt=overview-transfer-service></p><p>如上图所示，Transfer objects 代表着数据源，数据流向是 Registry 到 Image Store，目前已在 1.7 版本里支持的迁移能力如下表所示。其中数据转发过程可能会和客户端交互，比如推送当前的传输状态，或者客户端提供密钥信息做鉴权等等。这些交互过程都通过 <strong>streaming service</strong> 来实现: 客户端在发起数据传输时，它会向 <strong>streaming service</strong> 申请数据交互通道，这些通道将会共享给 Transfer object，并由具体的 Transfer object 实现来决定如何交互。</p><table><thead><tr><th>Source</th><th>Destination</th><th>Description</th></tr></thead><tbody><tr><td>Registry</td><td>Image Store</td><td>&ldquo;pull&rdquo;</td></tr><tr><td>Image Store</td><td>Registry</td><td>&ldquo;push&rdquo;</td></tr><tr><td>Object stream (Archive)</td><td>Image Store</td><td>&ldquo;import&rdquo;</td></tr><tr><td>Image Store</td><td>Object stream (Archive)</td><td>&ldquo;export&rdquo;</td></tr><tr><td>Image Store</td><td>Image Store</td><td>&ldquo;tag&rdquo;</td></tr></tbody></table><p>对于 lazy-loading 和安全供应链场景，镜像的数据流向应该如下表所示。在后续的实现里，<strong>fetch</strong> 操作将会负责拉取镜像相关的 referrers，并在目标数据源中做相应的处理，比如安全供应链的数据源会校验数据的合法性，而 lazy-loading 场景下的关注点将会是 <strong>如何通过 referrers 来获得真正的镜像格式</strong>，后续的进展可以关注 <a href=https://github.com/containerd/containerd/issues/7654>OCI Referrers API support</a>。</p><table><thead><tr><th>Source</th><th>Destination</th><th>Description</th></tr></thead><tbody><tr><td>Registry</td><td>Content Store(Object Stream)</td><td>&ldquo;fetch&rdquo;</td></tr><tr><td>Content Store(Object Stream)</td><td>Mount/Snapshot</td><td>&ldquo;unpack&rdquo;</td></tr><tr><td>Content Store(Object Stream)</td><td>Image Store</td><td>&ldquo;tag&rdquo;</td></tr></tbody></table><p>除此之外，镜像的密钥管理也将会插件化，只是现在如何同 lazy-loading snapshotter 交互还未确定，后续的进展可以关注 <a href=https://github.com/containerd/containerd/issues/8228>[transfer] credential manager plugin</a>。</p><h2 id=统一镜像处理逻辑>统一镜像处理逻辑<a hidden class=anchor aria-hidden=true href=#统一镜像处理逻辑>#</a></h2><p>虽然 containerd CRI 插件使用了 <strong>Pull</strong> 函数方法来处理镜像下载，但是它有不少优化特性，比如可根据流量来自动取消下载 <a href=https://github.com/containerd/containerd/pull/6150>feature: support image pull progress timeout</a>，通过共享机制来避免重复下载 <a href=https://github.com/containerd/containerd/pull/6702>CRI: improve image pulling performance</a>，或者是优化 lazy-loading snapshotter 集成体验 <a href=https://github.com/containerd/containerd/pull/8036>Export remote snapshotter label handler</a> 等。这些处理在 nerdctl 也有类似的实现，transfer service 的出现可以很好的统一类似的处理逻辑。</p><p>需要说明的是，transfer service 出现并不意味着放弃客户端下载的支持，类似 buildkit 这样项目有自身镜像管理需求，transfer service 不一定适合它们，这些项目依旧会使用 containerd 提供的 <strong>Pull</strong> 函数接口。</p><h2 id=把镜像下载到虚拟机里>把镜像下载到虚拟机里？？<a hidden class=anchor aria-hidden=true href=#把镜像下载到虚拟机里>#</a></h2><p>有部分厂家会使用机密计算和普通安全容器来提供多住户的 Kubernetes 产品，为了保证容器数据安全，这些场景有在 Guest OS 内下镜像的需求。为了支持这一特性，containerd ttrpc 支持了 streaming 能力 <a href=https://github.com/containerd/ttrpc/pull/107>Introduce streaming</a>。配合上 transfer service，containerd 2.0 大概率会把下载请求转发给 Guest OS 内的控制器，如下图所示。这部分转发逻辑也还在设计阶段，预计会在 Sandbox API 定稿后出提供。</p><p><img loading=lazy src=/img/2023-containerd-17-transfer-service/pull-image-in-vm.png alt=pull-image-in-vm></p><h2 id=最后>最后<a hidden class=anchor aria-hidden=true href=#最后>#</a></h2><p>个人一直很喜欢 containerd 插件机制，所以整体下来会比较期待 transfer service 在插件管理上的演进。</p><p>这一篇就先这样吧，有问题欢迎私信。</p><p>下一篇打算聊一下 containerd 垃圾回收机制。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://fuweid.com/post/2023-containerd-17-gc/><span class=title>« Prev</span><br><span>containerd 1.7: 垃圾回收的拓展</span></a>
<a class=next href=https://fuweid.com/post/2023-containerd-17-userns/><span class=title>Next »</span><br><span>containerd 1.7: UserNamespace Stateless Pod</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://fuweid.com/>fuweid</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>