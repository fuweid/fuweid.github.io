<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>eBPF Loader | fuweid</title><meta name=keywords content><meta name=description content="如何加载 eBPF 二进制"><meta name=author content><link rel=canonical href=https://fuweid.com/post/2022-ebpf-loader/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://fuweid.com/favicon.jpg><link rel=icon type=image/png sizes=16x16 href=https://fuweid.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fuweid.com/favicon-32x32.png><link rel=apple-touch-icon href=https://fuweid.com/apple-touch-icon.png><link rel=mask-icon href=https://fuweid.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-1C7VLVHN52"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1C7VLVHN52",{anonymize_ip:!1})}</script><meta property="og:title" content="eBPF Loader"><meta property="og:description" content="如何加载 eBPF 二进制"><meta property="og:type" content="article"><meta property="og:url" content="https://fuweid.com/post/2022-ebpf-loader/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-02-27T23:00:53+08:00"><meta property="article:modified_time" content="2022-02-27T23:00:53+08:00"><meta property="og:site_name" content="fuweid"><meta name=twitter:card content="summary"><meta name=twitter:title content="eBPF Loader"><meta name=twitter:description content="如何加载 eBPF 二进制"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fuweid.com/post/"},{"@type":"ListItem","position":2,"name":"eBPF Loader","item":"https://fuweid.com/post/2022-ebpf-loader/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"eBPF Loader","name":"eBPF Loader","description":"如何加载 eBPF 二进制","keywords":[],"articleBody":"0. What is eBPF? Extended Berkeley Packet Filter (eBPF) 是由 Linux 提供的内核技术，它是以安全沙盒 (Virtual Machine) 的形式运行用户定义的 ByteCode 来观测内核运行状态以及拓展内核的能力，开发者无需定制内核模块就可以高效地完成对现有模块的拓展。eBPF 安全沙盒是嵌入到 Linux 内核运行态的关键路径上，通过事件订阅的形式来触发 eBPF 程序，其运用场景有：\ncilium 在 L3/L4 提供高效的网络转发能力 bcc 提供常用的观测组件来定位业务遇到的性能问题 Google 内核调度拓展 ghOSt 我过去主要使用 eBPF 在观测和排查一些节点的性能问题。由于底层基础设施能力以及业务运行模型存在差异，这将导致节点组件出现不在预期内的行为，而在本地又难以复现，大大增加了沟通和排查成本。而 eBPF 可以捕捉到程序在内核里的状态，甚至是短命的程序调用 (比如容器领域的 runC 命令) 都可以捕捉, 它可以最大程度地呈现程序的运行状态来提升问题的排查效率。\n比如前段时间遇到的 containerD CRI 组件创建容器超时的问题，我通过 bcc stackcount 捕抓到 根因: umount 可写的文件系统时会调用底层文件系统的刷盘动作，它用来保证数据能及时落盘；但这同时也给磁盘带来压力，IOPS 弱的数据盘将会拖慢 umount 调用。对于一个不熟悉内核代码的开发者来说，eBPF 观测类工具暴露出的关键函数路径就和日志的错误信息一样，全局搜索相应的内核代码段，然后顺藤摸瓜，总会找到些蛛丝马迹。\neBPF 目前发展的比较快，其中一个重要的支线是 Compile-Once Run-Everwhere (CO-RE) ，这有点像 docker 镜像分发的 Build-Once Run-Anywhere, 下面将主要围绕兼容性去介绍如何加载 eBPF 程序。\n1. Type Metadata eBPF 允许读取和修改内核运行态的数据，常见数据结构有线程的 task_struct 和网络子系统的 __sk_buff。这些常用的结构体在不同内核版本之间存在差异， 比如某一个字段位于 task_struct 结构体的第 16 字节处，然而升级到某一个内核版本后，这个字段被移到第 24 字节处，那么原先编译好的 eBPF 将无法正常工作。早期的 bcc 组件在使用过程中都是在目标节点上利用现有的内核相关头文件来编译。但即使如此，bcc 也没法解决字段名被更换的问题，字段名变化容易出现编译不通过。因此早期大部分情况下，开发者还是会选择根据不同内核版本出不同的二进制，这给测试验证带来了极大的成本。\n为了解决类型匹配问题，eBPF 需要额外的类型系统的描述数据。eBPF 程序所使用的数据类型和函数接口都通过常用的调试信息 DWARF 描述, 如下图所示 bootstrap.bpf.c 编译完毕后的 task_struct 部分类型信息， 其中 thread_info 和 state 是 task_struct的字段。\n// use llvm-dwarfdump ... 0x00005f27: DW_TAG_structure_type DW_AT_name (\"task_struct\") DW_AT_byte_size (0x1ac0) DW_AT_decl_file (\"xxx\") DW_AT_decl_line (883) 0x00005f2f: DW_TAG_member DW_AT_name (\"thread_info\") DW_AT_type (0x00006775 \"thread_info\") DW_AT_decl_file (\"xxx\") DW_AT_decl_line (884) DW_AT_data_member_location (0x00) 0x00005f3a: DW_TAG_member DW_AT_name (\"state\") DW_AT_type (0x00006793 \"volatile long\") DW_AT_decl_file (\"xxx\") DW_AT_decl_line (885) DW_AT_data_member_location (0x10) ... DWARF 对类型描述十分详细，包含类型字段的大小、字段的偏移量等等。当 eBPF 加载时，只需要在当前 Linux 内核的 DWARF 调试信息找到最匹配 eBPF 程序中的类型即可，即使字段的偏移量发生改变也没关系，只需 Relocation 成对应的偏移量即可。但 DWARF 调试信息为纯文本格式，内核的调试信息大概有 100+ MB，让内核启动带上这些信息成本太高了，这里需要可压缩的类型格式。\n内核社区提出了 BPF Type Format (BTF), 它可以将 100+ MB DWARF 信息压缩到 1.5 MB，eBPF 以及 Linux 内核都方便携带，具体的压缩算法可以阅读 BTF deduplication and Linux kernel BTF, 在此就仅仅展示 BTF dump 信息。\n// use pahole -JV ... [624] STRUCT task_struct size=6848 thread_info type_id=625 bits_offset=0 state type_id=626 bits_offset=128 stack type_id=29 bits_offset=192 usage type_id=308 bits_offset=256 flags type_id=37 bits_offset=288 ptrace type_id=37 bits_offset=320 on_cpu type_id=10 bits_offset=352 wake_entry type_id=628 bits_offset=384 cpu type_id=37 bits_offset=512 ... 当每个字段的偏移量以及类型信息可通过极低的成本携带时，eBPF 加载器可以使用类型匹配策略来将使用体验提升到新的高度。下面将介绍加载器的核心工作 - 重定向。\n2. Relocation eBPF 一般来说是由 clang/llvm 编译 C 文件得到的 ELF 二进制文件， 其中它采用十个通用的寄存器、只读的 Frame Pointer 寄存器以及使用长度为 64 bits 的 指令集。加载器需要解决重定向后才能进行 BPF Verifier，而重定向内容主要涉及到三部分 Map，CO-RE 以及函数调用。\n2.1 Map eBPF 程序和程序之间以及同用户态之间的交互都是通过 Map 来实现，而 Map 增删改查是通过文件句柄的形式来操作，而这依赖 BPF_MAP_CREATE bpf 系统调用。\n// https://man7.org/linux/man-pages/man2/bpf.2.html bpf(BPF_MAP_CREATE, \u0026bpf_attr, sizeof(bpf_attr)); union bpf_attr { struct { /* anonymous struct used by BPF_MAP_CREATE command */ __u32 map_type; /* one of enum bpf_map_type */ __u32 key_size; /* size of key in bytes */ __u32 value_size; /* size of value in bytes */ __u32 max_entries; /* max number of entries in a map */ __u32 map_flags; /* prealloc or not */ }; } bpf_attr 定义可以从 ELF 二进制的 section .maps 或者 maps 中获取， 如下面的代码片段所示。bpf_map_def 定义数据模式已经被弃用了，如下图所示，加载器需要严格按照固定的偏移量来读取 bpf_attr，相比 BTF 类型系统而言，编码和使用体验都差很多。\n// Use BTF struct { __uint(type, BPF_MAP_TYPE_HASH); __uint(max_entries, 8192); __type(key, pid_t); __type(value, u64); } exec_start_btf SEC(\".maps\"); // Use symbol but it has been deprecated struct bpf_map_def SEC(\"maps\") exec_start_symbol = { .type = BPF_MAP_TYPE_HASH, .key_size = sizeof(pid_t), .value_size = sizeof(u64), .max_entries = 8192, }; // https://github.com/fuweid/demos/tree/master/ebpf ➜ llvm-readelf -s -x maps ./.output/example-map-relo.bpf.o Symbol table '.symtab' contains 6 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 SECTION LOCAL DEFAULT 2 tp/sched/sched_process_exec 2: 0000000000000000 184 FUNC GLOBAL DEFAULT 2 handle_exec 3: 0000000000000000 32 OBJECT GLOBAL DEFAULT 5 exec_start_btf 4: 0000000000000000 20 OBJECT GLOBAL DEFAULT 4 exec_start_symbol 5: 0000000000000000 13 OBJECT GLOBAL DEFAULT 3 LICENSE Hex dump of section 'maps': .type=1 .key_size=4 .value_size=8 .max_entries = 8192 0x00000000 01000000 04000000 08000000 00200000 ............. .. .flags=0 0x00000010 00000000 当加载器读取 eBPF ELF 时， 代码段 section, 比如 tp/sched/sched_process_exec, 其对应的重定向符号的偏移量会在 .reltp/sched/sched_process_exec 描述，如下面的结果所示，其中 18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DWORD 指令将是我们要替换的指令。\n➜ llvm-objdump -dr ./.output/example-map-relo-btf.bpf.o ./.output/example-map-relo-btf.bpf.o:\tfile format elf64-bpf Disassembly of section tp/sched/sched_process_exec: 0000000000000000 : 0:\t85 00 00 00 0e 00 00 00\tcall 14 1:\t77 00 00 00 20 00 00 00\tr0 \u003e\u003e= 32 2:\t63 0a fc ff 00 00 00 00\t*(u32 *)(r10 - 4) = r0 3:\t85 00 00 00 05 00 00 00\tcall 5 4:\t7b 0a f0 ff 00 00 00 00\t*(u64 *)(r10 - 16) = r0 5:\tbf a2 00 00 00 00 00 00\tr2 = r10 6:\t07 02 00 00 fc ff ff ff\tr2 += -4 7:\tbf a3 00 00 00 00 00 00\tr3 = r10 8:\t07 03 00 00 f0 ff ff ff\tr3 += -16 9:\t18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00\tr1 = 0 ll 0000000000000048: R_BPF_64_64\texec_start_btf 11:\tb7 04 00 00 00 00 00 00\tr4 = 0 12:\t85 00 00 00 02 00 00 00\tcall 2 13:\t95 00 00 00 00 00 00 00\texit ➜ llvm-readelf -r ./.output/example-map-relo-btf.bpf.o Relocation section '.reltp/sched/sched_process_exec' at offset 0x6d8 contains 1 entries: Offset Info Type Symbol's Value Symbol's Name 0000000000000048 0000000300000001 R_BPF_64_64 0000000000000000 exec_start_btf 当前阅读最新的内核文档 (v5.17.0-rc5) 没有说明如何替换 eBPF Map 符号指令，反倒是 libbpf 加载器中有说明：当指令类型为 LD_IMM64 且原寄存器编号不为 0 时，那么该指令可以被重写成 MAP 相关的操作，重写规则如下面的代码所示。回顾上头要被替换指令，其开头 18 为 LD_IMM64 且 01 是 r1 寄存器， 替换的 Map 符号符合该模式；因此通过 BPF 系统调用申请 Map 文件句柄之后，加载器可以把代码段中第 52 个 Byte 替换成对应的文件句柄即可。\n需要说明的是，替换的并不是 .reltp/sched/sched_process_exec 中提到的第 48 Byte。BPF 并不采用 Elf64_Rela 来携带 Addend， 而是针对不同的重定向类型作了特殊的约定， 比如 R_BPF_64_64 类型的替换地址为 重定向声明的偏移量 + 4 = 48 + 4 = 52。\n// https://github.com/libbpf/libbpf/blob/v0.7.0/include/uapi/linux/bpf.h#L1121 /* When BPF ldimm64's insn[0].src_reg != 0 then this can have * the following extensions: * * insn[0].src_reg: BPF_PSEUDO_MAP_[FD|IDX] * insn[0].imm: map fd or fd_idx * insn[1].imm: 0 * insn[0].off: 0 * insn[1].off: 0 * ldimm64 rewrite: address of map * verifier type: CONST_PTR_TO_MAP */ #define BPF_PSEUDO_MAP_FD\t1 #define BPF_PSEUDO_MAP_IDX\t5 为了方便用户态修改程序中的只读常量，clang/llvm 会将 const volatile 声明的全局变量合并成一个结构体，并将为其声明成只有 [一个元素的 Map]，数据按照顺序存储在第一个 Value 里。因为不同变量在结构体的偏移量不同，那么指令改写逻辑有点差异，如下面的代码所示。\n// https://github.com/libbpf/libbpf/blob/v0.7.0/include/uapi/linux/bpf.h#L1135 /* insn[0].src_reg: BPF_PSEUDO_MAP_[IDX_]VALUE * insn[0].imm: map fd or fd_idx * insn[1].imm: offset into value * insn[0].off: 0 * insn[1].off: 0 * ldimm64 rewrite: address of map[0]+offset * verifier type: PTR_TO_MAP_VALUE */ #define BPF_PSEUDO_MAP_VALUE\t2 #define BPF_PSEUDO_MAP_IDX_VALUE\t6 不过使用的时候一定要注意用户态的类似是不是和 eBPF 程序中的一致，感兴趣的可以查看 iovisor/bcc#3777。\n2.2 Field Offset Rewrite 前面提到了 Linux 内核社区设计可压缩的 BTF 格式，我们通过工具转化 DWARF 数据成 BTF，那么内核里所有的数据结构都可以通过 BTF 反推成 C 头文件。当我们有了这个 All-in-One 头文件，那我们就不再需要在安装 kernel-headers 了！没人喜欢安装一堆依赖，不是吗？！\n➜ bpftool btf dump file /sys/kernel/btf/vmlinux format c \u003e vmlinux.h 我们来看一个具体的例子吧， example-field-offset-rewrite 读取当前 exec 进程 task_struct 结构体，并返回它的 real_parent 的 pid。如下图所示，我们可以看到没有加载前的访问指令是符合 vmlinux.c 描述的偏移量的：\nreal_parent 在 task 变量的 9472 bits = 1184 bytes 的位置； 同时 real_parent 本身也是一个 task_struct 类型的变量，它的 pid 字段将在 9344 bits = 1168 bytes 位置读取。 ➜ llvm-objdump -dr ./.output/example-field-offset-rewrite.bpf.o ./.output/example-field-offset-rewrite.bpf.o:\tfile format elf64-bpf Disassembly of section tp/sched/sched_process_exec: 0000000000000000 : 0:\t85 00 00 00 23 00 00 00\tcall 35 // 使用 Ubuntu v5.8 内核 BTF dump 出来的 vmlinux.c // [596] STRUCT task_struct size=6848 // ... // real_parent type_id=594 bitfield_size=0 bits_offset=9472 1:\tb7 01 00 00 a0 04 00 00\tr1 = 1184 \u003c== 1184 Bytes 2:\t0f 10 00 00 00 00 00 00\tr0 += r1 3:\tbf a1 00 00 00 00 00 00\tr1 = r10 4:\t07 01 00 00 f0 ff ff ff\tr1 += -16 5:\tb7 02 00 00 08 00 00 00\tr2 = 8 6:\tbf 03 00 00 00 00 00 00\tr3 = r0 // bpf_probe_read 调用读出 real_parent task_struct == task-\u003ereal_parent 7:\t85 00 00 00 71 00 00 00\tcall 113 // [596] STRUCT task_struct size=6848 // ... // pid type_id=1800 bitfield_size=0 bits_offset=9344 8:\tb7 01 00 00 90 04 00 00\tr1 = 1168 9:\t79 a3 f0 ff 00 00 00 00\tr3 = *(u64 *)(r10 - 16) 10:\t0f 13 00 00 00 00 00 00\tr3 += r1 11:\tbf a1 00 00 00 00 00 00\tr1 = r10 12:\t07 01 00 00 fc ff ff ff\tr1 += -4 13:\tb7 02 00 00 04 00 00 00\tr2 = 4 14:\t85 00 00 00 71 00 00 00\tcall 113 15:\t61 a0 fc ff 00 00 00 00\tr0 = *(u32 *)(r10 - 4) 16:\t95 00 00 00 00 00 00 00\texit 但上面的 eBPF 指令访问 task_struct 内部字段是基于 v5.8 内核 BTF 构建的，和我当前的 v5.13.0 内核版本存在较大的差异， real_parent 和 pid 偏移量都变化较多。而且 llvm-objdump -dr 并没有显示哪些 [读取字段的指令] 需要替换。由于这部分指令修改策略还没有更新到当前最新的 v5.17.0-rc5 版本上，只能通过阅读代码来获取。\n➜ uname -a Linux chaofan 5.13.0-30-generic #33~20.04.1-Ubuntu SMP Mon Feb 7 14:25:10 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux ➜ bpftool btf dump file /sys/kernel/btf/vmlinux | less ... [174] STRUCT 'task_struct' size=9472 vlen=232 ... 'real_parent' type_id=175 bits_offset=18816 'pid' type_id=60 bits_offset=18688 通过查看代码，我发现主要由三个 Patch 来提供替换的编码信息：\n[BPF] Preserve debuginfo array/union/struct type/access index CO-RE offset relocations bpf: CO-RE support in the kernel 其中 llvm 的 Patch 做到了在 BTF 中保留对内核数据结构的访问路径, 如下面的代码片段所示， 目前 libbpf 加载器一次的访问路径的最大深度为 9。\n// https://github.com/cilium/ebpf/blob/v0.8.1/internal/btf/core.go#L435 struct sample { int a; struct { int b[10]; } }; struct sample s = ...; int x = \u0026s-\u003ea; // encoded as \"0:0\" (a is field #0) int y = \u0026s-\u003eb[5]; // encoded as \"0:1:0:5\" (anon struct is field #1, // b is field #0 inside anon struct, accessing elem #5) int z = \u0026s[10]-\u003eb; // encoded as \"10:1\" (ptr is used as an array) // More info： https://llvm.org/docs/LangRef.html#getelementptr-instruction 而 0:1:0:5 这样的信息作为字符串保存在 .BTF section 中，而重写指令的偏移量则保存在 .BTF.ext 的 sub-section 中，具体的数据结构如下：\n// https://www.kernel.org/doc/html/latest/bpf/btf.html struct btf_ext_info_sec { __u32 sec_name_off; /* offset to section name */ __u32 num_info; /* Followed by num_info * record_size number of bytes */ __u8 data[0]; }; // https://github.com/libbpf/libbpf/blob/v0.7.0/include/uapi/linux/bpf.h#L6560 struct bpf_core_relo { __u32 insn_off; // 一开始是 section 偏移量，读出来一般都会修改成 [基于所在函数的偏移量]， // 方便后续不同 section 函数指令合并后的指令重写。 __u32 type_id; // 以上面 struct sample，那么 type_id 为 struct sample 的 BTF ID __u32 access_str_off; // 0:1:0:5 enum bpf_core_relo_kind kind; }; // sub-section layout about bpf_core_relo btf_ext_info_sec for section #1 /* bpf_core_relo for section #1 */ btf_ext_info_sec for section #2 /* bpf_core_relo for section #2 */ ... 有了这样访问路径信息后，加载器会读出本地 BTF 信息按照访问路径进行相应的结构体匹配，当然这里是 [尽力去找最匹配的结果]，比如结构体的名字要一致，相应的结构体大小要一致等等。如果存在匹配结果，那么 bpf_core_relo.insn_off 对应的指令将会被修改； 否则，加载将会返回失败。\n[一次编译，到处运行] 将 eBPF 使用体验都提升了好几个档次，想想看，OCI Artifacts 是不是可以 eBPF 程序作分发标准化呢？!\n2.3 CALL INSN on pc-relative? eBPF 是将每一个函数挂到相应的事件触发器上。一般来说，调用自定义的函数都会被 inlined 掉，即使代码段不在同一个 section 里。如下面的代码所示，这样程序是不需要重写指令的。\n# https://github.com/fuweid/demos/blob/master/ebpf/example-func-inline.bpf.c ➜ llvm-objdump -dr ./.output/example-func-inline.bpf.o ./.output/example-func-inline.bpf.o:\tfile format elf64-bpf Disassembly of section .text: 0000000000000000 : 0:\tbf 10 00 00 00 00 00 00\tr0 = r1 1:\t67 00 00 00 01 00 00 00\tr0 \u003c\u003c= 1 2:\t95 00 00 00 00 00 00 00\texit Disassembly of section tp/sched/sched_process_exec: # 全部 inlined 到 handle_exec， 无需跳转 0000000000000000 : 0:\t85 00 00 00 05 00 00 00\tcall 5 1:\t67 00 00 00 01 00 00 00\tr0 \u003c\u003c= 1 2:\t95 00 00 00 00 00 00 00\texit 如果 double_ts 函数不 inlined，那么编译后的结果如下。可以看到函数代码段在不同的 Section 中，加载器需要把所有相关的代码片段都 [追加] 到 handle_exec 的末尾，然后根据重定向的偏移量来修改指令。\n需要注意的是，内核文档在描述 eBPF CALL 指令时并没有说 Immediate 是不是相对值。我是通过查看 libbpf 加载器中 BPF_PSEUDO_CALL 描述才知道这是一个相对值，偏移量的计算也是 约定值。函数调用重写相比 MAP/Field Offset 重写要简单些，一般这部分的指令修改都是放到最后做。\n# https://github.com/fuweid/demos/blob/master/ebpf/example-func-noinline.bpf.c ➜ llvm-objdump -dr ./.output/example-func-noinline.bpf.o ./.output/example-func-noinline.bpf.o:\tfile format elf64-bpf Disassembly of section .text: 0000000000000000 : 0:\tbf 10 00 00 00 00 00 00\tr0 = r1 1:\t67 00 00 00 01 00 00 00\tr0 \u003c\u003c= 1 2:\t95 00 00 00 00 00 00 00\texit Disassembly of section tp/sched/sched_process_exec: 0000000000000000 : 0:\t85 00 00 00 05 00 00 00\tcall 5 1:\tbf 01 00 00 00 00 00 00\tr1 = r0 2:\t85 10 00 00 ff ff ff ff\tcall -1 0000000000000010: R_BPF_64_32\t.text 3:\t95 00 00 00 00 00 00 00\texit # 修改后的结果 dump from kernel int handle_exec(struct trace_event_raw_sched_process_exec * ctx): ; ts = bpf_ktime_get_ns(); 0: (85) call bpf_ktime_get_ns#135136 ; ts = double_ts(ts); 1: (bf) r1 = r0 2: (85) call pc+1#bpf_prog_6aadb6445c8badae_F ; return ts; 3: (95) exit u64 double_ts(u64 ts): ; u64 double_ts(u64 ts) { 4: (bf) r0 = r1 ; return ts + ts; 5: (67) r0 \u003c\u003c= 1 ; return ts + ts; 6: (95) exit 3.0 Conclusion 本文只是简单介绍了 eBPF 加载器是怎么修改指令的，虽然还有很多细节没有提到，比如 CALL bpf_ktime_get_ns 指令是如何工作，以及 eBPF 尾调用如何拼接在一起等等，但大体的工作方式差不多，建议读一读 libbpf 加载器，或者 cilium/ebpf go 代码，还是比较有意思的。\n","wordCount":"1791","inLanguage":"en","datePublished":"2022-02-27T23:00:53+08:00","dateModified":"2022-02-27T23:00:53+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://fuweid.com/post/2022-ebpf-loader/"},"publisher":{"@type":"Organization","name":"fuweid","logo":{"@type":"ImageObject","url":"https://fuweid.com/favicon.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fuweid.com/ accesskey=h title="fuweid.com (Alt + H)">fuweid.com</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fuweid.com/>Home</a>&nbsp;»&nbsp;<a href=https://fuweid.com/post/>Posts</a></div><h1 class=post-title>eBPF Loader</h1><div class=post-description>如何加载 eBPF 二进制</div><div class=post-meta><span title='2022-02-27 23:00:53 +0800 HKT'>February 27, 2022</span></div></header><div class=post-content><h2 id=0-what-is-ebpf>0. What is eBPF?<a hidden class=anchor aria-hidden=true href=#0-what-is-ebpf>#</a></h2><p>Extended Berkeley Packet Filter (eBPF) 是由 Linux 提供的内核技术，它是以安全沙盒 (Virtual Machine) 的形式运行用户定义的 ByteCode 来观测内核运行状态以及拓展内核的能力，开发者无需定制内核模块就可以高效地完成对现有模块的拓展。eBPF 安全沙盒是嵌入到 Linux 内核运行态的关键路径上，通过事件订阅的形式来触发 eBPF 程序，其运用场景有：</p><ul><li><a href=https://github.com/cilium/cilium>cilium</a> 在 L3/L4 提供高效的网络转发能力</li><li><a href=https://github.com/iovisor/bcc>bcc</a> 提供常用的观测组件来定位业务遇到的性能问题</li><li>Google 内核调度拓展 <a href=https://github.com/google/ghost-userspace>ghOSt</a></li></ul><p>我过去主要使用 eBPF 在观测和排查一些节点的性能问题。由于底层基础设施能力以及业务运行模型存在差异，这将导致节点组件出现不在预期内的行为，而在本地又难以复现，大大增加了沟通和排查成本。而 eBPF 可以捕捉到程序在内核里的状态，甚至是短命的程序调用 (比如容器领域的 runC 命令) 都可以捕捉, 它可以最大程度地呈现程序的运行状态来提升问题的排查效率。</p><p>比如前段时间遇到的 containerD CRI 组件创建容器超时的问题，我通过 <a href=https://github.com/iovisor/bcc>bcc</a> stackcount 捕抓到 <a href=https://github.com/containerd/containerd/pull/6478>根因</a>: umount 可写的文件系统时会调用底层文件系统的刷盘动作，它用来保证数据能及时落盘；但这同时也给磁盘带来压力，IOPS 弱的数据盘将会拖慢 umount 调用。对于一个不熟悉内核代码的开发者来说，eBPF 观测类工具暴露出的关键函数路径就和日志的错误信息一样，全局搜索相应的内核代码段，然后顺藤摸瓜，总会找到些蛛丝马迹。</p><p>eBPF 目前发展的比较快，其中一个重要的支线是 Compile-Once Run-Everwhere (CO-RE) ，这有点像 <a href=https://github.com/moby/moby>docker</a> 镜像分发的 Build-Once Run-Anywhere, 下面将主要围绕兼容性去介绍如何加载 eBPF 程序。</p><h3 id=1-type-metadata>1. Type Metadata<a hidden class=anchor aria-hidden=true href=#1-type-metadata>#</a></h3><p>eBPF 允许读取和修改内核运行态的数据，常见数据结构有线程的 <code>task_struct</code> 和网络子系统的 <code>__sk_buff</code>。这些常用的结构体在不同内核版本之间存在差异， 比如某一个字段位于 <code>task_struct</code> 结构体的第 16 字节处，然而升级到某一个内核版本后，这个字段被移到第 24 字节处，那么原先编译好的 eBPF 将无法正常工作。早期的 <a href=https://github.com/iovisor/bcc>bcc</a> 组件在使用过程中都是在目标节点上利用现有的内核相关头文件来编译。但即使如此，bcc 也没法解决字段名被更换的问题，字段名变化容易出现编译不通过。因此早期大部分情况下，开发者还是会选择根据不同内核版本出不同的二进制，这给测试验证带来了极大的成本。</p><p>为了解决类型匹配问题，eBPF 需要额外的类型系统的描述数据。eBPF 程序所使用的数据类型和函数接口都通过常用的调试信息 <a href=https://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf>DWARF</a> 描述, 如下图所示 <a href=https://github.com/libbpf/libbpf-bootstrap/blob/master/examples/c/bootstrap.bpf.c>bootstrap.bpf.c</a> 编译完毕后的 <code>task_struct</code> 部分类型信息， 其中 <code>thread_info</code> 和 <code>state</code> 是 <code>task_struct</code>的字段。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// use llvm-dwarfdump
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0x00005f27:   DW_TAG_structure_type
</span></span><span class=line><span class=cl>                DW_AT_name      (&#34;task_struct&#34;)
</span></span><span class=line><span class=cl>                DW_AT_byte_size (0x1ac0)
</span></span><span class=line><span class=cl>                DW_AT_decl_file (&#34;xxx&#34;)
</span></span><span class=line><span class=cl>                DW_AT_decl_line (883)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0x00005f2f:     DW_TAG_member
</span></span><span class=line><span class=cl>                  DW_AT_name    (&#34;thread_info&#34;)
</span></span><span class=line><span class=cl>                  DW_AT_type    (0x00006775 &#34;thread_info&#34;)
</span></span><span class=line><span class=cl>                  DW_AT_decl_file       (&#34;xxx&#34;)
</span></span><span class=line><span class=cl>                  DW_AT_decl_line       (884)
</span></span><span class=line><span class=cl>                  DW_AT_data_member_location    (0x00)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0x00005f3a:     DW_TAG_member
</span></span><span class=line><span class=cl>                  DW_AT_name    (&#34;state&#34;)
</span></span><span class=line><span class=cl>                  DW_AT_type    (0x00006793 &#34;volatile long&#34;)
</span></span><span class=line><span class=cl>                  DW_AT_decl_file       (&#34;xxx&#34;)
</span></span><span class=line><span class=cl>                  DW_AT_decl_line       (885)
</span></span><span class=line><span class=cl>                  DW_AT_data_member_location    (0x10)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>DWARF 对类型描述十分详细，包含类型字段的大小、字段的偏移量等等。当 eBPF 加载时，只需要在当前 Linux 内核的 DWARF 调试信息找到最匹配 eBPF 程序中的类型即可，即使字段的偏移量发生改变也没关系，只需 Relocation 成对应的偏移量即可。但 DWARF 调试信息为纯文本格式，内核的调试信息大概有 100+ MB，让内核启动带上这些信息成本太高了，这里需要可压缩的类型格式。</p><p>内核社区提出了 <a href=https://www.kernel.org/doc/html/v5.13/bpf/btf.html>BPF Type Format (BTF)</a>, 它可以将 100+ MB DWARF 信息压缩到 1.5 MB，eBPF 以及 Linux 内核都方便携带，具体的压缩算法可以阅读 <a href=https://nakryiko.com/posts/btf-dedup/>BTF deduplication and Linux kernel BTF</a>, 在此就仅仅展示 BTF dump 信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>// use pahole -JV
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[624] STRUCT task_struct size=6848
</span></span><span class=line><span class=cl>        thread_info type_id=625 bits_offset=0
</span></span><span class=line><span class=cl>        state type_id=626 bits_offset=128
</span></span><span class=line><span class=cl>        stack type_id=29 bits_offset=192
</span></span><span class=line><span class=cl>        usage type_id=308 bits_offset=256
</span></span><span class=line><span class=cl>        flags type_id=37 bits_offset=288
</span></span><span class=line><span class=cl>        ptrace type_id=37 bits_offset=320
</span></span><span class=line><span class=cl>        on_cpu type_id=10 bits_offset=352
</span></span><span class=line><span class=cl>        wake_entry type_id=628 bits_offset=384
</span></span><span class=line><span class=cl>        cpu type_id=37 bits_offset=512
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>当每个字段的偏移量以及类型信息可通过极低的成本携带时，eBPF 加载器可以使用类型匹配策略来将使用体验提升到新的高度。下面将介绍加载器的核心工作 - 重定向。</p><h3 id=2-relocation>2. Relocation<a hidden class=anchor aria-hidden=true href=#2-relocation>#</a></h3><p>eBPF 一般来说是由 clang/llvm 编译 C 文件得到的 ELF 二进制文件， 其中它采用十个通用的寄存器、只读的 Frame Pointer 寄存器以及使用长度为 64 bits 的 <a href=https://www.kernel.org/doc/html/latest/bpf/instruction-set.html>指令集</a>。加载器需要解决重定向后才能进行 BPF Verifier，而重定向内容主要涉及到三部分 Map，CO-RE 以及函数调用。</p><h4 id=21-map>2.1 Map<a hidden class=anchor aria-hidden=true href=#21-map>#</a></h4><p>eBPF 程序和程序之间以及同用户态之间的交互都是通过 Map 来实现，而 Map 增删改查是通过文件句柄的形式来操作，而这依赖 <a href=https://man7.org/linux/man-pages/man2/bpf.2.html>BPF_MAP_CREATE</a> bpf 系统调用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// https://man7.org/linux/man-pages/man2/bpf.2.html
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>bpf</span><span class=p>(</span><span class=n>BPF_MAP_CREATE</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bpf_attr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>bpf_attr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=n>bpf_attr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=p>{</span> <span class=cm>/* anonymous struct used by BPF_MAP_CREATE command */</span>
</span></span><span class=line><span class=cl>      <span class=n>__u32</span>   <span class=n>map_type</span><span class=p>;</span>       <span class=cm>/* one of enum bpf_map_type */</span>
</span></span><span class=line><span class=cl>      <span class=n>__u32</span>   <span class=n>key_size</span><span class=p>;</span>       <span class=cm>/* size of key in bytes */</span>
</span></span><span class=line><span class=cl>      <span class=n>__u32</span>   <span class=n>value_size</span><span class=p>;</span>     <span class=cm>/* size of value in bytes */</span>
</span></span><span class=line><span class=cl>      <span class=n>__u32</span>   <span class=n>max_entries</span><span class=p>;</span>    <span class=cm>/* max number of entries in a map */</span>
</span></span><span class=line><span class=cl>      <span class=n>__u32</span>   <span class=n>map_flags</span><span class=p>;</span>      <span class=cm>/* prealloc or not */</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>bpf_attr</code> 定义可以从 ELF 二进制的 section <code>.maps</code> 或者 <code>maps</code> 中获取， 如下面的代码片段所示。<code>bpf_map_def</code> 定义数据模式已经被弃用了，如下图所示，加载器需要严格按照固定的偏移量来读取 <code>bpf_attr</code>，相比 BTF 类型系统而言，编码和使用体验都差很多。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Use BTF
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>__uint</span><span class=p>(</span><span class=n>type</span><span class=p>,</span> <span class=n>BPF_MAP_TYPE_HASH</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>__uint</span><span class=p>(</span><span class=n>max_entries</span><span class=p>,</span> <span class=mi>8192</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>__type</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>pid_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>__type</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>u64</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>exec_start_btf</span> <span class=n>SEC</span><span class=p>(</span><span class=s>&#34;.maps&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Use symbol but it has been deprecated
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>bpf_map_def</span> <span class=nf>SEC</span><span class=p>(</span><span class=s>&#34;maps&#34;</span><span class=p>)</span> <span class=n>exec_start_symbol</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>type</span>        <span class=o>=</span> <span class=n>BPF_MAP_TYPE_HASH</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>key_size</span>    <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>pid_t</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>value_size</span>  <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>u64</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>max_entries</span> <span class=o>=</span> <span class=mi>8192</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// https://github.com/fuweid/demos/tree/master/ebpf
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>➜</span>  <span class=n>llvm</span><span class=o>-</span><span class=n>readelf</span> <span class=o>-</span><span class=n>s</span> <span class=o>-</span><span class=n>x</span> <span class=n>maps</span> <span class=p>.</span><span class=o>/</span><span class=p>.</span><span class=n>output</span><span class=o>/</span><span class=n>example</span><span class=o>-</span><span class=n>map</span><span class=o>-</span><span class=n>relo</span><span class=p>.</span><span class=n>bpf</span><span class=p>.</span><span class=n>o</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Symbol</span> <span class=n>table</span> <span class=err>&#39;</span><span class=p>.</span><span class=n>symtab</span><span class=err>&#39;</span> <span class=n>contains</span> <span class=mi>6</span> <span class=nl>entries</span><span class=p>:</span>
</span></span><span class=line><span class=cl>   <span class=nl>Num</span><span class=p>:</span>    <span class=n>Value</span>          <span class=n>Size</span> <span class=n>Type</span>    <span class=n>Bind</span>   <span class=n>Vis</span>       <span class=n>Ndx</span> <span class=n>Name</span>
</span></span><span class=line><span class=cl>     <span class=mi>0</span><span class=o>:</span> <span class=mo>0000000000000000</span>     <span class=mi>0</span> <span class=n>NOTYPE</span>  <span class=n>LOCAL</span>  <span class=n>DEFAULT</span>   <span class=n>UND</span> 
</span></span><span class=line><span class=cl>     <span class=mi>1</span><span class=o>:</span> <span class=mo>0000000000000000</span>     <span class=mi>0</span> <span class=n>SECTION</span> <span class=n>LOCAL</span>  <span class=n>DEFAULT</span>     <span class=mi>2</span> <span class=n>tp</span><span class=o>/</span><span class=n>sched</span><span class=o>/</span><span class=n>sched_process_exec</span>
</span></span><span class=line><span class=cl>     <span class=mi>2</span><span class=o>:</span> <span class=mo>0000000000000000</span>   <span class=mi>184</span> <span class=n>FUNC</span>    <span class=n>GLOBAL</span> <span class=n>DEFAULT</span>     <span class=mi>2</span> <span class=n>handle_exec</span>
</span></span><span class=line><span class=cl>     <span class=mi>3</span><span class=o>:</span> <span class=mo>0000000000000000</span>    <span class=mi>32</span> <span class=n>OBJECT</span>  <span class=n>GLOBAL</span> <span class=n>DEFAULT</span>     <span class=mi>5</span> <span class=n>exec_start_btf</span>
</span></span><span class=line><span class=cl>     <span class=mi>4</span><span class=o>:</span> <span class=mo>0000000000000000</span>    <span class=mi>20</span> <span class=n>OBJECT</span>  <span class=n>GLOBAL</span> <span class=n>DEFAULT</span>     <span class=mi>4</span> <span class=n>exec_start_symbol</span>
</span></span><span class=line><span class=cl>     <span class=mi>5</span><span class=o>:</span> <span class=mo>0000000000000000</span>    <span class=mi>13</span> <span class=n>OBJECT</span>  <span class=n>GLOBAL</span> <span class=n>DEFAULT</span>     <span class=mi>3</span> <span class=n>LICENSE</span>
</span></span><span class=line><span class=cl><span class=n>Hex</span> <span class=n>dump</span> <span class=n>of</span> <span class=n>section</span> <span class=err>&#39;</span><span class=n>maps</span><span class=err>&#39;</span><span class=o>:</span>
</span></span><span class=line><span class=cl>          <span class=p>.</span><span class=n>type</span><span class=o>=</span><span class=mi>1</span>     <span class=p>.</span><span class=n>key_size</span><span class=o>=</span><span class=mi>4</span>   <span class=p>.</span><span class=n>value_size</span><span class=o>=</span><span class=mi>8</span>   <span class=p>.</span><span class=n>max_entries</span> <span class=o>=</span> <span class=mi>8192</span>
</span></span><span class=line><span class=cl><span class=mh>0x00000000</span> <span class=mo>01000000</span>   <span class=mo>04000000</span>      <span class=mi>08000000</span>        <span class=mo>00200000</span> <span class=p>.............</span> <span class=p>..</span>
</span></span><span class=line><span class=cl>          <span class=p>.</span><span class=n>flags</span><span class=o>=</span><span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=mh>0x00000010</span> <span class=mo>00000000</span>
</span></span></code></pre></div><p>当加载器读取 eBPF ELF 时， 代码段 section, 比如 <code>tp/sched/sched_process_exec</code>, 其对应的重定向符号的偏移量会在 <code>.reltp/sched/sched_process_exec</code> 描述，如下面的结果所示，其中 <code>18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00</code> DWORD 指令将是我们要替换的指令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>➜  llvm-objdump -dr ./.output/example-map-relo-btf.bpf.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>./.output/example-map-relo-btf.bpf.o:	file format elf64-bpf
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Disassembly of section tp/sched/sched_process_exec:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=m>0000000000000000</span> &lt;handle_exec&gt;:
</span></span><span class=line><span class=cl>       0:	<span class=m>85</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 0e <span class=m>00</span> <span class=m>00</span> 00	call <span class=m>14</span>
</span></span><span class=line><span class=cl>       1:	<span class=m>77</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>20</span> <span class=m>00</span> <span class=m>00</span> 00	r0 &gt;&gt;<span class=o>=</span> <span class=m>32</span>
</span></span><span class=line><span class=cl>       2:	<span class=m>63</span> 0a <span class=nb>fc</span> ff <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	*<span class=o>(</span>u32 *<span class=o>)(</span>r10 - 4<span class=o>)</span> <span class=o>=</span> r0
</span></span><span class=line><span class=cl>       3:	<span class=m>85</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>05</span> <span class=m>00</span> <span class=m>00</span> 00	call <span class=m>5</span>
</span></span><span class=line><span class=cl>       4:	7b 0a f0 ff <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	*<span class=o>(</span>u64 *<span class=o>)(</span>r10 - 16<span class=o>)</span> <span class=o>=</span> r0
</span></span><span class=line><span class=cl>       5:	bf a2 <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r2</span> <span class=o>=</span> r10
</span></span><span class=line><span class=cl>       6:	<span class=m>07</span> <span class=m>02</span> <span class=m>00</span> <span class=m>00</span> <span class=nb>fc</span> ff ff ff	<span class=nv>r2</span> <span class=o>+=</span> -4
</span></span><span class=line><span class=cl>       7:	bf a3 <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r3</span> <span class=o>=</span> r10
</span></span><span class=line><span class=cl>       8:	<span class=m>07</span> <span class=m>03</span> <span class=m>00</span> <span class=m>00</span> f0 ff ff ff	<span class=nv>r3</span> <span class=o>+=</span> -16
</span></span><span class=line><span class=cl>       9:	<span class=m>18</span> <span class=m>01</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r1</span> <span class=o>=</span> <span class=m>0</span> ll
</span></span><span class=line><span class=cl>		0000000000000048:  R_BPF_64_64	exec_start_btf
</span></span><span class=line><span class=cl>      11:	b7 <span class=m>04</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r4</span> <span class=o>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>      12:	<span class=m>85</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>02</span> <span class=m>00</span> <span class=m>00</span> 00	call <span class=m>2</span>
</span></span><span class=line><span class=cl>      13:	<span class=m>95</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nb>exit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>➜  llvm-readelf -r ./.output/example-map-relo-btf.bpf.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Relocation section <span class=s1>&#39;.reltp/sched/sched_process_exec&#39;</span> at offset 0x6d8 contains <span class=m>1</span> entries:
</span></span><span class=line><span class=cl>    Offset             Info             Type               Symbol<span class=s1>&#39;s Value  Symbol&#39;</span>s Name
</span></span><span class=line><span class=cl><span class=m>0000000000000048</span>  <span class=m>0000000300000001</span> R_BPF_64_64            <span class=m>0000000000000000</span> exec_start_btf
</span></span></code></pre></div><p>当前阅读最新的内核文档 (v5.17.0-rc5) 没有说明如何替换 eBPF Map 符号指令，反倒是 <a href=https://github.com/libbpf/libbpf>libbpf</a> 加载器中有说明：当指令类型为 LD_IMM64 且原寄存器编号不为 0 时，那么该指令可以被重写成 MAP 相关的操作，重写规则如下面的代码所示。回顾上头要被替换指令，其开头 <code>18</code> 为 LD_IMM64 且 <code>01</code> 是 <code>r1</code> 寄存器， 替换的 Map 符号符合该模式；因此通过 BPF 系统调用申请 Map 文件句柄之后，加载器可以把代码段中第 52 个 Byte 替换成对应的文件句柄即可。</p><p>需要说明的是，替换的并不是 <code>.reltp/sched/sched_process_exec</code> 中提到的第 48 Byte。BPF 并不采用 <a href=https://llvm.org/doxygen/structllvm_1_1ELF_1_1Elf64__Rela.html>Elf64_Rela</a> 来携带 Addend， 而是<a href=https://www.kernel.org/doc/html/latest/bpf/llvm_reloc.html#different-relocation-types>针对不同的重定向类型作了特殊的约定</a>， 比如 <code>R_BPF_64_64</code> 类型的替换地址为 <code>重定向声明的偏移量 + 4 = 48 + 4 = 52</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// https://github.com/libbpf/libbpf/blob/v0.7.0/include/uapi/linux/bpf.h#L1121
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cm>/* When BPF ldimm64&#39;s insn[0].src_reg != 0 then this can have
</span></span></span><span class=line><span class=cl><span class=cm> * the following extensions:
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * insn[0].src_reg:  BPF_PSEUDO_MAP_[FD|IDX]
</span></span></span><span class=line><span class=cl><span class=cm> * insn[0].imm:      map fd or fd_idx
</span></span></span><span class=line><span class=cl><span class=cm> * insn[1].imm:      0
</span></span></span><span class=line><span class=cl><span class=cm> * insn[0].off:      0
</span></span></span><span class=line><span class=cl><span class=cm> * insn[1].off:      0
</span></span></span><span class=line><span class=cl><span class=cm> * ldimm64 rewrite:  address of map
</span></span></span><span class=line><span class=cl><span class=cm> * verifier type:    CONST_PTR_TO_MAP
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=cp>#define BPF_PSEUDO_MAP_FD	1
</span></span></span><span class=line><span class=cl><span class=cp>#define BPF_PSEUDO_MAP_IDX	5
</span></span></span></code></pre></div><p>为了方便用户态修改程序中的只读常量，clang/llvm 会将 <code>const volatile</code> 声明的全局变量合并成一个结构体，并将为其声明成只有 <strong>[一个元素的 Map]</strong>，数据按照顺序存储在第一个 Value 里。因为不同变量在结构体的偏移量不同，那么指令改写逻辑有点差异，如下面的代码所示。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// https://github.com/libbpf/libbpf/blob/v0.7.0/include/uapi/linux/bpf.h#L1135
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cm>/* insn[0].src_reg:  BPF_PSEUDO_MAP_[IDX_]VALUE
</span></span></span><span class=line><span class=cl><span class=cm> * insn[0].imm:      map fd or fd_idx
</span></span></span><span class=line><span class=cl><span class=cm> * insn[1].imm:      offset into value
</span></span></span><span class=line><span class=cl><span class=cm> * insn[0].off:      0
</span></span></span><span class=line><span class=cl><span class=cm> * insn[1].off:      0
</span></span></span><span class=line><span class=cl><span class=cm> * ldimm64 rewrite:  address of map[0]+offset
</span></span></span><span class=line><span class=cl><span class=cm> * verifier type:    PTR_TO_MAP_VALUE
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=cp>#define BPF_PSEUDO_MAP_VALUE		2
</span></span></span><span class=line><span class=cl><span class=cp>#define BPF_PSEUDO_MAP_IDX_VALUE	6
</span></span></span></code></pre></div><p>不过使用的时候一定要注意用户态的类似是不是和 eBPF 程序中的一致，感兴趣的可以查看 <a href=https://github.com/iovisor/bcc/pull/3777>iovisor/bcc#3777</a>。</p><h4 id=22-field-offset-rewrite>2.2 Field Offset Rewrite<a hidden class=anchor aria-hidden=true href=#22-field-offset-rewrite>#</a></h4><p>前面提到了 Linux 内核社区设计可压缩的 BTF 格式，我们通过工具转化 DWARF 数据成 BTF，那么内核里所有的数据结构都可以通过 BTF 反推成 C 头文件。当我们有了这个 All-in-One 头文件，那我们就不再需要在安装 kernel-headers 了！没人喜欢安装一堆依赖，不是吗？！</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>➜  bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h
</span></span></code></pre></div><p>我们来看一个具体的例子吧， <a href=https://github.com/fuweid/demos/blob/master/ebpf/example-field-offset-rewrite.bpf.c>example-field-offset-rewrite</a> 读取当前 exec 进程 <code>task_struct</code> 结构体，并返回它的 <code>real_parent</code> 的 pid。如下图所示，我们可以看到没有加载前的访问指令是符合 vmlinux.c 描述的偏移量的：</p><ul><li><code>real_parent</code> 在 <code>task</code> 变量的 <code>9472 bits = 1184 bytes</code> 的位置；</li><li>同时 <code>real_parent</code> 本身也是一个 <code>task_struct</code> 类型的变量，它的 <code>pid</code> 字段将在 <code>9344 bits = 1168 bytes</code> 位置读取。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>➜  llvm-objdump -dr ./.output/example-field-offset-rewrite.bpf.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>./.output/example-field-offset-rewrite.bpf.o:	file format elf64-bpf
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Disassembly of section tp/sched/sched_process_exec:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=m>0000000000000000</span> &lt;handle_exec&gt;:
</span></span><span class=line><span class=cl>       0:	<span class=m>85</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>23</span> <span class=m>00</span> <span class=m>00</span> 00	call <span class=m>35</span>
</span></span><span class=line><span class=cl>       // 使用 Ubuntu v5.8 内核 BTF dump 出来的 vmlinux.c 
</span></span><span class=line><span class=cl>       // <span class=o>[</span>596<span class=o>]</span> STRUCT task_struct <span class=nv>size</span><span class=o>=</span><span class=m>6848</span>
</span></span><span class=line><span class=cl>       //   ...
</span></span><span class=line><span class=cl>       //   real_parent <span class=nv>type_id</span><span class=o>=</span><span class=m>594</span> <span class=nv>bitfield_size</span><span class=o>=</span><span class=m>0</span> <span class=nv>bits_offset</span><span class=o>=</span><span class=m>9472</span>
</span></span><span class=line><span class=cl>       1:	b7 <span class=m>01</span> <span class=m>00</span> <span class=m>00</span> a0 <span class=m>04</span> <span class=m>00</span> 00	<span class=nv>r1</span> <span class=o>=</span> <span class=m>1184</span>  &lt;<span class=o>==</span> <span class=m>1184</span> Bytes
</span></span><span class=line><span class=cl>       2:	0f <span class=m>10</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r0</span> <span class=o>+=</span> r1
</span></span><span class=line><span class=cl>       3:	bf a1 <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r1</span> <span class=o>=</span> r10
</span></span><span class=line><span class=cl>       4:	<span class=m>07</span> <span class=m>01</span> <span class=m>00</span> <span class=m>00</span> f0 ff ff ff	<span class=nv>r1</span> <span class=o>+=</span> -16
</span></span><span class=line><span class=cl>       5:	b7 <span class=m>02</span> <span class=m>00</span> <span class=m>00</span> <span class=m>08</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r2</span> <span class=o>=</span> <span class=m>8</span>
</span></span><span class=line><span class=cl>       6:	bf <span class=m>03</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r3</span> <span class=o>=</span> r0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // bpf_probe_read 调用读出 real_parent <span class=nv>task_struct</span> <span class=o>==</span> task-&gt;real_parent
</span></span><span class=line><span class=cl>       7:	<span class=m>85</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>71</span> <span class=m>00</span> <span class=m>00</span> 00	call <span class=m>113</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      // <span class=o>[</span>596<span class=o>]</span> STRUCT task_struct <span class=nv>size</span><span class=o>=</span><span class=m>6848</span>
</span></span><span class=line><span class=cl>      //   ...
</span></span><span class=line><span class=cl>      // pid <span class=nv>type_id</span><span class=o>=</span><span class=m>1800</span> <span class=nv>bitfield_size</span><span class=o>=</span><span class=m>0</span> <span class=nv>bits_offset</span><span class=o>=</span><span class=m>9344</span>
</span></span><span class=line><span class=cl>       8:	b7 <span class=m>01</span> <span class=m>00</span> <span class=m>00</span> <span class=m>90</span> <span class=m>04</span> <span class=m>00</span> 00	<span class=nv>r1</span> <span class=o>=</span> <span class=m>1168</span>
</span></span><span class=line><span class=cl>       9:	<span class=m>79</span> a3 f0 ff <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r3</span> <span class=o>=</span> *<span class=o>(</span>u64 *<span class=o>)(</span>r10 - 16<span class=o>)</span>
</span></span><span class=line><span class=cl>      10:	0f <span class=m>13</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r3</span> <span class=o>+=</span> r1
</span></span><span class=line><span class=cl>      11:	bf a1 <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r1</span> <span class=o>=</span> r10
</span></span><span class=line><span class=cl>      12:	<span class=m>07</span> <span class=m>01</span> <span class=m>00</span> <span class=m>00</span> <span class=nb>fc</span> ff ff ff	<span class=nv>r1</span> <span class=o>+=</span> -4
</span></span><span class=line><span class=cl>      13:	b7 <span class=m>02</span> <span class=m>00</span> <span class=m>00</span> <span class=m>04</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r2</span> <span class=o>=</span> <span class=m>4</span>
</span></span><span class=line><span class=cl>      14:	<span class=m>85</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>71</span> <span class=m>00</span> <span class=m>00</span> 00	call <span class=m>113</span>
</span></span><span class=line><span class=cl>      15:	<span class=m>61</span> a0 <span class=nb>fc</span> ff <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r0</span> <span class=o>=</span> *<span class=o>(</span>u32 *<span class=o>)(</span>r10 - 4<span class=o>)</span>
</span></span><span class=line><span class=cl>      16:	<span class=m>95</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nb>exit</span>
</span></span></code></pre></div><p>但上面的 eBPF 指令访问 <code>task_struct</code> 内部字段是基于 v5.8 内核 BTF 构建的，和我当前的 v5.13.0 内核版本存在较大的差异， <code>real_parent</code> 和 <code>pid</code> 偏移量都变化较多。而且 <code>llvm-objdump -dr</code> 并没有显示哪些 [读取字段的指令] 需要替换。由于这部分指令修改策略还没有更新到当前最新的 <code>v5.17.0-rc5</code> 版本上，只能通过阅读代码来获取。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>➜  uname -a
</span></span><span class=line><span class=cl>Linux chaofan 5.13.0-30-generic <span class=c1>#33~20.04.1-Ubuntu SMP Mon Feb 7 14:25:10 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>➜  bpftool btf dump file /sys/kernel/btf/vmlinux <span class=p>|</span> less
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl><span class=o>[</span>174<span class=o>]</span> STRUCT <span class=s1>&#39;task_struct&#39;</span> <span class=nv>size</span><span class=o>=</span><span class=m>9472</span> <span class=nv>vlen</span><span class=o>=</span><span class=m>232</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>  <span class=s1>&#39;real_parent&#39;</span> <span class=nv>type_id</span><span class=o>=</span><span class=m>175</span> <span class=nv>bits_offset</span><span class=o>=</span><span class=m>18816</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;pid&#39;</span> <span class=nv>type_id</span><span class=o>=</span><span class=m>60</span> <span class=nv>bits_offset</span><span class=o>=</span><span class=m>18688</span>
</span></span></code></pre></div><p>通过查看代码，我发现主要由三个 Patch 来提供替换的编码信息：</p><ul><li><a href=https://reviews.llvm.org/rG048493f882faf19d80a1343d877d69cbb19c5091>[BPF] Preserve debuginfo array/union/struct type/access index</a></li><li><a href=https://lore.kernel.org/bpf/20190801064803.2519675-9-andriin@fb.com/t/>CO-RE offset relocations</a></li><li><a href=https://lore.kernel.org/bpf/20211124060209.493-1-alexei.starovoitov@gmail.com/>bpf: CO-RE support in the kernel</a></li></ul><p>其中 llvm 的 Patch 做到了在 BTF 中保留对内核数据结构的访问路径, 如下面的代码片段所示， 目前 libbpf 加载器一次的访问路径的最大深度为 9。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// https://github.com/cilium/ebpf/blob/v0.8.1/internal/btf/core.go#L435
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>sample</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>b</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>sample</span> <span class=n>s</span> <span class=o>=</span> <span class=p>...;</span>                                                                                         
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>a</span><span class=p>;</span>     <span class=c1>// encoded as &#34;0:0&#34; (a is field #0)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>b</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span>  <span class=c1>// encoded as &#34;0:1:0:5&#34; (anon struct is field #1,
</span></span></span><span class=line><span class=cl><span class=c1></span>                   <span class=c1>// b is field #0 inside anon struct, accessing elem #5)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>z</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>[</span><span class=mi>10</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>b</span><span class=p>;</span> <span class=c1>// encoded as &#34;10:1&#34; (ptr is used as an array)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// More info： https://llvm.org/docs/LangRef.html#getelementptr-instruction
</span></span></span></code></pre></div><p>而 <code>0:1:0:5</code> 这样的信息作为字符串保存在 <code>.BTF</code> section 中，而重写指令的偏移量则保存在 <code>.BTF.ext</code> 的 sub-section 中，具体的数据结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// https://www.kernel.org/doc/html/latest/bpf/btf.html
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>btf_ext_info_sec</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=n>__u32</span>   <span class=n>sec_name_off</span><span class=p>;</span> <span class=cm>/* offset to section name */</span>
</span></span><span class=line><span class=cl>   <span class=n>__u32</span>   <span class=n>num_info</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=cm>/* Followed by num_info * record_size number of bytes */</span>
</span></span><span class=line><span class=cl>   <span class=n>__u8</span>    <span class=n>data</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// https://github.com/libbpf/libbpf/blob/v0.7.0/include/uapi/linux/bpf.h#L6560
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>bpf_core_relo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>__u32</span> <span class=n>insn_off</span><span class=p>;</span>              <span class=c1>// 一开始是 section 偏移量，读出来一般都会修改成 [基于所在函数的偏移量]，
</span></span></span><span class=line><span class=cl><span class=c1></span>                               <span class=c1>// 方便后续不同 section 函数指令合并后的指令重写。
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>__u32</span> <span class=n>type_id</span><span class=p>;</span>               <span class=c1>// 以上面 struct sample，那么 type_id 为 struct sample 的 BTF ID                                            
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>__u32</span> <span class=n>access_str_off</span><span class=p>;</span>        <span class=c1>// 0:1:0:5 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>enum</span> <span class=n>bpf_core_relo_kind</span> <span class=n>kind</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// sub-section layout about bpf_core_relo
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>btf_ext_info_sec</span> <span class=k>for</span> <span class=n>section</span> <span class=err>#</span><span class=mi>1</span> <span class=cm>/* bpf_core_relo for section #1 */</span>
</span></span><span class=line><span class=cl><span class=n>btf_ext_info_sec</span> <span class=k>for</span> <span class=n>section</span> <span class=err>#</span><span class=mi>2</span> <span class=cm>/* bpf_core_relo for section #2 */</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><p>有了这样访问路径信息后，加载器会读出本地 BTF 信息按照访问路径进行相应的结构体匹配，当然这里是 [尽力去找最匹配的结果]，比如结构体的名字要一致，相应的结构体大小要一致等等。如果存在匹配结果，那么 <code>bpf_core_relo.insn_off</code> 对应的指令将会被修改； 否则，加载将会返回失败。</p><p>[一次编译，到处运行] 将 eBPF 使用体验都提升了好几个档次，想想看，OCI Artifacts 是不是可以 eBPF 程序作分发标准化呢？!</p><h4 id=23-call-insn-on-pc-relative>2.3 CALL INSN on pc-relative?<a hidden class=anchor aria-hidden=true href=#23-call-insn-on-pc-relative>#</a></h4><p>eBPF 是将每一个函数挂到相应的事件触发器上。一般来说，调用自定义的函数都会被 inlined 掉，即使代码段不在同一个 section 里。如下面的代码所示，这样程序是不需要重写指令的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># https://github.com/fuweid/demos/blob/master/ebpf/example-func-inline.bpf.c</span>
</span></span><span class=line><span class=cl>➜  llvm-objdump -dr ./.output/example-func-inline.bpf.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>./.output/example-func-inline.bpf.o:	file format elf64-bpf
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Disassembly of section .text:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=m>0000000000000000</span> &lt;double_ts_in_text&gt;:
</span></span><span class=line><span class=cl>       0:	bf <span class=m>10</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r0</span> <span class=o>=</span> r1
</span></span><span class=line><span class=cl>       1:	<span class=m>67</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>01</span> <span class=m>00</span> <span class=m>00</span> 00	r0 &lt;&lt;<span class=o>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>       2:	<span class=m>95</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nb>exit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Disassembly of section tp/sched/sched_process_exec:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 全部 inlined 到 handle_exec， 无需跳转</span>
</span></span><span class=line><span class=cl><span class=m>0000000000000000</span> &lt;handle_exec&gt;:
</span></span><span class=line><span class=cl>       0:	<span class=m>85</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>05</span> <span class=m>00</span> <span class=m>00</span> 00	call <span class=m>5</span>
</span></span><span class=line><span class=cl>       1:	<span class=m>67</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>01</span> <span class=m>00</span> <span class=m>00</span> 00	r0 &lt;&lt;<span class=o>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>       2:	<span class=m>95</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nb>exit</span>
</span></span></code></pre></div><p>如果 <code>double_ts</code> 函数不 inlined，那么编译后的结果如下。可以看到函数代码段在不同的 Section 中，加载器需要把所有相关的代码片段都 [追加] 到 <code>handle_exec</code> 的末尾，然后根据重定向的偏移量来修改指令。</p><p>需要注意的是，内核文档在描述 eBPF CALL 指令时并没有说 Immediate 是不是相对值。我是通过查看 libbpf 加载器中 <a href=https://github.com/libbpf/libbpf/blob/v0.7.0/include/uapi/linux/bpf.h#L1166>BPF_PSEUDO_CALL</a> 描述才知道这是一个相对值，偏移量的计算也是 <a href=https://www.kernel.org/doc/html/latest/bpf/llvm_reloc.html#different-relocation-types>约定值</a>。函数调用重写相比 MAP/Field Offset 重写要简单些，一般这部分的指令修改都是放到最后做。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># https://github.com/fuweid/demos/blob/master/ebpf/example-func-noinline.bpf.c</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>➜  llvm-objdump -dr ./.output/example-func-noinline.bpf.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>./.output/example-func-noinline.bpf.o:	file format elf64-bpf
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Disassembly of section .text:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=m>0000000000000000</span> &lt;double_ts&gt;:
</span></span><span class=line><span class=cl>       0:	bf <span class=m>10</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r0</span> <span class=o>=</span> r1
</span></span><span class=line><span class=cl>       1:	<span class=m>67</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>01</span> <span class=m>00</span> <span class=m>00</span> 00	r0 &lt;&lt;<span class=o>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>       2:	<span class=m>95</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nb>exit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Disassembly of section tp/sched/sched_process_exec:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=m>0000000000000000</span> &lt;handle_exec&gt;:
</span></span><span class=line><span class=cl>       0:	<span class=m>85</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>05</span> <span class=m>00</span> <span class=m>00</span> 00	call <span class=m>5</span>
</span></span><span class=line><span class=cl>       1:	bf <span class=m>01</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nv>r1</span> <span class=o>=</span> r0
</span></span><span class=line><span class=cl>       2:	<span class=m>85</span> <span class=m>10</span> <span class=m>00</span> <span class=m>00</span> ff ff ff ff	call -1
</span></span><span class=line><span class=cl>		0000000000000010:  R_BPF_64_32	.text
</span></span><span class=line><span class=cl>       3:	<span class=m>95</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> 00	<span class=nb>exit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 修改后的结果 dump from kernel</span>
</span></span><span class=line><span class=cl>int handle_exec<span class=o>(</span>struct trace_event_raw_sched_process_exec * ctx<span class=o>)</span>:
</span></span><span class=line><span class=cl><span class=p>;</span> <span class=nv>ts</span> <span class=o>=</span> bpf_ktime_get_ns<span class=o>()</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   0: <span class=o>(</span>85<span class=o>)</span> call bpf_ktime_get_ns#135136
</span></span><span class=line><span class=cl><span class=p>;</span> <span class=nv>ts</span> <span class=o>=</span> double_ts<span class=o>(</span>ts<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   1: <span class=o>(</span>bf<span class=o>)</span> <span class=nv>r1</span> <span class=o>=</span> r0
</span></span><span class=line><span class=cl>   2: <span class=o>(</span>85<span class=o>)</span> call pc+1#bpf_prog_6aadb6445c8badae_F
</span></span><span class=line><span class=cl><span class=p>;</span> <span class=k>return</span> ts<span class=p>;</span>
</span></span><span class=line><span class=cl>   3: <span class=o>(</span>95<span class=o>)</span> <span class=nb>exit</span>
</span></span><span class=line><span class=cl>u64 double_ts<span class=o>(</span>u64 ts<span class=o>)</span>:
</span></span><span class=line><span class=cl><span class=p>;</span> u64 double_ts<span class=o>(</span>u64 ts<span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>   4: <span class=o>(</span>bf<span class=o>)</span> <span class=nv>r0</span> <span class=o>=</span> r1
</span></span><span class=line><span class=cl><span class=p>;</span> <span class=k>return</span> ts + ts<span class=p>;</span>
</span></span><span class=line><span class=cl>   5: <span class=o>(</span>67<span class=o>)</span> r0 &lt;&lt;<span class=o>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=p>;</span> <span class=k>return</span> ts + ts<span class=p>;</span>
</span></span><span class=line><span class=cl>   6: <span class=o>(</span>95<span class=o>)</span> <span class=nb>exit</span>
</span></span></code></pre></div><h3 id=30-conclusion>3.0 Conclusion<a hidden class=anchor aria-hidden=true href=#30-conclusion>#</a></h3><p>本文只是简单介绍了 eBPF 加载器是怎么修改指令的，虽然还有很多细节没有提到，比如 <code>CALL bpf_ktime_get_ns</code> 指令是如何工作，以及 eBPF 尾调用如何拼接在一起等等，但大体的工作方式差不多，建议读一读 libbpf 加载器，或者 <a href=https://github.com/cilium/ebpf>cilium/ebpf go 代码</a>，还是比较有意思的。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://fuweid.com/post/2022-ebpf-portable-with-btfhub/><span class=title>« Prev</span><br><span>Towards truly portable eBPF</span></a>
<a class=next href=https://fuweid.com/post/2020-go-sync-mutex-insight/><span class=title>Next »</span><br><span>go sync.Mutex 源码阅读</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://fuweid.com/>fuweid</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>