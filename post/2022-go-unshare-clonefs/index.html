<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用 unshare(CLONE_FS) 来优化 OverlayFS 挂载 | fuweid</title><meta name=keywords content><meta name=description content="一次不错的尝试"><meta name=author content><link rel=canonical href=https://fuweid.com/post/2022-go-unshare-clonefs/><link crossorigin=anonymous href=/assets/css/stylesheet.abc7c82c3d415a6df50430738d1cbcc4c76fea558bc5a0c830d3babf78167a35.css integrity="sha256-q8fILD1BWm31BDBzjRy8xMdv6lWLxaDIMNO6v3gWejU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://fuweid.com/favicon.jpg><link rel=icon type=image/png sizes=16x16 href=https://fuweid.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fuweid.com/favicon-32x32.png><link rel=apple-touch-icon href=https://fuweid.com/apple-touch-icon.png><link rel=mask-icon href=https://fuweid.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','G-1C7VLVHN52','auto');ga('send','pageview');}</script><meta property="og:title" content="使用 unshare(CLONE_FS) 来优化 OverlayFS 挂载"><meta property="og:description" content="一次不错的尝试"><meta property="og:type" content="article"><meta property="og:url" content="https://fuweid.com/post/2022-go-unshare-clonefs/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-15T18:20:45+08:00"><meta property="article:modified_time" content="2022-10-15T18:20:45+08:00"><meta property="og:site_name" content="fuweid"><meta name=twitter:card content="summary"><meta name=twitter:title content="使用 unshare(CLONE_FS) 来优化 OverlayFS 挂载"><meta name=twitter:description content="一次不错的尝试"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fuweid.com/post/"},{"@type":"ListItem","position":2,"name":"使用 unshare(CLONE_FS) 来优化 OverlayFS 挂载","item":"https://fuweid.com/post/2022-go-unshare-clonefs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用 unshare(CLONE_FS) 来优化 OverlayFS 挂载","name":"使用 unshare(CLONE_FS) 来优化 OverlayFS 挂载","description":"一次不错的尝试","keywords":[],"articleBody":"背景 在 Linux 平台上，大部分情况下会使用 OverlayFS 文件系统来管理容器镜像存储，而 OverlayFS 文件的特点也比较符合容器场景使用：它不仅可以将多个目录合并成统一的访问视图，还能做到读写分离。\nmount -t overlay overlay \\  -olowerdir=/lower1:/lower2:/lower3,upperdir=/upper,workdir=/work \\  /merged 如上面的挂载命令所示， lowerdir 代表着容器镜像层解压后的目录。从 OCI Image 标准 定义来看，容器镜像的层数并没有限制。但 mount(2) 系统调用的参数被严格限制在 4KiB，所以实际使用的容器镜像层级有限制的。\n为了解决这个层级的问题，Docker 采用压缩 lowerdir 参数来尽可能地支持更多层级的容器镜像。Docker 存储插件使用 l/${random-id(len=26)} 软链接指向实际的存储目录，然后跳到 /var/lib/docker/overlay2 目录下进行挂载，这样就不需要在 lowerdir 参数里重复填写 /var/lib/docker/overlay2/ 这 25 个字符。按照 Docker 代码里的注释，Overlay 镜像存储最大可支持到 128 层。\n/var/lib/docker/overlay2/l/63WSQBTYICXV2O7SOZXAXYLAY2 - ../f98d68377b05c44bacc062397f7ebaaf066b070fce15fbcfe824698d15f2eaa8/diff 但在当时，Go 并没有提供太多的线程操作，所有被 Go-Runtime 管理的线程都使用了 CLONE_FS。一旦某个 Goroutine 通过 Chdir 修改了当前工作目录，这会污染到整个进程，Docker 无法基于这样的方式来并发处理 OverlayFS 挂载请求，所以在当时只能选择 Fork-Exec 子进程来处理。考虑到维护多个二进制的成本过高，Docker 采用了 Re-exec 的方式。\n不管怎么样，Fork-Exec 处理挂载成本很高，而且这样挂载逻辑没法独立成一个 Go Package，它要求使用者在 Go-Main-Init 函数里添加启动的预处理逻辑。所以在 containerd 项目里，我们采用了 Clone-Thread 的形式。\n这个 Patch 是 Derek 带着我做的，也算是我给 containerd 提交的第一个有意思的修改。当时我们模拟了 Go-Exec-Fork 进程的步骤来创建线程。但毕竟这个线程的状态并不能用于其他 Goroutine，所以我们会锁住这个线程，这个线程在处理完 Chdir 和 mount 之后就主动退出，避免对整个进程的影响。当然这种模拟 Go-Exec-Fork 进程的行为不只有我们这么做，gVisor 也这么玩 ：）\n//go:linkname beforeFork syscall.runtime_BeforeFork func beforeFork() //go:linkname afterFork syscall.runtime_AfterFork func afterFork() //go:linkname afterForkInChild syscall.runtime_AfterForkInChild func afterForkInChild() 模拟 Go-Exec-Fork 来管理线程在 containerd 平稳运行了近 5 年，但最近社区的 Brian Goff 和 Cory Snider 发现还有更好的处理方式。\nUnshare(CLONE_FS) https://man7.org/linux/man-pages/man2/unshare.2.html CLONE_FS Reverse the effect of the clone(2) CLONE_FS flag. Unshare filesystem attributes, so that the calling process no longer shares its root directory (chroot(2)), current directory (chdir(2)), or umask (umask(2)) attributes with any other process. 根据 unshare(2) 的文档来看，CLONE_FS 只提到了进程。但通过实践来看，它是可以作用在单个线程上。如下面的代码所示，syscall.Unshare(CLONE_FS) 之后修改当前工作目录并不会对其他线程造成影响。\n➜ /tmp cat main.go package main import ( \"fmt\" \"os\" \"runtime\" \"syscall\" ) func main() { ch := make(chan struct{}) go func() { runtime.LockOSThread() defer close(ch) syscall.Unshare(syscall.CLONE_FS) syscall.Chdir(\"/etc\") fmt.Println(os.Getwd()) }() (os.Getwd()) } ➜ /tmp go run main.go /etc  /tmp  unshare 提供了对 Go 管理线程改造的能力，再配合上 runtime.LockOSThread 锁线程的能力，基本上就可以 Go 来做一些更底层的操作了。理论上来说，Replace mount fork hack with CLONE_FS 是比前面模拟 Go-Fork-Exec 逻辑更优秀的解法。而且除此之外，unshare(CLONE_FS) 还支持 chroot, umask 等系统调用，这无疑是给容器相关的编程带来了很大便利。\n但目前这个优化并没有在 containerd 社区合并，原因是我们发现 Go-Runtime 自身的问题。\n后续跟进 首先，Go-Runtime 的 LockOSThread 文档没有提及 Main-Thread 的特殊性。在 Linux Kernel 里，Main Thread 其实就是我们平时提到的进程；当它被 LockOSThread 了但没有被 Unlock，按照官方文档说明，这个线程会主动退出。但实际上 Main-Thread 一旦推出，整个进程就变成僵尸状态，也就是退出了，所以 Go-Runtime 并不会退出这个线程，只是将其变成不可调度状态。\n其实，在 Github Action Pipeline 里，我们发现 Go-Runtime 自身处理锁的时候有问题，也不知道是不是和 Main-Thread 没有退出有关导致。比较麻烦的是，每次出现的错误都不一样。\nhttps://github.com/fuweid/containerd-pr-7513/actions/runs/3255360436/jobs/5345228547 runtime: newstack at runtime.checkdead+0x2f5 sp=0x7fb781e8ae38 stack=[0xc00004c800, 0xc00004d000] morebuf={pc:0x4745df sp:0x7fb781e8ae40 lr:0x0} sched={pc:0x47c975 sp:0x7fb781e8ae38 lr:0x0 ctxt:0x0} runtime.mexit(0x1) /opt/hostedtoolcache/go/1.19.2/x64/src/runtime/proc.go:1545 +0x17f fp=0x7fb781e8ae70 sp=0x7fb781e8ae40 pc=0x4[74](https://github.com/fuweid/containerd-pr-7513/actions/runs/3255360436/jobs/5345228547#step:5:75)5df runtime.mstart0() /opt/hostedtoolcache/go/1.19.2/x64/src/runtime/proc.go:1391 +0x89 fp=0x7fb781e8aea0 sp=0x7fb781e8ae70 pc=0x474289 runtime.mstart() /opt/hostedtoolcache/go/1.19.2/x64/src/runtime/asm_amd64.s:390 +0x5 fp=0x7fb781e8aea8 sp=0x7fb781e8aea0 pc=0x4a2725 created by github.com/fuweid/containerd-pr-[75](https://github.com/fuweid/containerd-pr-7513/actions/runs/3255360436/jobs/5345228547#step:5:76)13.mountAt /home/runner/work/containerd-pr-7513/containerd-pr-7513/mount.go:126 +0x2ac fatal error: runtime: stack split at bad time 具体问题描述都在 runtime: “runtime·lock: lock count” fatal error when cgo is enabled，感兴趣的朋友可以关注下这个问题。\n","wordCount":"316","inLanguage":"en","datePublished":"2022-10-15T18:20:45+08:00","dateModified":"2022-10-15T18:20:45+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://fuweid.com/post/2022-go-unshare-clonefs/"},"publisher":{"@type":"Organization","name":"fuweid","logo":{"@type":"ImageObject","url":"https://fuweid.com/favicon.jpg"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=https://fuweid.com/ accesskey=h title="fuweid.com (Alt + H)">fuweid.com</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fuweid.com/>Home</a>&nbsp;»&nbsp;<a href=https://fuweid.com/post/>Posts</a></div><h1 class=post-title>使用 unshare(CLONE_FS) 来优化 OverlayFS 挂载</h1><div class=post-description>一次不错的尝试</div><div class=post-meta><span title="2022-10-15 18:20:45 +0800 HKT">October 15, 2022</span></div></header><div class=post-content><h3 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h3><p>在 Linux 平台上，大部分情况下会使用 <a href=https://docs.kernel.org/filesystems/overlayfs.html>OverlayFS</a> 文件系统来管理容器镜像存储，而 OverlayFS 文件的特点也比较符合容器场景使用：它不仅可以将多个目录合并成统一的访问视图，还能做到读写分离。</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>mount -t overlay overlay <span class=se>\
</span><span class=se></span>  -olowerdir<span class=o>=</span>/lower1:/lower2:/lower3,upperdir<span class=o>=</span>/upper,workdir<span class=o>=</span>/work <span class=se>\
</span><span class=se></span>  /merged
</code></pre></div><p>如上面的挂载命令所示， lowerdir 代表着容器镜像层解压后的目录。从 OCI Image 标准 定义来看，容器镜像的层数并没有限制。但 <a href=https://man7.org/linux/man-pages/man2/mount.2.html>mount(2)</a> 系统调用的参数被严格限制在 4KiB，所以实际使用的容器镜像层级有限制的。</p><p>为了解决这个层级的问题，Docker 采用压缩 lowerdir 参数来尽可能地支持更多层级的容器镜像。Docker 存储插件使用 <code>l/${random-id(len=26)}</code> 软链接指向实际的存储目录，然后跳到 <code>/var/lib/docker/overlay2</code> 目录下进行挂载，这样就不需要在 lowerdir 参数里重复填写 <code>/var/lib/docker/overlay2/</code> 这 25 个字符。按照 Docker 代码里的注释，Overlay 镜像存储最大可支持到 128 层。</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>/var/lib/docker/overlay2/l/63WSQBTYICXV2O7SOZXAXYLAY2 
  -&gt; ../f98d68377b05c44bacc062397f7ebaaf066b070fce15fbcfe824698d15f2eaa8/diff
</code></pre></div><p>但在当时，Go 并没有提供太多的线程操作，所有被 Go-Runtime 管理的线程都使用了 <a href=https://man7.org/linux/man-pages/man2/clone.2.html>CLONE_FS</a>。一旦某个 Goroutine 通过 Chdir 修改了当前工作目录，这会污染到整个进程，Docker 无法基于这样的方式来并发处理 OverlayFS 挂载请求，所以在当时只能选择 Fork-Exec 子进程来处理。考虑到维护多个二进制的成本过高，Docker 采用了 Re-exec 的方式。</p><p>不管怎么样，Fork-Exec 处理挂载成本很高，而且这样挂载逻辑没法独立成一个 Go Package，它要求使用者在 Go-Main-Init 函数里添加启动的预处理逻辑。所以在 containerd 项目里，我们采用了 Clone-Thread 的形式。</p><p>这个 Patch 是 Derek 带着我做的，也算是我给 containerd 提交的第一个有意思的修改。当时我们模拟了 Go-Exec-Fork 进程的步骤来创建线程。但毕竟这个线程的状态并不能用于其他 Goroutine，所以我们会锁住这个线程，这个线程在处理完 Chdir 和 mount 之后就主动退出，避免对整个进程的影响。当然这种模拟 Go-Exec-Fork 进程的行为不只有我们这么做，gVisor 也这么玩 ：）</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=c1>//go:linkname beforeFork syscall.runtime_BeforeFork
</span><span class=c1></span><span class=kd>func</span> <span class=nf>beforeFork</span><span class=p>()</span>

<span class=c1>//go:linkname afterFork syscall.runtime_AfterFork
</span><span class=c1></span><span class=kd>func</span> <span class=nf>afterFork</span><span class=p>()</span>

<span class=c1>//go:linkname afterForkInChild syscall.runtime_AfterForkInChild
</span><span class=c1></span><span class=kd>func</span> <span class=nf>afterForkInChild</span><span class=p>()</span>
</code></pre></div><p>模拟 Go-Exec-Fork 来管理线程在 containerd 平稳运行了近 5 年，但最近社区的 Brian Goff 和 Cory Snider 发现还有更好的处理方式。</p><h3 id=unshareclone_fs>Unshare(CLONE_FS)<a hidden class=anchor aria-hidden=true href=#unshareclone_fs>#</a></h3><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>https://man7.org/linux/man-pages/man2/unshare.2.html

CLONE_FS
              Reverse the effect of the clone(2) CLONE_FS flag.  Unshare
              filesystem attributes, so that the calling process no
              longer shares its root directory (chroot(2)), current
              directory (chdir(2)), or umask (umask(2)) attributes with
              any other process.
</code></pre></div><p>根据 <a href=https://man7.org/linux/man-pages/man2/unshare.2.html>unshare(2)</a> 的文档来看，CLONE_FS 只提到了进程。但通过实践来看，它是可以作用在单个线程上。如下面的代码所示，syscall.Unshare(CLONE_FS) 之后修改当前工作目录并不会对其他线程造成影响。</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>➜  /tmp cat main.go
package main

import <span class=o>(</span>
        <span class=s2>&#34;fmt&#34;</span>
        <span class=s2>&#34;os&#34;</span>
        <span class=s2>&#34;runtime&#34;</span>
        <span class=s2>&#34;syscall&#34;</span>
<span class=o>)</span>

func main<span class=o>()</span> <span class=o>{</span>
        ch :<span class=o>=</span> make<span class=o>(</span>chan struct<span class=o>{})</span>
        go func<span class=o>()</span> <span class=o>{</span>
                runtime.LockOSThread<span class=o>()</span>
                defer close<span class=o>(</span>ch<span class=o>)</span>

                syscall.Unshare<span class=o>(</span>syscall.CLONE_FS<span class=o>)</span>
                syscall.Chdir<span class=o>(</span><span class=s2>&#34;/etc&#34;</span><span class=o>)</span>

                fmt.Println<span class=o>(</span>os.Getwd<span class=o>())</span>
        <span class=o>}()</span>
        &lt;-ch
        fmt.Println<span class=o>(</span>os.Getwd<span class=o>())</span>
<span class=o>}</span>

➜  /tmp go run main.go
/etc &lt;nil&gt;
/tmp &lt;nil&gt;
</code></pre></div><p>unshare 提供了对 Go 管理线程改造的能力，再配合上 <code>runtime.LockOSThread</code> 锁线程的能力，基本上就可以 Go 来做一些更底层的操作了。理论上来说，<a href=https://github.com/containerd/containerd/pull/7513>Replace mount fork hack with CLONE_FS</a> 是比前面模拟 Go-Fork-Exec 逻辑更优秀的解法。而且除此之外，unshare(CLONE_FS) 还支持 chroot, umask 等系统调用，这无疑是给容器相关的编程带来了很大便利。</p><p>但目前这个优化并没有在 containerd 社区合并，原因是我们发现 Go-Runtime 自身的问题。</p><h3 id=后续跟进>后续跟进<a hidden class=anchor aria-hidden=true href=#后续跟进>#</a></h3><p>首先，Go-Runtime 的 LockOSThread 文档没有提及 Main-Thread 的特殊性。在 Linux Kernel 里，Main Thread 其实就是我们平时提到的进程；当它被 LockOSThread 了但没有被 Unlock，按照官方文档说明，这个线程会主动退出。但实际上 Main-Thread 一旦推出，整个进程就变成僵尸状态，也就是退出了，所以 Go-Runtime 并不会退出这个线程，只是将其变成不可调度状态。</p><p>其实，在 Github Action Pipeline 里，我们发现 Go-Runtime 自身处理锁的时候有问题，也不知道是不是和 Main-Thread 没有退出有关导致。比较麻烦的是，每次出现的错误都不一样。</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>https://github.com/fuweid/containerd-pr-7513/actions/runs/3255360436/jobs/5345228547

runtime: newstack at runtime.checkdead+0x2f5 <span class=nv>sp</span><span class=o>=</span>0x7fb781e8ae38 <span class=nv>stack</span><span class=o>=[</span>0xc00004c800, 0xc00004d000<span class=o>]</span>
	<span class=nv>morebuf</span><span class=o>={</span>pc:0x4745df sp:0x7fb781e8ae40 lr:0x0<span class=o>}</span>
	<span class=nv>sched</span><span class=o>={</span>pc:0x47c975 sp:0x7fb781e8ae38 lr:0x0 ctxt:0x0<span class=o>}</span>
runtime.mexit<span class=o>(</span>0x1<span class=o>)</span>
	/opt/hostedtoolcache/go/1.19.2/x64/src/runtime/proc.go:1545 +0x17f <span class=nv>fp</span><span class=o>=</span>0x7fb781e8ae70 <span class=nv>sp</span><span class=o>=</span>0x7fb781e8ae40 <span class=nv>pc</span><span class=o>=</span>0x4<span class=o>[</span>74<span class=o>](</span>https://github.com/fuweid/containerd-pr-7513/actions/runs/3255360436/jobs/5345228547#step:5:75<span class=o>)</span>5df
runtime.mstart0<span class=o>()</span>
	/opt/hostedtoolcache/go/1.19.2/x64/src/runtime/proc.go:1391 +0x89 <span class=nv>fp</span><span class=o>=</span>0x7fb781e8aea0 <span class=nv>sp</span><span class=o>=</span>0x7fb781e8ae70 <span class=nv>pc</span><span class=o>=</span>0x474289
runtime.mstart<span class=o>()</span>
	/opt/hostedtoolcache/go/1.19.2/x64/src/runtime/asm_amd64.s:390 +0x5 <span class=nv>fp</span><span class=o>=</span>0x7fb781e8aea8 <span class=nv>sp</span><span class=o>=</span>0x7fb781e8aea0 <span class=nv>pc</span><span class=o>=</span>0x4a2725
created by github.com/fuweid/containerd-pr-<span class=o>[</span>75<span class=o>](</span>https://github.com/fuweid/containerd-pr-7513/actions/runs/3255360436/jobs/5345228547#step:5:76<span class=o>)</span>13.mountAt
	/home/runner/work/containerd-pr-7513/containerd-pr-7513/mount.go:126 +0x2ac
fatal error: runtime: stack split at bad <span class=nb>time</span>
</code></pre></div><p>具体问题描述都在 <a href=https://github.com/golang/go/issues/56243>runtime: &ldquo;runtime·lock: lock count&rdquo; fatal error when cgo is enabled</a>，感兴趣的朋友可以关注下这个问题。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://fuweid.com/post/2023-containerd-17-userns/><span class=title>« Prev</span><br><span>containerd 1.7: UserNamespace Stateless Pod</span></a>
<a class=next href=https://fuweid.com/post/2022-bpf-kprobe-fentry-poke/><span class=title>Next »</span><br><span>eBPF 动态观测之指令跳板</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://fuweid.com/>fuweid</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerHTML='copy';function copyingDone(){copybutton.innerHTML='copied!';setTimeout(()=>{copybutton.innerHTML='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>