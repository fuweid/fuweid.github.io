<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>go sync.Mutex 源码阅读 | fuweid</title>
<meta name=keywords content><meta name=description content="基于 go1.14.4 源码分析 sync.Mutex "><meta name=author content><link rel=canonical href=https://fuweid.com/post/2020-go-sync-mutex-insight/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://fuweid.com/favicon.jpg><link rel=icon type=image/png sizes=16x16 href=https://fuweid.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fuweid.com/favicon-32x32.png><link rel=apple-touch-icon href=https://fuweid.com/apple-touch-icon.png><link rel=mask-icon href=https://fuweid.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://fuweid.com/post/2020-go-sync-mutex-insight/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-1C7VLVHN52"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1C7VLVHN52",{anonymize_ip:!1})}</script><meta property="og:title" content="go sync.Mutex 源码阅读"><meta property="og:description" content="基于 go1.14.4 源码分析 sync.Mutex "><meta property="og:type" content="article"><meta property="og:url" content="https://fuweid.com/post/2020-go-sync-mutex-insight/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-06-21T18:00:53+08:00"><meta property="article:modified_time" content="2020-06-21T18:00:53+08:00"><meta property="og:site_name" content="fuweid"><meta name=twitter:card content="summary"><meta name=twitter:title content="go sync.Mutex 源码阅读"><meta name=twitter:description content="基于 go1.14.4 源码分析 sync.Mutex "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fuweid.com/post/"},{"@type":"ListItem","position":2,"name":"go sync.Mutex 源码阅读","item":"https://fuweid.com/post/2020-go-sync-mutex-insight/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"go sync.Mutex 源码阅读","name":"go sync.Mutex 源码阅读","description":"基于 go1.14.4 源码分析 sync.Mutex ","keywords":[],"articleBody":"Linux Kernel 提供 Semaphore/Mutex 来实现线程间的同步机制，可保证在同一个时间段 只有少量的线程可以访问同一块资源（也称为进入临界区域）。 线程之间要通过竞争来获得访问权限，一旦竞争失败，线程会进入到阻塞状态； 而阻塞的线程只能等待离开临界区域被内核唤醒。\ngo runtime 提供的 sync.Mutex 并不是采用内核级别的同步机制。 作为执行单元的线程一旦阻塞，意味该线程将不再受到 go runtime 控制， go runtime 需要创建新的线程来执行其他 runnable goroutine ， 线程的数目会和竞争资源的请求成正比，容易造成资源浪费。 而 go 优势是 goroutine 轻量级调度，因此 sync.Mutex 选择在用户态来实现同步机制。\n和线程阻塞类似，在无法进入临界区的情况下，goroutine 会主动释放当前的 执行单元 - 线程，进入到阻塞状态；在 sync.Mutex 持有者离开临界区之前， 阻塞状态的 goroutine 将不会出现在调度队列里。 这样被释放的线程会去执行其他 runnable goroutine，提升线程的利用率。\nsync.Mutex 结构设计分析 Mutex 也被称之为锁。\n// sync/mutex.go // A Mutex is a mutual exclusion lock. // The zero value for a Mutex is an unlocked mutex. // // A Mutex must not be copied after first use. type Mutex struct { state int32 sema uint32 } 每一个 Mutex 实例都有虚拟全局唯一的地址，go runtime 通过 Mutex.sema 地址来维护 阻塞的 goroutine 队列。当 goroutine 无法获得锁的情况下，goroutine 主动调用 runtime_Semacquire ，将自己加入锁对应的阻塞队列中；而锁的持有者在释放锁之后， 根据当前阻塞情况来调用 runtime_Semrelease 方法，唤醒阻塞队列头部的 goroutine 。\n// runtime/sema.go //go:linkname sync_runtime_Semrelease sync.runtime_Semrelease func sync_runtime_Semrelease(addr *uint32, handoff bool, skipframes int) { semrelease1(addr, handoff, skipframes) } //go:linkname sync_runtime_SemacquireMutex sync.runtime_SemacquireMutex func sync_runtime_SemacquireMutex(addr *uint32, lifo bool, skipframes int) { semacquire1(addr, lifo, semaBlockProfile|semaMutexProfile, skipframes) } 而 Mutex 更多的细节是在 state 字段上。Mutex.state 将 32 bit 划分成四块区域。\n高位 3-31 bits 表示当前进入阻塞状态的 goroutine 数目，它直接反应出调用 runtime_SemacquireMutex 的次数。runtime_SemacquireMutex 采用单链表管理队列。 正常情况下，阻塞的 goroutine 是通过尾插法的方式加入队列；释放锁的时候会唤醒队列 头部的 goroutine，即先入先出，保证了公平特性。\n被唤醒的 goroutine 会和新来的 goroutine 竞争加锁， 被唤醒的 goroutine 可能会因拿不到锁而重新回到阻塞队列。 在处理并发请求时，最先发起的请求会因为竞争关系可能一直拿不到锁， 导致个别请求耗时非常长；并发请求越多，这样的问题就越严重。\n为了保证公平性，Mutex 引入了 Starving 模式。经历了长时间阻塞，如果被唤醒的 goroutine 还是拿不到锁，它就主动加上 Starving 标志位，该标志位用来告诉新来的 goroutine 要照顾下「阻塞了长时间-刚被唤醒-还拿不到锁的同志」: 不要加锁啦， 直接把自己加入到阻塞队列里吧。这样新到达的 goroutine 会被加入到阻塞队列的尾部， 之前就在阻塞队列里的 goroutine 就可以优先被唤醒了，降低长尾带来的问题。\n那些被唤醒的 goroutine 再次回到阻塞队列时，它们不再重新排队，通过设置 Last In, First Out(LIFO) 来强行插队，保证它是下一个被唤醒的 goroutine。\n除了保护公平性之外，Starving 模式还减少了 goroutine 之间的竞争关系。 因为运气不好的情况下，新来的 goroutine 会一直拿到锁，导致唤醒的动作白费了， 系统线程还不如执行其他 runnable goroutine。\nWoken 比特位是用来告知持有锁的调用者：现在有一个活跃状态 goroutine 在尝试拿锁， 如果不是处于 Starving 状态，请不要在释放锁的时候做唤醒，尽量让这个活跃的 goroutine 去竞争拿锁，减少不必要的唤醒竞争。\n以上是 sync.Mutex 设计介绍，下面我们通过查看代码注释来了解细节。\nUnlock 逻辑 // sync/mutex.go // Unlock unlocks m. func (m *Mutex) Unlock() { if race.Enabled { _ = m.state race.Release(unsafe.Pointer(m)) } // Fast path: drop lock bit. // 通过减一来完成解锁。如果 m.state 没有其他标记位，那么解锁结束。 // 否则将进入到 slow path，判断是否要唤醒其他阻塞的 goroutine。 new := atomic.AddInt32(\u0026m.state, -mutexLocked) if new != 0 { m.unlockSlow(new) } } func (m *Mutex) unlockSlow(new int32) { // 为了防止出现 Unlock 非锁定状态的 Mutex，需要检查下 mutexLocked 标记位。 if (new+mutexLocked)\u0026mutexLocked == 0 { throw(\"sync: unlock of unlocked mutex\") } // 正常模式，还未出现 Starving if new\u0026mutexStarving == 0 { old := new for { // 这里有两大类场景，出现了直接结束掉 slow path: // // 没有阻塞状态的 goroutine (old \u003e\u003e mutexWaiterShift == 0) // // 还存在阻塞状态的 goroutine(s) // // 1. 当前有活跃状态的 goroutine (old\u0026mutexWoken != 0) // 选择让当前活跃状态的 goroutine 去竞争锁，减少不必要的唤醒 // // 2. 当前锁已经被其他 goroutine 获取了 (old\u0026mutexLocked != 0) // 需要等待释放锁的时候再做唤醒，应直接退出， // 交给下一次 Unlock 调用在处理。 // // 3. 当前是一个 Starving 状态 (old\u0026(mutexStarving) != 0) // 进入循环前是「非 Starving」状态，而现在确是 Starving 模式。 // 说明这段时间里出现了 (Lock/Unlock)../Lock 连续调用， // 导致「被其他 Unlock 调用唤醒的 goroutine」 拿不到锁， // 进入到 Starving 模式。 // 这种情况下应该直接退出，交给下一次 Unlock 调用在处理了。 if old\u003e\u003emutexWaiterShift == 0 || old\u0026(mutexLocked|mutexWoken|mutexStarving) != 0 { return } // 这个时候 mutexLocked|Starving|Woken 标记位为空，尝试将阻塞数目减一。 // // 只要 CAS 原子操作成功，就可以唤醒阻塞队列头部的 goroutine。 new = (old - 1\u003c\u003cmutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { runtime_Semrelease(\u0026m.sema, false, 1) return } old = m.state } } else { // 因为出现 Starving 状态，说明阻塞时间足够长了，Unlock 调用者会将 // runtime_Semrelease 函数第二个参数设置成 true，表示会主动释放 // 当前执行线程，而当前执行线程会直接执行阻塞队列头部的 goroutine。 // 被唤醒的 goroutine 相当于获得锁的状态了，因为在 Starving 状态下， // 新到达的 goroutine 不会竞争锁，它们会直接进入阻塞队列。 runtime_Semrelease(\u0026m.sema, true, 1) } } Lock 细节 如果一开始 Mutex.state 是一个空值状态，那么 CAS 更新 mutexLocked 标志位会直接成功，相当于上锁了。 那么其他 goroutine 想要上锁就要走 slow path 了。\n// sync/mutex.go // Lock locks m. // If the lock is already in use, the calling goroutine // blocks until the mutex is available. func (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026m.state, 0, mutexLocked) { if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return } // Slow path (outlined so that the fast path can be inlined) m.lockSlow() } 这里代码细节比较多，我们直接查看中文注释~\n// sync/mutex.go func (m *Mutex) lockSlow() { var waitStartTime int64 // 所有刚进入 slow path 的 goroutine 都会以正常模式运行 // 只有出现阻塞了超过 1ms 的情况，才会将 starving = true starving := false awoke := false iter := 0 old := m.state for { // 正常模式下（非 Starving） 的时候，新到达的 goroutine 会尝试 // 空转 4 次左右。如果还是 Locked 状态 或者 出现了 Starving 状态， // goroutine 会尝试释放执行单元，进入阻塞状态。 if old\u0026(mutexLocked|mutexStarving) == mutexLocked \u0026\u0026 runtime_canSpin(iter) { // 如果阻塞队列非空，那么应该尝试设置上 Woken 状态。 // 用来通知 Unlock 不要做唤醒动作，让当前的 goroutine 去竞争锁。 if !awoke \u0026\u0026 old\u0026mutexWoken == 0 \u0026\u0026 old\u003e\u003emutexWaiterShift != 0 \u0026\u0026 atomic.CompareAndSwapInt32(\u0026m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() iter++ old = m.state continue } new := old // 如果已经处于 Starving 状态了，那么新到达的 goroutine 就不要 // 去竞争锁了。 if old\u0026mutexStarving == 0 { new |= mutexLocked } // 如果当前(已经上锁|处于 Starving) 状态，那么(新到达|被唤醒) // goroutine 应该变成阻塞状态。 if old\u0026(mutexLocked|mutexStarving) != 0 { new += 1 \u003c\u003c mutexWaiterShift } //「长时间阻塞 - 被唤醒了还拿不到锁」goroutine 会设置上 Starving。 // 希望在释放锁的时候，优先唤醒自己。 if starving \u0026\u0026 old\u0026mutexLocked != 0 { new |= mutexStarving } // 如果是当前 goroutine 设置上了 woken 状态，那么在尝试获得锁的时候， // 应该去掉该标记位。 if awoke { if new\u0026mutexWoken == 0 { throw(\"sync: inconsistent mutex state\") } new \u0026^= mutexWoken } if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { // 1. old\u0026(mutexLocked|mutexStarving) = 10B // 锁已经释放，但正在唤醒「设置 Starving」 goroutine， // 当前 goroutine 拿不到锁； // // 2. old\u0026(mutexLocked|mutexStarving) = 01B // 锁还没被释放，当前 goroutine 拿不到锁； // // 3. old\u0026(mutexLocked|mutexStarving) = 11B // 被唤醒的 goroutine 刚更新成 Starving 状态， // 当前 goroutine 拿不到锁； // // 4. old\u0026(mutexLocked|mutexStarving) = 0 // 正好遇到释放锁，运气不错，new 值拿到锁，退出。 if old\u0026(mutexLocked|mutexStarving) == 0 { break // locked the mutex with CAS } queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } // 「被唤醒过 - 但竞争失败」的 goroutine 都采用 LIFO // 头插法入队，即插队。 // // runtime_SemacuireMutex 将当前 goroutine 设置成阻塞态 runtime_SemacquireMutex(\u0026m.sema, queueLifo, 1) // 被唤醒之后继续执行 starving = starving || runtime_nanotime()-waitStartTime \u003e starvationThresholdNs old = m.state // old\u0026mutexStarving != 0 说明当前 goroutine 已经拿到锁。 // 但这个时候 Mutex.state 相应标记位还没更新。 if old\u0026mutexStarving != 0 { // 在 Starving 状态下，Unlock 只负责唤醒，并不 // 会更新 Mutex.state 状态。如果状态被修改成 // mutexLocked，导致不一致，应该 panic。 if old\u0026(mutexLocked|mutexWoken) != 0 || old\u003e\u003emutexWaiterShift == 0 { throw(\"sync: inconsistent mutex state\") } // 更新 mutexLocked 以及对阻塞数目减一。 delta := int32(mutexLocked - 1\u003c\u003cmutexWaiterShift) // 如果 Starving 状态不清理，那么每次 Unlock // 都会直接唤醒阻塞队列里的。 // // 毕竟 Starving 会让新到达的 goroutine 直接放 // 弃竞争，解决某些「阻塞太久 goroutine」 // 获得锁的问题，但也浪费了新到达的 goroutine // 的执行时间。 // // 如果发现阻塞队列里的 goroutine 并没有达到 // Starving 设置阈值，那么 应该清理掉 Starving // 标记位。 if !starving || old\u003e\u003emutexWaiterShift == 1 { delta -= mutexStarving } atomic.AddInt32(\u0026m.state, delta) break } // 属于正常唤醒，Unlock 已经帮忙设置上 mutexWoken 标记 // 和 对阻塞数目减一。 awoke = true iter = 0 } else { old = m.state } } if race.Enabled { race.Acquire(unsafe.Pointer(m)) } } 小结 sync.Mutex 整体代码量不多，其中很多细节都被 runtime.sync_runtime_SemacquireMutex 和 runtime.sync_runtime_Semrelease 函数屏蔽了，后面有时间会更新这部分的代码分析。\n","wordCount":"959","inLanguage":"en","datePublished":"2020-06-21T18:00:53+08:00","dateModified":"2020-06-21T18:00:53+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://fuweid.com/post/2020-go-sync-mutex-insight/"},"publisher":{"@type":"Organization","name":"fuweid","logo":{"@type":"ImageObject","url":"https://fuweid.com/favicon.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fuweid.com/ accesskey=h title="fuweid.com (Alt + H)">fuweid.com</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fuweid.com/>Home</a>&nbsp;»&nbsp;<a href=https://fuweid.com/post/>Posts</a></div><h1 class=post-title>go sync.Mutex 源码阅读</h1><div class=post-description>基于 go1.14.4 源码分析 sync.Mutex</div><div class=post-meta>&lt;span title='2020-06-21 18:00:53 +0800 HKT'>June 21, 2020&lt;/span></div></header><div class=post-content><p>Linux Kernel 提供 Semaphore/Mutex 来实现线程间的同步机制，可保证在同一个时间段
只有少量的线程可以访问同一块资源（也称为进入临界区域）。
线程之间要通过竞争来获得访问权限，一旦竞争失败，线程会进入到阻塞状态；
而阻塞的线程只能等待离开临界区域被内核唤醒。</p><p>go runtime 提供的 sync.Mutex 并不是采用内核级别的同步机制。
作为执行单元的线程一旦阻塞，意味该线程将不再受到 go runtime 控制，
go runtime 需要创建新的线程来执行其他 runnable goroutine ，
线程的数目会和竞争资源的请求成正比，容易造成资源浪费。
而 go 优势是 goroutine 轻量级调度，因此 sync.Mutex 选择在用户态来实现同步机制。</p><p>和线程阻塞类似，在无法进入临界区的情况下，goroutine 会主动释放当前的
执行单元 - 线程，进入到阻塞状态；在 sync.Mutex 持有者离开临界区之前，
阻塞状态的 goroutine 将不会出现在调度队列里。
这样被释放的线程会去执行其他 runnable goroutine，提升线程的利用率。</p><h3 id=syncmutex-结构设计分析>sync.Mutex 结构设计分析<a hidden class=anchor aria-hidden=true href=#syncmutex-结构设计分析>#</a></h3><p>Mutex 也被称之为锁。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// sync/mutex.go
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// A Mutex is a mutual exclusion lock.
</span></span></span><span class=line><span class=cl><span class=c1>// The zero value for a Mutex is an unlocked mutex.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// A Mutex must not be copied after first use.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Mutex</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>state</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl>        <span class=nx>sema</span>  <span class=kt>uint32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>每一个 Mutex 实例都有虚拟全局唯一的地址，go runtime 通过 Mutex.sema 地址来维护
阻塞的 goroutine 队列。当 goroutine 无法获得锁的情况下，goroutine 主动调用
runtime_Semacquire ，将自己加入锁对应的阻塞队列中；而锁的持有者在释放锁之后，
根据当前阻塞情况来调用 runtime_Semrelease 方法，唤醒阻塞队列头部的 goroutine 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=o>//</span> <span class=n>runtime</span><span class=o>/</span><span class=n>sema</span><span class=o>.</span><span class=n>go</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>//</span><span class=n>go</span><span class=p>:</span><span class=n>linkname</span> <span class=n>sync_runtime_Semrelease</span> <span class=n>sync</span><span class=o>.</span><span class=n>runtime_Semrelease</span>
</span></span><span class=line><span class=cl><span class=k>func</span> <span class=n>sync_runtime_Semrelease</span><span class=p>(</span><span class=n>addr</span> <span class=o>*</span><span class=n>uint32</span><span class=p>,</span> <span class=n>handoff</span> <span class=ne>bool</span><span class=p>,</span> <span class=n>skipframes</span> <span class=ne>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>semrelease1</span><span class=p>(</span><span class=n>addr</span><span class=p>,</span> <span class=n>handoff</span><span class=p>,</span> <span class=n>skipframes</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>//</span><span class=n>go</span><span class=p>:</span><span class=n>linkname</span> <span class=n>sync_runtime_SemacquireMutex</span> <span class=n>sync</span><span class=o>.</span><span class=n>runtime_SemacquireMutex</span>
</span></span><span class=line><span class=cl><span class=k>func</span> <span class=n>sync_runtime_SemacquireMutex</span><span class=p>(</span><span class=n>addr</span> <span class=o>*</span><span class=n>uint32</span><span class=p>,</span> <span class=n>lifo</span> <span class=ne>bool</span><span class=p>,</span> <span class=n>skipframes</span> <span class=ne>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>semacquire1</span><span class=p>(</span><span class=n>addr</span><span class=p>,</span> <span class=n>lifo</span><span class=p>,</span> <span class=n>semaBlockProfile</span><span class=o>|</span><span class=n>semaMutexProfile</span><span class=p>,</span> <span class=n>skipframes</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>而 Mutex 更多的细节是在 state 字段上。Mutex.state 将 32 bit 划分成四块区域。</p><p><img loading=lazy src=/img/2020-go-sync-mutex-insight/mutex-state.png alt=mutex-state></p><p>高位 3-31 bits 表示当前进入阻塞状态的 goroutine 数目，它直接反应出调用
runtime_SemacquireMutex 的次数。runtime_SemacquireMutex 采用单链表管理队列。
正常情况下，阻塞的 goroutine 是通过尾插法的方式加入队列；释放锁的时候会唤醒队列
头部的 goroutine，即先入先出，保证了公平特性。</p><p>被唤醒的 goroutine 会和新来的 goroutine 竞争加锁，
被唤醒的 goroutine 可能会因拿不到锁而重新回到阻塞队列。
在处理并发请求时，最先发起的请求会因为竞争关系可能一直拿不到锁，
导致个别请求耗时非常长；并发请求越多，这样的问题就越严重。</p><p>为了保证公平性，Mutex 引入了 Starving 模式。经历了长时间阻塞，如果被唤醒的
goroutine 还是拿不到锁，它就主动加上 Starving 标志位，该标志位用来告诉新来的
goroutine 要照顾下「阻塞了长时间-刚被唤醒-还拿不到锁的同志」: <strong>不要加锁啦，
直接把自己加入到阻塞队列里吧</strong>。这样新到达的 goroutine 会被加入到阻塞队列的尾部，
之前就在阻塞队列里的 goroutine 就可以优先被唤醒了，降低长尾带来的问题。</p><p>那些被唤醒的 goroutine 再次回到阻塞队列时，它们不再重新排队，通过设置
Last In, First Out(LIFO) 来强行插队，保证它是下一个被唤醒的 goroutine。</p><p>除了保护公平性之外，Starving 模式还减少了 goroutine 之间的竞争关系。
因为运气不好的情况下，新来的 goroutine 会一直拿到锁，导致唤醒的动作白费了，
系统线程还不如执行其他 runnable goroutine。</p><p>Woken 比特位是用来告知持有锁的调用者：现在有一个活跃状态 goroutine 在尝试拿锁，
如果不是处于 Starving 状态，请不要在释放锁的时候做唤醒，尽量让这个活跃的
goroutine 去竞争拿锁，减少不必要的唤醒竞争。</p><p>以上是 sync.Mutex 设计介绍，下面我们通过查看代码注释来了解细节。</p><h3 id=unlock-逻辑>Unlock 逻辑<a hidden class=anchor aria-hidden=true href=#unlock-逻辑>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// sync/mutex.go
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Unlock unlocks m.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Mutex</span><span class=p>)</span> <span class=nf>Unlock</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>race</span><span class=p>.</span><span class=nx>Enabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>_</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>state</span>
</span></span><span class=line><span class=cl>                <span class=nx>race</span><span class=p>.</span><span class=nf>Release</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>m</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Fast path: drop lock bit.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 通过减一来完成解锁。如果 m.state 没有其他标记位，那么解锁结束。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 否则将进入到 slow path，判断是否要唤醒其他阻塞的 goroutine。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>new</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=o>-</span><span class=nx>mutexLocked</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>new</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>m</span><span class=p>.</span><span class=nf>unlockSlow</span><span class=p>(</span><span class=nx>new</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Mutex</span><span class=p>)</span> <span class=nf>unlockSlow</span><span class=p>(</span><span class=nx>new</span> <span class=kt>int32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 为了防止出现 Unlock 非锁定状态的 Mutex，需要检查下 mutexLocked 标记位。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=nx>new</span><span class=o>+</span><span class=nx>mutexLocked</span><span class=p>)</span><span class=o>&amp;</span><span class=nx>mutexLocked</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;sync: unlock of unlocked mutex&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 正常模式，还未出现 Starving
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>new</span><span class=o>&amp;</span><span class=nx>mutexStarving</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>old</span> <span class=o>:=</span> <span class=nx>new</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 这里有两大类场景，出现了直接结束掉 slow path:
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 没有阻塞状态的 goroutine (old &gt;&gt; mutexWaiterShift == 0)
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 还存在阻塞状态的 goroutine(s)
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 1. 当前有活跃状态的 goroutine (old&amp;mutexWoken != 0)
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//    选择让当前活跃状态的 goroutine 去竞争锁，减少不必要的唤醒
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 2. 当前锁已经被其他 goroutine 获取了 (old&amp;mutexLocked != 0)
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//    需要等待释放锁的时候再做唤醒，应直接退出，
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//    交给下一次 Unlock 调用在处理。
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 3. 当前是一个 Starving 状态 (old&amp;(mutexStarving) != 0)
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//    进入循环前是「非 Starving」状态，而现在确是 Starving 模式。
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//    说明这段时间里出现了 (Lock/Unlock)../Lock 连续调用，
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//    导致「被其他 Unlock 调用唤醒的 goroutine」 拿不到锁，
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//    进入到 Starving 模式。
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//    这种情况下应该直接退出，交给下一次 Unlock 调用在处理了。
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=k>if</span> <span class=nx>old</span><span class=o>&gt;&gt;</span><span class=nx>mutexWaiterShift</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>old</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>mutexLocked</span><span class=p>|</span><span class=nx>mutexWoken</span><span class=p>|</span><span class=nx>mutexStarving</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                                <span class=k>return</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=c1>// 这个时候 mutexLocked|Starving|Woken 标记位为空，尝试将阻塞数目减一。
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 只要 CAS 原子操作成功，就可以唤醒阻塞队列头部的 goroutine。
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=nx>new</span> <span class=p>=</span> <span class=p>(</span><span class=nx>old</span> <span class=o>-</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=nx>mutexWaiterShift</span><span class=p>)</span> <span class=p>|</span> <span class=nx>mutexWoken</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>new</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                                <span class=nf>runtime_Semrelease</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>sema</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                <span class=k>return</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>                        <span class=nx>old</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>state</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 因为出现 Starving 状态，说明阻塞时间足够长了，Unlock 调用者会将
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// runtime_Semrelease 函数第二个参数设置成 true，表示会主动释放
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 当前执行线程，而当前执行线程会直接执行阻塞队列头部的 goroutine。
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=c1>// 被唤醒的 goroutine 相当于获得锁的状态了，因为在 Starving 状态下，
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 新到达的 goroutine 不会竞争锁，它们会直接进入阻塞队列。
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>runtime_Semrelease</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>sema</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=lock-细节>Lock 细节<a hidden class=anchor aria-hidden=true href=#lock-细节>#</a></h3><p>如果一开始 Mutex.state 是一个空值状态，那么 CAS 更新 mutexLocked 标志位会直接成功，相当于上锁了。
那么其他 goroutine 想要上锁就要走 slow path 了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// sync/mutex.go
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Lock locks m.
</span></span></span><span class=line><span class=cl><span class=c1>// If the lock is already in use, the calling goroutine
</span></span></span><span class=line><span class=cl><span class=c1>// blocks until the mutex is available.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Mutex</span><span class=p>)</span> <span class=nf>Lock</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Fast path: grab unlocked mutex.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>mutexLocked</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=nx>race</span><span class=p>.</span><span class=nx>Enabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=nx>race</span><span class=p>.</span><span class=nf>Acquire</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>m</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Slow path (outlined so that the fast path can be inlined)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>m</span><span class=p>.</span><span class=nf>lockSlow</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这里代码细节比较多，我们直接查看中文注释~</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// sync/mutex.go
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Mutex</span><span class=p>)</span> <span class=nf>lockSlow</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>waitStartTime</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 所有刚进入 slow path 的 goroutine 都会以正常模式运行
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 只有出现阻塞了超过 1ms 的情况，才会将 starving = true
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>starving</span> <span class=o>:=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=nx>awoke</span> <span class=o>:=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=nx>iter</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=nx>old</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>state</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 正常模式下（非 Starving） 的时候，新到达的 goroutine 会尝试
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 空转 4 次左右。如果还是 Locked 状态 或者 出现了 Starving 状态，
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// goroutine 会尝试释放执行单元，进入阻塞状态。
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>mutexLocked</span><span class=p>|</span><span class=nx>mutexStarving</span><span class=p>)</span> <span class=o>==</span> <span class=nx>mutexLocked</span> <span class=o>&amp;&amp;</span> <span class=nf>runtime_canSpin</span><span class=p>(</span><span class=nx>iter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 如果阻塞队列非空，那么应该尝试设置上 Woken 状态。
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 用来通知 Unlock 不要做唤醒动作，让当前的 goroutine 去竞争锁。
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=k>if</span> <span class=p>!</span><span class=nx>awoke</span> <span class=o>&amp;&amp;</span> <span class=nx>old</span><span class=o>&amp;</span><span class=nx>mutexWoken</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>old</span><span class=o>&gt;&gt;</span><span class=nx>mutexWaiterShift</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                                <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>old</span><span class=p>|</span><span class=nx>mutexWoken</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                                <span class=nx>awoke</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>                        <span class=nf>runtime_doSpin</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                        <span class=nx>iter</span><span class=o>++</span>
</span></span><span class=line><span class=cl>                        <span class=nx>old</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>state</span>
</span></span><span class=line><span class=cl>                        <span class=k>continue</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=nx>new</span> <span class=o>:=</span> <span class=nx>old</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 如果已经处于 Starving 状态了，那么新到达的 goroutine 就不要
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 去竞争锁了。
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=nx>mutexStarving</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=nx>new</span> <span class=o>|=</span> <span class=nx>mutexLocked</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 如果当前(已经上锁|处于 Starving) 状态，那么(新到达|被唤醒) 
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// goroutine 应该变成阻塞状态。
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>mutexLocked</span><span class=p>|</span><span class=nx>mutexStarving</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=nx>new</span> <span class=o>+=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=nx>mutexWaiterShift</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>//「长时间阻塞 - 被唤醒了还拿不到锁」goroutine 会设置上 Starving。
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 希望在释放锁的时候，优先唤醒自己。
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=nx>starving</span> <span class=o>&amp;&amp;</span> <span class=nx>old</span><span class=o>&amp;</span><span class=nx>mutexLocked</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=nx>new</span> <span class=o>|=</span> <span class=nx>mutexStarving</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 如果是当前 goroutine 设置上了 woken 状态，那么在尝试获得锁的时候，
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 应该去掉该标记位。
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=nx>awoke</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=nx>new</span><span class=o>&amp;</span><span class=nx>mutexWoken</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                                <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;sync: inconsistent mutex state&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>                        <span class=nx>new</span> <span class=o>&amp;^=</span> <span class=nx>mutexWoken</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>new</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 1. old&amp;(mutexLocked|mutexStarving) = 10B
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//    锁已经释放，但正在唤醒「设置 Starving」 goroutine，
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//    当前 goroutine 拿不到锁；
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 2. old&amp;(mutexLocked|mutexStarving) = 01B
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//    锁还没被释放，当前 goroutine 拿不到锁；
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 3. old&amp;(mutexLocked|mutexStarving) = 11B
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//    被唤醒的 goroutine 刚更新成 Starving 状态，
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//    当前 goroutine 拿不到锁；
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 4. old&amp;(mutexLocked|mutexStarving) = 0
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//    正好遇到释放锁，运气不错，new 值拿到锁，退出。
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>mutexLocked</span><span class=p>|</span><span class=nx>mutexStarving</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                                <span class=k>break</span> <span class=c1>// locked the mutex with CAS
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>                        <span class=nx>queueLifo</span> <span class=o>:=</span> <span class=nx>waitStartTime</span> <span class=o>!=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=nx>waitStartTime</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                                <span class=nx>waitStartTime</span> <span class=p>=</span> <span class=nf>runtime_nanotime</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 「被唤醒过 - 但竞争失败」的 goroutine 都采用 LIFO 
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 头插法入队，即插队。
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// runtime_SemacuireMutex 将当前 goroutine 设置成阻塞态
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=nf>runtime_SemacquireMutex</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>sema</span><span class=p>,</span> <span class=nx>queueLifo</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                        <span class=c1>// 被唤醒之后继续执行 
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=nx>starving</span> <span class=p>=</span> <span class=nx>starving</span> <span class=o>||</span> <span class=nf>runtime_nanotime</span><span class=p>()</span><span class=o>-</span><span class=nx>waitStartTime</span> <span class=p>&gt;</span> <span class=nx>starvationThresholdNs</span>
</span></span><span class=line><span class=cl>                        <span class=nx>old</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>state</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=c1>// old&amp;mutexStarving != 0 说明当前 goroutine 已经拿到锁。
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 但这个时候 Mutex.state 相应标记位还没更新。
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=nx>mutexStarving</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=c1>// 在 Starving 状态下，Unlock 只负责唤醒，并不
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// 会更新 Mutex.state 状态。如果状态被修改成
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// mutexLocked，导致不一致，应该 panic。
</span></span></span><span class=line><span class=cl><span class=c1></span>                                <span class=k>if</span> <span class=nx>old</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>mutexLocked</span><span class=p>|</span><span class=nx>mutexWoken</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>old</span><span class=o>&gt;&gt;</span><span class=nx>mutexWaiterShift</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                                        <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;sync: inconsistent mutex state&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                <span class=p>}</span>
</span></span><span class=line><span class=cl>                                <span class=c1>// 更新 mutexLocked 以及对阻塞数目减一。
</span></span></span><span class=line><span class=cl><span class=c1></span>                                <span class=nx>delta</span> <span class=o>:=</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>mutexLocked</span> <span class=o>-</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=nx>mutexWaiterShift</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=c1>// 如果 Starving 状态不清理，那么每次 Unlock
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// 都会直接唤醒阻塞队列里的。
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// 
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// 毕竟 Starving 会让新到达的 goroutine 直接放
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// 弃竞争，解决某些「阻塞太久 goroutine」
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// 获得锁的问题，但也浪费了新到达的 goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// 的执行时间。
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// 如果发现阻塞队列里的 goroutine 并没有达到
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// Starving 设置阈值，那么 应该清理掉 Starving
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// 标记位。
</span></span></span><span class=line><span class=cl><span class=c1></span>                                <span class=k>if</span> <span class=p>!</span><span class=nx>starving</span> <span class=o>||</span> <span class=nx>old</span><span class=o>&gt;&gt;</span><span class=nx>mutexWaiterShift</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                                        <span class=nx>delta</span> <span class=o>-=</span> <span class=nx>mutexStarving</span>
</span></span><span class=line><span class=cl>                                <span class=p>}</span>
</span></span><span class=line><span class=cl>                                <span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>state</span><span class=p>,</span> <span class=nx>delta</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                <span class=k>break</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 属于正常唤醒，Unlock 已经帮忙设置上 mutexWoken 标记
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 和 对阻塞数目减一。
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=nx>awoke</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>                        <span class=nx>iter</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=nx>old</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>state</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>race</span><span class=p>.</span><span class=nx>Enabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>race</span><span class=p>.</span><span class=nf>Acquire</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>m</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h3><p>sync.Mutex 整体代码量不多，其中很多细节都被 runtime.sync_runtime_SemacquireMutex 和
runtime.sync_runtime_Semrelease 函数屏蔽了，后面有时间会更新这部分的代码分析。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://fuweid.com/post/2022-ebpf-loader/><span class=title>« Prev</span><br><span>eBPF Loader</span>
</a><a class=next href=https://fuweid.com/post/2020-go-string-data-race/><span class=title>Next »</span><br><span>可以同时对一个 go string 进行读写操作吗？</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://fuweid.com/>fuweid</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>