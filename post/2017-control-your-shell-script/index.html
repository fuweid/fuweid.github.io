<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>让你的 shell 脚本变得可控 | fuweid</title><meta name=keywords content><meta name=description content="set -euo pipefail 让 shell 脚本变得可控"><meta name=author content><link rel=canonical href=https://fuweid.com/post/2017-control-your-shell-script/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://fuweid.com/favicon.jpg><link rel=icon type=image/png sizes=16x16 href=https://fuweid.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fuweid.com/favicon-32x32.png><link rel=apple-touch-icon href=https://fuweid.com/apple-touch-icon.png><link rel=mask-icon href=https://fuweid.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-1C7VLVHN52"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1C7VLVHN52",{anonymize_ip:!1})}</script><meta property="og:title" content="让你的 shell 脚本变得可控"><meta property="og:description" content="set -euo pipefail 让 shell 脚本变得可控"><meta property="og:type" content="article"><meta property="og:url" content="https://fuweid.com/post/2017-control-your-shell-script/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-03-20T00:00:00+00:00"><meta property="article:modified_time" content="2017-03-20T00:00:00+00:00"><meta property="og:site_name" content="fuweid"><meta name=twitter:card content="summary"><meta name=twitter:title content="让你的 shell 脚本变得可控"><meta name=twitter:description content="set -euo pipefail 让 shell 脚本变得可控"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fuweid.com/post/"},{"@type":"ListItem","position":2,"name":"让你的 shell 脚本变得可控","item":"https://fuweid.com/post/2017-control-your-shell-script/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"让你的 shell 脚本变得可控","name":"让你的 shell 脚本变得可控","description":"set -euo pipefail 让 shell 脚本变得可控","keywords":[],"articleBody":"刚开始接触 shell 脚本的时候，最痛苦的地方在于出了问题，却不容易定位问题。\nshell 脚本遇到错误，“大部分” 情况下都会继续执行剩下的命令，最后返回 Zero Exit Code 并不代表着结果正确。\n这让人很难发现问题，它不像其他脚本语言，遇到 语法错误 和 typo 等错误时便会立即退出。\n如果想要写出容易维护、容易 debug 的 shell 脚本，我们就需要让 shell 脚本变得可控。\nset -e 默认情况下，shell 脚本遇到错误并不会立即退出，它还是会继续执行剩下的命令。\n[root@localhost ~]# cat example #!/usr/bin/env bash # set -e sayhi # this command is not available. echo \"sayhi\" [root@localhost ~]# ./example ./example: line 4: sayhi: command not found sayhi 我们知道 Linux/Unix 用户等于系统的时候，内核会加载 .bashrc 或者 .bash_profile 里的配置。\n不同 shell 版本会使用不同的 rc/profile 文件，比如 zsh 版本的 rc 文件名是 .zshrc。\n简单设想下，假如 shell 脚本遇到错误就退出，那么只要这些文件里有 typo 等错误，该用户就永远登陆不了系统。\n在此，并没有考究默认行为的设计缘由，只是想表达 shell 脚本默认行为会让脚本变得不可控。\nset -e 能会让 shell 脚本遇到 Non-Zero Exit Code 时，会立即停止执行。\n[root@localhost ~]# cat example #!/usr/bin/env bash set -e sayhi # this command is not available. echo \"sayhi\" [root@localhost ~]# ./example ./example: line 4: sayhi: command not found set -u 初始化后再使用变量，这是好的编程习惯。\n但在默认情况下，shell 脚本使用未初始化的变量并不会报错。\n[root@localhost ~]# cat example #!/usr/bin/env bash # set -u echo \"Hi, ${1}\" [root@localhost ~]# ./example Hi, [root@localhost ~]# echo $? 0 若脚本设置 set -u ，一旦使用没有初始化的变量或者 positional parameter 时，脚本将立即返回 1 Exit Code。\n[root@localhost ~]# cat example #!/usr/bin/env bash set -u echo \"Hi, ${1}\" [root@localhost ~]# ./example ./example: line 4: 1: unbound variable [root@localhost ~]# echo $? 1 需要说明的是，对于预定义的 $@, $* 等这些变量，是可以正常使用。\n为了避免使用未初始化的变量，常使用 ${VAR:-DEFAULT} 来设置默认值。\n#!/usr/bin/env bash set -u # ${VAR:-DEFAULT} evals to DEFAULT if VAR undefined. foo=${nonexisting:-ping} echo \"${foo}\" # =\u003e ping bar=\"pong\" foo=${bar:-ping} echo \"${foo}\" # =\u003e pong # DEFAULT can be empty empty=${nonexisting:-} echo \"${empty}\" # =\u003e '' set -o pipefail 在默认情况下，pipeline 会采用最后一个命令的 Exit Code 作为最终返回的 Exit Code。\n[root@localhost ~]# cat example #!/usr/bin/env bash # set -o pipefail grep string /non-existing-file | sort [root@localhost ~]# ./example grep: /non-existing-file: No such file or directory [root@localhost ~]# echo $? 0 明明报错了，为什么还会返回 Zero Exit Code?\ngrep 一个并不存在的文件会返回 2 Exit Code。grep 不仅会输出错误信息到 STDERR 上，还会输出空的字符串到 STDOUT。对于 sort 命令而言，空字符串是合法的输入，所以最后命令返回 Zero Exit Code。\n这样错误信息并不能很好地帮助我们改善脚本，返回的 Exit Code 应该要尽可能地反映错误现场。\n和前面两个设置一样，set -o pipefail 会让 shell 脚本在 pipeline 过程遇到错误便立即返回相应错误的 Exit Code。\n[root@localhost ~]# cat example #!/usr/bin/env bash set -o pipefail grep string /non-existing-file | sort [root@localhost ~]# ./example grep: /non-existing-file: No such file or directory [root@localhost ~]# echo $? 2 non-zero exit code is expected 这三个配置太过于苛刻，某些情况下还需要放宽这些限制：当程序可以接受 non-zero exit code 时。\n这里有两种常用的方式去放宽限制：\nset + 这里有一个脚本是用来产生长度为 64 的随机字符串：\nroot@localhost ~]# cat example #!/usr/bin/env bash set -euo pipefail str=$(cat /dev/urandom | tr -dc '0-9A-Za-z' | head -c 64) echo \"${str}\" [root@localhost ~]# ./example [root@localhost ~]# echo $? 141 该脚本有一个问题，就是 head 命令在获取到第 64 个字节之后，会关闭 STDIN，但是 pipe 还在不断地输出，导致内核不得不抛出 SIGPIPE 来终止命令。\n因为设置 set -o pipefail 了 ，整个脚本因为 SIGPIPE 会退出。\n假设该脚本剩下命令还很多，不能整体去掉 pipefail ，那么我们就局部放弃这个限制好了。\n[root@localhost ~]# cat example #!/usr/bin/env bash # exit immediately if non-zero exit code/unset variable/pipe error set -euo pipefail # loosen up set +o pipefail str=$(cat /dev/urandom | tr -dc '0-9A-Za-z' | head -c 64) set -o pipefail echo \"${str}\" [root@localhost ~]# ./example pvScFHDZrdjlI091rQbruyEPM9e6iTN59IyzaKcCJwiCxYmiSNRmkFOfp0YuXi1C [root@localhost ~]# echo $? 0 同理，只要设置上 set +e 或者 set +u 时，就会放宽相应的限制。\n记得 有借有还，再借不难 就好了。\n短路运算 现在有一个脚本，该脚本用来统计文件 file 中有多少行是包含了 string 这个字符串。\nroot@localhost ~]# cat example #!/usr/bin/env bash set -euo pipefail count=$(grep -c string ./file) echo \"${count}\" [root@localhost ~]# ./example [root@localhost ~]# echo $? 1 [root@localhost ~]# cat ./file example 因为文件 file 中并不包含 string 这一字符串，所以 grep 返回 1 Exit Code。\n假设遇到没有匹配上的文件，该脚本应该显示零，而不是错误。\n$(cmd || true) 短路运算会让该命令永远都正常执行。\n[root@localhost ~]# cat example #!/usr/bin/env bash set -euo pipefail count=$(grep -c string ./file || true) echo \"${count}\" [root@localhost ~]# ./example 0 [root@localhost ~]# echo $? 0 思考 shell 脚本能帮助我们轻松地完成自动化的任务，这是它的优势。\n但是劣势也比较明显，就是 shell 脚本的返回值。我们来看看下面的一个例子。\n相对于 if/else, 短路运算可以让代码变得简洁。\n但是一旦最终的判断结果为否，那么该短路运算将会返回 Non-Zero Exit Code。\n假如有一个脚本的最后一条命令是短路运算。\n[root@localhost ~]# cat ./echo_filename #!/usr/bin/env bash set -euo pipefail file=${1:-} [[ -f \"${file}\" ]] \u0026\u0026 echo \"File: ${file}\" [root@localhost ~]# ./echo_filename [root@localhost ~]# echo $? 1 如果没有传参数，那么短路运算将会返回 1 Exit Code，这个结果也将作为整个脚本的返回结果。\n需要说明的是，虽然短路运算返回的 Non-Zero Exit Code，但 set -e 不会因为它而退出。\n然后我们再看看使用 if/else 的结果。\n[root@localhost ~]# cat echo_filename #!/usr/bin/env bash set -euo pipefail file=${1:-} if [[ -f \"${file}\" ]]; then echo \"File: ${file}\" fi [root@localhost ~]# ./echo_filename [root@localhost ~]# echo $? 0 从逻辑上来分析，即使不传参数，呈现的应该是空字符串，并返回 Zero Exit Code。\nif/else 语句相对于短路运算要合理。\n我们别小看这一区别，如果这里有脚本调用 echo_filename，那么使用短路运算将会导致调用该脚本的脚本停止工作。\n归根结底，是因为 shell 脚本并不像其他语言那样支持返回多种数据类型，它只能返回数字的 Exit Code。\n这就代表着脚本的程序设计必须要考虑返回正确的 Exit Code，这样 set -euo pipefail 才能让脚本变得更加可控。\n关于 set 更多的内容，请前往 Link 。\n","wordCount":"627","inLanguage":"en","datePublished":"2017-03-20T00:00:00Z","dateModified":"2017-03-20T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://fuweid.com/post/2017-control-your-shell-script/"},"publisher":{"@type":"Organization","name":"fuweid","logo":{"@type":"ImageObject","url":"https://fuweid.com/favicon.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fuweid.com/ accesskey=h title="fuweid.com (Alt + H)">fuweid.com</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fuweid.com/>Home</a>&nbsp;»&nbsp;<a href=https://fuweid.com/post/>Posts</a></div><h1 class=post-title>让你的 shell 脚本变得可控</h1><div class=post-description>set -euo pipefail 让 shell 脚本变得可控</div><div class=post-meta><span title='2017-03-20 00:00:00 +0000 UTC'>March 20, 2017</span></div></header><div class=post-content><p>刚开始接触 shell 脚本的时候，最痛苦的地方在于出了问题，却不容易定位问题。</p><p>shell 脚本遇到错误，“大部分” 情况下都会继续执行剩下的命令，最后返回 Zero <a href=https://en.wikipedia.org/wiki/Exit_status>Exit Code</a> 并不代表着结果正确。</p><p>这让人很难发现问题，它不像其他脚本语言，遇到 <code>语法错误</code> 和 <code>typo</code> 等错误时便会立即退出。</p><p>如果想要写出容易维护、容易 debug 的 shell 脚本，我们就需要让 shell 脚本变得可控。</p><h3 id=set--e>set -e<a hidden class=anchor aria-hidden=true href=#set--e>#</a></h3><p>默认情况下，shell 脚本遇到错误并不会立即退出，它还是会继续执行剩下的命令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># cat example</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/env bash</span>
</span></span><span class=line><span class=cl><span class=c1># set -e</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sayhi <span class=c1># this command is not available.</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;sayhi&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># ./example</span>
</span></span><span class=line><span class=cl>./example: line 4: sayhi: <span class=nb>command</span> not found
</span></span><span class=line><span class=cl>sayhi
</span></span></code></pre></div><p>我们知道 Linux/Unix 用户等于系统的时候，内核会加载 <code>.bashrc</code> 或者 <code>.bash_profile</code> 里的配置。</p><blockquote><p>不同 shell 版本会使用不同的 rc/profile 文件，比如 zsh 版本的 rc 文件名是 .zshrc。</p></blockquote><p>简单设想下，假如 shell 脚本遇到错误就退出，那么只要这些文件里有 typo 等错误，该用户就永远登陆不了系统。</p><blockquote><p>在此，并没有考究默认行为的设计缘由，只是想表达 shell 脚本默认行为会让脚本变得不可控。</p></blockquote><p><code>set -e</code> 能会让 shell 脚本遇到 Non-Zero Exit Code 时，会立即停止执行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># cat example</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/env bash</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> -e
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sayhi <span class=c1># this command is not available.</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;sayhi&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># ./example</span>
</span></span><span class=line><span class=cl>./example: line 4: sayhi: <span class=nb>command</span> not found
</span></span></code></pre></div><h3 id=set--u>set -u<a hidden class=anchor aria-hidden=true href=#set--u>#</a></h3><p>初始化后再使用变量，这是好的编程习惯。</p><p>但在默认情况下，shell 脚本使用未初始化的变量并不会报错。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># cat example</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/env bash</span>
</span></span><span class=line><span class=cl><span class=c1># set -u</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;Hi, </span><span class=si>${</span><span class=nv>1</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># ./example</span>
</span></span><span class=line><span class=cl>Hi,
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># echo $?</span>
</span></span><span class=line><span class=cl><span class=m>0</span>
</span></span></code></pre></div><p>若脚本设置 <code>set -u</code> ，一旦使用没有初始化的变量或者 <code>positional parameter</code> 时，脚本将立即返回 1 Exit Code。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># cat example</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/env bash</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> -u
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;Hi, </span><span class=si>${</span><span class=nv>1</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># ./example</span>
</span></span><span class=line><span class=cl>./example: line 4: 1: unbound variable
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># echo $?</span>
</span></span><span class=line><span class=cl><span class=m>1</span>
</span></span></code></pre></div><blockquote><p>需要说明的是，对于预定义的 <code>$@</code>, <code>$*</code> 等这些变量，是可以正常使用。</p></blockquote><p>为了避免使用未初始化的变量，常使用 <code>${VAR:-DEFAULT}</code> 来设置默认值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/usr/bin/env bash
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=nb>set</span> -u
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ${VAR:-DEFAULT} evals to DEFAULT if VAR undefined.</span>
</span></span><span class=line><span class=cl><span class=nv>foo</span><span class=o>=</span><span class=si>${</span><span class=nv>nonexisting</span><span class=k>:-</span><span class=nv>ping</span><span class=si>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>foo</span><span class=si>}</span><span class=s2>&#34;</span> <span class=c1># =&gt; ping</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>bar</span><span class=o>=</span><span class=s2>&#34;pong&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>foo</span><span class=o>=</span><span class=si>${</span><span class=nv>bar</span><span class=k>:-</span><span class=nv>ping</span><span class=si>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>foo</span><span class=si>}</span><span class=s2>&#34;</span> <span class=c1># =&gt; pong</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># DEFAULT can be empty</span>
</span></span><span class=line><span class=cl><span class=nv>empty</span><span class=o>=</span><span class=si>${</span><span class=nv>nonexisting</span><span class=k>:-</span><span class=si>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>empty</span><span class=si>}</span><span class=s2>&#34;</span> <span class=c1># =&gt; &#39;&#39;</span>
</span></span></code></pre></div><h3 id=set--o-pipefail>set -o pipefail<a hidden class=anchor aria-hidden=true href=#set--o-pipefail>#</a></h3><p>在默认情况下，<code>pipeline</code> 会采用最后一个命令的 Exit Code 作为最终返回的 Exit Code。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># cat example</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/env bash</span>
</span></span><span class=line><span class=cl><span class=c1># set -o pipefail</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>grep string /non-existing-file <span class=p>|</span> sort
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># ./example</span>
</span></span><span class=line><span class=cl>grep: /non-existing-file: No such file or directory
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># echo $?</span>
</span></span><span class=line><span class=cl><span class=m>0</span>
</span></span></code></pre></div><p>明明报错了，为什么还会返回 Zero Exit Code?</p><p><code>grep</code> 一个并不存在的文件会返回 2 Exit Code。<code>grep</code> 不仅会输出错误信息到 <code>STDERR</code> 上，还会输出空的字符串到 <code>STDOUT</code>。对于 <code>sort</code> 命令而言，空字符串是合法的输入，所以最后命令返回 Zero Exit Code。</p><p>这样错误信息并不能很好地帮助我们改善脚本，返回的 Exit Code 应该要尽可能地反映错误现场。</p><p>和前面两个设置一样，<code>set -o pipefail</code> 会让 shell 脚本在 <code>pipeline</code> 过程遇到错误便立即返回相应错误的 Exit Code。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># cat example</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/env bash</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> -o pipefail
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>grep string /non-existing-file <span class=p>|</span> sort
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># ./example</span>
</span></span><span class=line><span class=cl>grep: /non-existing-file: No such file or directory
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># echo $?</span>
</span></span><span class=line><span class=cl><span class=m>2</span>
</span></span></code></pre></div><h3 id=non-zero-exit-code-is-expected>non-zero exit code is expected<a hidden class=anchor aria-hidden=true href=#non-zero-exit-code-is-expected>#</a></h3><p>这三个配置太过于苛刻，某些情况下还需要放宽这些限制：当程序可以接受 non-zero exit code 时。</p><p>这里有两种常用的方式去放宽限制：</p><h4 id=set->set +<a hidden class=anchor aria-hidden=true href=#set->#</a></h4><p>这里有一个脚本是用来产生长度为 64 的随机字符串：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>root@localhost ~<span class=o>]</span><span class=c1># cat example</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/env bash</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> -euo pipefail
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>str</span><span class=o>=</span><span class=k>$(</span>cat /dev/urandom <span class=p>|</span> tr -dc <span class=s1>&#39;0-9A-Za-z&#39;</span> <span class=p>|</span> head -c 64<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>str</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># ./example</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># echo $?</span>
</span></span><span class=line><span class=cl><span class=m>141</span>
</span></span></code></pre></div><p>该脚本有一个问题，就是 <code>head</code> 命令在获取到第 64 个字节之后，会关闭 <code>STDIN</code>，但是 <code>pipe</code> 还在不断地输出，导致内核不得不抛出 <code>SIGPIPE</code> 来终止命令。</p><p>因为设置 <code>set -o pipefail</code> 了 ，整个脚本因为 <code>SIGPIPE</code> 会退出。</p><p>假设该脚本剩下命令还很多，不能整体去掉 <code>pipefail</code> ，那么我们就局部放弃这个限制好了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># cat example</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/env bash</span>
</span></span><span class=line><span class=cl><span class=c1># exit immediately if non-zero exit code/unset variable/pipe error</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> -euo pipefail
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># loosen up</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> +o pipefail
</span></span><span class=line><span class=cl><span class=nv>str</span><span class=o>=</span><span class=k>$(</span>cat /dev/urandom <span class=p>|</span> tr -dc <span class=s1>&#39;0-9A-Za-z&#39;</span> <span class=p>|</span> head -c 64<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> -o pipefail
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>str</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># ./example</span>
</span></span><span class=line><span class=cl>pvScFHDZrdjlI091rQbruyEPM9e6iTN59IyzaKcCJwiCxYmiSNRmkFOfp0YuXi1C
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># echo $?</span>
</span></span><span class=line><span class=cl><span class=m>0</span>
</span></span></code></pre></div><p>同理，只要设置上 <code>set +e</code> 或者 <code>set +u</code> 时，就会放宽相应的限制。</p><p>记得 <strong>有借有还，再借不难</strong> 就好了。</p><h4 id=短路运算>短路运算<a hidden class=anchor aria-hidden=true href=#短路运算>#</a></h4><p>现在有一个脚本，该脚本用来统计文件 <code>file</code> 中有多少行是包含了 <code>string</code> 这个字符串。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>root@localhost ~<span class=o>]</span><span class=c1># cat example</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/env bash</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> -euo pipefail
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>count</span><span class=o>=</span><span class=k>$(</span>grep -c string ./file<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>count</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># ./example</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># echo $?</span>
</span></span><span class=line><span class=cl><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># cat ./file</span>
</span></span><span class=line><span class=cl>example
</span></span></code></pre></div><p>因为文件 <code>file</code> 中并不包含 <code>string</code> 这一字符串，所以 <code>grep</code> 返回 1 Exit Code。</p><p>假设遇到没有匹配上的文件，该脚本应该显示零，而不是错误。</p><p><code>$(cmd || true)</code> 短路运算会让该命令永远都正常执行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># cat example</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/env bash</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> -euo pipefail
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>count</span><span class=o>=</span><span class=k>$(</span>grep -c string ./file <span class=o>||</span> <span class=nb>true</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>count</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># ./example</span>
</span></span><span class=line><span class=cl><span class=m>0</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># echo $?</span>
</span></span><span class=line><span class=cl><span class=m>0</span>
</span></span></code></pre></div><h3 id=思考>思考<a hidden class=anchor aria-hidden=true href=#思考>#</a></h3><p>shell 脚本能帮助我们轻松地完成自动化的任务，这是它的优势。</p><p>但是劣势也比较明显，就是 shell 脚本的返回值。我们来看看下面的一个例子。</p><p>相对于 <code>if/else</code>, 短路运算可以让代码变得简洁。</p><p>但是一旦最终的判断结果为否，那么该短路运算将会返回 Non-Zero Exit Code。</p><p>假如有一个脚本的最后一条命令是短路运算。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># cat ./echo_filename</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/env bash</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> -euo pipefail
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>file</span><span class=o>=</span><span class=si>${</span><span class=nv>1</span><span class=k>:-</span><span class=si>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[[</span> -f <span class=s2>&#34;</span><span class=si>${</span><span class=nv>file</span><span class=si>}</span><span class=s2>&#34;</span> <span class=o>]]</span> <span class=o>&amp;&amp;</span> <span class=nb>echo</span> <span class=s2>&#34;File: </span><span class=si>${</span><span class=nv>file</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># ./echo_filename</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># echo $?</span>
</span></span><span class=line><span class=cl><span class=m>1</span>
</span></span></code></pre></div><p>如果没有传参数，那么短路运算将会返回 1 Exit Code，这个结果也将作为整个脚本的返回结果。</p><blockquote><p>需要说明的是，虽然短路运算返回的 Non-Zero Exit Code，但 <code>set -e</code> 不会因为它而退出。</p></blockquote><p>然后我们再看看使用 <code>if/else</code> 的结果。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># cat echo_filename</span>
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/env bash</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> -euo pipefail
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>file</span><span class=o>=</span><span class=si>${</span><span class=nv>1</span><span class=k>:-</span><span class=si>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>[[</span> -f <span class=s2>&#34;</span><span class=si>${</span><span class=nv>file</span><span class=si>}</span><span class=s2>&#34;</span> <span class=o>]]</span><span class=p>;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;File: </span><span class=si>${</span><span class=nv>file</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># ./echo_filename</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># echo $?</span>
</span></span><span class=line><span class=cl><span class=m>0</span>
</span></span></code></pre></div><p>从逻辑上来分析，即使不传参数，呈现的应该是空字符串，并返回 Zero Exit Code。</p><p><code>if/else</code> 语句相对于短路运算要合理。</p><p>我们别小看这一区别，如果这里有脚本调用 <code>echo_filename</code>，那么使用短路运算将会导致调用该脚本的脚本停止工作。</p><p>归根结底，是因为 shell 脚本并不像其他语言那样支持返回多种数据类型，它只能返回数字的 Exit Code。</p><p>这就代表着脚本的程序设计必须要考虑返回正确的 Exit Code，这样 <code>set -euo pipefail</code> 才能让脚本变得更加可控。</p><blockquote><p>关于 <code>set</code> 更多的内容，请前往 <a href=https://www.gnu.org/software/bash/manual/bashref.html#The-Set-Builtin>Link</a> 。</p></blockquote></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://fuweid.com/post/2017-go-interface-duck-typing/><span class=title>« Prev</span><br><span>Go Interface & Duck Typing</span></a>
<a class=next href=https://fuweid.com/post/2017-shebang-compatibility-version/><span class=title>Next »</span><br><span>shebang - #!</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://fuweid.com/>fuweid</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>