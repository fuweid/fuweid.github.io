<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>containerd 1.7: UserNamespace Stateless Pod | fuweid</title><meta name=keywords content><meta name=description content="Usernamespace 实验特性介绍"><meta name=author content><link rel=canonical href=https://fuweid.com/post/2023-containerd-17-userns/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://fuweid.com/favicon.jpg><link rel=icon type=image/png sizes=16x16 href=https://fuweid.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fuweid.com/favicon-32x32.png><link rel=apple-touch-icon href=https://fuweid.com/apple-touch-icon.png><link rel=mask-icon href=https://fuweid.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-1C7VLVHN52"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1C7VLVHN52",{anonymize_ip:!1})}</script><meta property="og:title" content="containerd 1.7: UserNamespace Stateless Pod"><meta property="og:description" content="Usernamespace 实验特性介绍"><meta property="og:type" content="article"><meta property="og:url" content="https://fuweid.com/post/2023-containerd-17-userns/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-03-04T15:20:45+08:00"><meta property="article:modified_time" content="2023-03-04T15:20:45+08:00"><meta property="og:site_name" content="fuweid"><meta name=twitter:card content="summary"><meta name=twitter:title content="containerd 1.7: UserNamespace Stateless Pod"><meta name=twitter:description content="Usernamespace 实验特性介绍"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fuweid.com/post/"},{"@type":"ListItem","position":2,"name":"containerd 1.7: UserNamespace Stateless Pod","item":"https://fuweid.com/post/2023-containerd-17-userns/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"containerd 1.7: UserNamespace Stateless Pod","name":"containerd 1.7: UserNamespace Stateless Pod","description":"Usernamespace 实验特性介绍","keywords":[],"articleBody":"containerd 1.7 版本有比较多的实验特性。在这里，我会介绍 containerd 对 UserNamespace Stateless Pod 支持的情况，算是个人对 containerd 1.7 版本特性介绍系列的开篇。\n1. UserNamespace 安全特性 Linux 内核是基于进程的 credentials(7) 凭证来做访问控制，比如进程的拥有者标识 UID/GID 和用于系统资源访问控制判定的 Effective UID/GID 等凭证。而 user_namespace(7) 提供了安全隔离特性。在不同的 user namespace(userns) 下，同一个进程不仅有不同的 UID/GID，同时还具备了不同的 capabilities(7) 权限。比如 u1001 用户进程 bash 通过 unshare -r bash 进入到了新的 userns，并将自己映射成了 root 用户，还具备了所有的 capabilities。但这个进程真的就变成了特权进程？这取决于该用户在系统资源所属的 userns 里是否拥有访问权限。\n在介绍具体的判定规则前，先花点时间了解下内核是如何管理 UID/GID 的映射关系。\n每个进程都必须归属于某一个 userns。在初始状态下，进程都属于 initial userns。Initial userns 比较特殊，它没有任何映射关系；Linux 支持嵌套的 userns，所有正在使用的 userns 组成的关系图将会是以 initial userns 为根的树状图。在 parent userns 里的进程，只要具备 CAP_SET{UID,GID} 能力，这些进程就可以通过 /proc/[pid]/{uid,gid}_map 文件接口，以 ID-inside-ns ID-outside-ns Range-length 的格式，给刚进入 child userns 的进程设置 UID/GID 映射关系，而创建该 userns 进程的 Effective UID(EUID) 将成为 userns 的所有者，如下图所示。\n在上图中，有两层 userns 映射关系：\nuid_map: 0 1001 10 将 initial userns 的 UID [1001, 1010] 映射到 userns X 里的 UID [0, 9] uid_map: 10 0 5 将 userns X 中的 UID [0, 4] 映射成 userns Y 里的 UID [10, 14]。 但这些都是用户态的映射关系，uid_map 文件接口会将其转化成 内核态的映射关系 userspace-id:kernel-id:range(u:k:r)，比如 u1000:k0:r100 映射关系可以把 k10 映射成 u1010 = k10 - k0 + u1000；同样的，u1005 可以转化为 k5 = u1005 - u1000 + k0，其中 r100 是用来判断映射是否超出范围。Initial userns 的 ID 映射关系是 u0:k0:r4294967295，相当于 u 等于 k。Userns X 的 parent userns 是 initial userns，结合 uid_map 的配置，内核态的映射关系应为 u0:k1001:r10；同理 Userns Y 的内核态映射关系是 u10:k1001:r5。在进行权限判断时，内核最终都以 kernel-id 为凭据。\n回到最初的话题，为什么具备了所有 capabilities 还是不能进行 bind-mount？\nLinux 的系统资源都归属于某一个 userns，比如 mount_namespace(7) 下的挂载资源，network_namespace(7) 下的设备资源等等。当进程想要访问系统资源时，内核会采用下面的策略来决定进程是否有权 (为了方便解释，被访问的系统资源属于 userns X，而访问该系统资源的进程属于 userns Y)：\n在 initial userns 为根的树状关系里，当 userns X 是 userns Y 的祖先或者是兄弟分支，进程无权访问； 当 userns X 与 userns Y 相等或者 userns Y 是 userns X 的祖先时，只要进程具备资源要求的 capabilities 即可访问； 当 userns Y 是 userns X 的父节点，且当前进程的 EUID 为 userns X 的创建者，那么该进程可以访问 userns Y 下的所有系统资源。 判断进程的 EUID 是否为 userns X 的所有者时，内核比较的是 kernel-id。上诉的判断来自 cap_capable 函数。大部分的权限判断都包着它来做，比如挂载权限的判断逻辑在 may_mount 等，感兴趣的可以去看看。\n如上图所示，虽然 unshare 切换了 userns，但 mount_namespace(mountns) 依然属于 parent userns。根据访问策略来看，当前进程无权访问祖先 userns 的资源，因此挂载失败。如果想要在不提权的情况下进行挂载，最好的方式就是 unshare 切换新的 mountns。全新的 mountns 将属于当前的 userns；当前进程具有 SYS_ADMIN 权限，所以它能进行挂载。\n现在的容器默认会配置独立的 mount/network/pid/ipc/uts_namespace(7) 资源，没有的独立的 userns，这些系统资源依旧隶属于 initial userns。而大部分容器进程都以 root 用户身份启动，为了防止容器进程逃逸后对系统造成破坏，业界的普遍做法是限制容器进程的 capabilities，同时采用 SELinux/Apparmor 安全规则控制对系统资源的访问。但这毕竟都是后验形式，集群管理员需要对容器进程做大量的行为审计，他们才能得到有效的安全规则。但就目前的结果来看，现在依然有不少 initial userns 的权限泄漏所引发的安全问题。\n既然全新的 userns 可以完全禁止进程访问隶属于 initial userns 的系统资源，那么为什么迟迟不落地呢？\n2. FSUID 映射问题 在 Linux 系统里，一个进程有两个关键的身份凭证：一个是前面提到的 EUID，它用于做系统资源的权限判断；而另外一个是 Filesystem UID(FSUID)，它用来判断是否有权限访问文件目录。一般情况下只要不调用 setfsuid，进程的 FSUID 都和 EUID 保持一致。\n当进程在创建文件目录时，文件系统会将当前进程 FSUID 的映射结果写入到存储设备。当然，文件系统并不是持久化当前 userns 的映射结果。当进程挂载文件系统时，内核会将该进程所在的 userns caller u:k:r 映射关系作为对应文件系统的 fs u:k:r 映射关系。文件系统会将创建文件进程的 FSUID kernel-id 转化成 fs u:k:r 下的 userspace-id，这个 id 才是最终存储的结果。有了这个概念后，我们看下查看文件拥有者标识的过程。\n假设用户 u1001 HOME 目录所在的文件系统采用了 fs u0:k0:r4294967295 映射，以及当前 stat 进程的 userns 也采用了同样的映射 caller u0:k0:r4294967295。文件系统先将存储设备里的 u1001 转化成 k1001，内核再通过当前进程的映射关系转化，最终得到我们所看到的 u1001。\n让我们再看看把 u1001 映射成 root 用户后的显示效果，如下图所示。因为进程已经切换到了新的 userns，但 .bashrc 文件的存储没有发生变化，经过两次映射，我们最终看到的是 u0。原先 /var/lib/containerd 在存储设备里的 FSUID 是 u0，经过 fs u0:k0:r4294967295 映射后得到 k0，但 k0 并不在 caller u0:k1001:r1 的范围内。对于这些不在映射范围内的 UID，内核统一显示成 nobody(65534)。这也意味着，当前 root 用户依然无法访问 /var/lib/containerd。\n回到容器的使用场景。首先，绝大多数的容器镜像是以 root 用户构建，这就要求容器进程的 FSUID 经过映射后要和存储对应的 FSUID 一致。为了方便解释，这里假设容器镜像的底层文件系统采用 initial userns 映射方式。如果容器进程采用 caller r0:k1001:r1 映射，那么它是无权访问镜像内容，它将无法启动。解决这个问题的方式，就是在启动容器前，我们通过 chown -R 把容器的根录都修改成 u1001。但这也意味着效率低下。\nImage Size Inodes overlayfs w/ metacopy overlayfs w/o metacopy tensorflow/tensorflow:latest 1489MiB 32596 1.29s 54.80s library/node:latest 1425MiB 33385 1.18s 52.86s library/ubuntu:22.04 83.4MiB 3517 0.15s 5.32s 当我们在修改容器根目录的文件属性时，如果没有 metacopy=on 的属性支持，那么 chown -R 在修改文件属性前，overlayfs 文件系统会将这个文件从只读层拷贝到可写层。如果文件越大，整个修改过程就越慢，同时还产生磁盘压力；带上 metacopy=on 之后，至少 overlayfs 仅拷贝文件的 metadata，效率高不少。但面对小文件特别多的场景，chown -R 操作依旧很耗时。与此同时， chown 还是永久性修改文件属性。\n然而不同容器之间可能会共享同一个数据卷。常见的场景有：容器 A 以 caller r0:k1001:r1 映射关系产生数据，然后容器 B 再进行分析消费。这就要求容器 B 也必须使用 r0:k1001:r1 映射关系，否则只能再次使用 chown 来切换。\n在全民白嫖镜像仓库的形势下，镜像仓库已经变成 免费数据 仓库。个人见过上百 GiB 的容器镜像，在这种容器镜像面前使用 chown，这简直是劝退。\n3. Mount idmapped 特性 \u003e= kernel v5.12 为了解决这个映射的难题，Linux v5.12 版本 引入了挂载点的映射关系 mount u:k:r，用户可以通过它来绕过文件系统原先的 fs u:k:r 映射，其中该特性由 mount_setattr(2) 系统调用提供。我们直接看例子解释吧，如下图所示。\nmount-idmapped 工具把 /var/lib/containerd 挂载到 /mnt 下，并通过 mount u0:k1001:r1 映射关系将其 授权 给 u1001 用户进程访问，u1001 用户无需提权就可以在 /mnt 下访问 /var/lib/containerd 的数据。挂载点 /mnt 上的 mount u0:k1001:r1 映射关系是替代了原先的 fs u0:k0:r4294967295。只是底层文件系统 inode 保存的是 fs u:k:r 映射后的 kernel-id；而 mount u:k:r 由 Virtual filesystem(vfs) 模块管理，vfs 拿不到存储设备上保存的 userspace-id，所以 vfs 需要利用 fs u:k:r 转化回来。这也就是上图里，u0 -\u003e k0 -\u003e u0 转化看似无效，但它其实是真实的处理流程。\n如果 u1001 用户进程在 /mnt 目录里进行写操作，通过上图的映射关系，新文件的 FSUID 最终将以 u0 落盘。\n无论多大的文件目录，该内核特性都可以很快完成 FSUID 映射，还可以同时支持多个 mount u:k:r 映射，也解决了数据卷共享问题。我想这就是为什么社区开始推进 userns 落地的原因吧。\n4. containerd 目前的集成情况 为了支持 userns，containerd 对 CRI RunPodSandbox 的流程有比较大的改动，但这仅针对 userns 场景的 Pod，其他场景和之前保持一致。\n4.1 依旧使用 chown 修改容器根目录 containerd 并没有使用 mount_setattr 特性，目前还是使用 chown 的形式。为了减少不必要的 chown 操作，containerd 将首次 chown 之后的容器根目录做成只读 snapshot，而对于后续使用相同镜像以及相同 uid_map 的容器而言，containerd 可以直接用现成的 snapshot 做根目录。也算是一个优化吧。\n没有集成 mount idmapped 的主要原因在于，它对 containerd 现有的 mount 挂载流程影响比较大。\nLinux v5.19 overlayfs 文件系统开始支持 mount idmapped，但它是针对只读层设计，用户无法对一个已挂载好的 overlayfs 文件系统进行 mount idmapped，毕竟 overlayfs 并没有像 ext4/xfs/btrfs 那样拥有 FS_ALLOW_IDMAP。\n// https://elixir.bootlin.com/linux/v6.1.15/source/fs/namespace.c#L3979 static int can_idmap_mount(const struct mount_kattr *kattr, struct mount *mnt) { ... /* The underlying filesystem doesn't support idmapped mounts yet. */ if (!(m-\u003emnt_sb-\u003es_type-\u003efs_flags \u0026 FS_ALLOW_IDMAP)) return -EINVAL; ... } 为此，我们需要将容器镜像的只读层挨个进行 mount idmapped，最后再挂载成 overlayfs。或者是将容器镜像直接解压到已经 mount idmapped 好的挂载点上。但后者对现有 containerd snapshot 管理有比较大的冲击，前者看起来会更容易落地些。\n值得一提的是，新版本内核已经演进出了新的 mount API: fsopen(2)/fsconfig(2)/fsmount(2) 将文件系统挂载拆成多次系统调用，而且 fsmount(2) 仅是生成 anonymous mount 记录，需要 move_mount(2) 将其转化成可见的挂载点。而普通的 bind mount 将由 open_tree(2) 来产生 anonymouns mount。\nmount_setattr 有一个要求就是必须是 anonymouns mount。但除了 fsopen，fsconfig/fsmount/open_tree 都没进入 golang.org/x/sys/unix。整体来看，mount_setattr 在 containerd 上落下来可能还需要几个月的时间。\n4.2 延后网络初始化 早期 dockerd 的容器网络初始化是在 runC 进入 init 阶段后，runC 通过 prestart_hook 回调通知 dockerd， dockerd 再通过 setns(2) 进入到容器 network namespace(netns) 进行配置。\n同样，kubelet 在处理 dockershim 的网络时，它也是等待 pause 容器启动后，并通过 /proc/[pause-pid]/ns/net 来进行 CNI 调用。但这里有一个很大的问题就是，一旦 pause 容器进程被意外杀死，同时原先 pause 容器进程 pid 被复用，那么 CNI 将会在错误的 netns 里进行操作。运气不好的话，CNI 可能会操作到 initial userns 下的 netns，造成整机的网络中断。\n而 containerd CRI 当前的设计可以避免 pid 复用所引发的问题。在启动 pause 容器前，containerd 会提前准备好 netns，并将其持久化到 /run/netns 之下。这个行为和 ip netns add 行为一致，如下图所示。CNI 初始化完毕后，containerd 才将持久化后的 netns 地址交给 runC。这完全避免了 pid 复用的问题。\n但这个不适用于 userns 场景，因为 containerd 创建的出来 netns 属于 initial userns，而且它还挂载在属于 initial userns 的 mountns 里。新的 userns 无法操作 netns 下的资源，同时因为 netns 归属问题，还导致 runC 无法将 /sys/ 挂载容器根目录。\n解决这个问题的唯一途径就是让 runC 创建 netns。为了防止出现 pid 复用问题，在 runC init 阶段结束后，containerd 将 /proc/[pause-pid]/ns/net 持久化到 /run/netns 之下，然后再判断 runC init 进程是否还处于运行状态，避免出现 datarace 的情况。\n为了避免对现有容器运行时集成的影响，这个处理逻辑仅针对使用 userns 的容器，原先支持的场景不受影响。\n5. 最后 目前该特性距离上生产还有很长的路要走，下图是 Kubernetes SIG-Node 之前讨论过规划。除此之外，还得看用户侧是否实时跟进新内核，以及各大 Linux 发行版商是否会及时 backport 新版本特性。\n个人倒是很喜欢这个特性，因为 userns 几乎可以让容器进程更好地享受隔离特性，减少 seccomp 这些作用不大但影响性能的配置干扰。说到这，我想起前同事做过的镜像构建项目，因为安全问题，管理员迟迟不愿意开放 mount 挂载权限。如果这个特性能推广，应该能减少很多不必要的会了吧。。。\n","wordCount":"775","inLanguage":"en","datePublished":"2023-03-04T15:20:45+08:00","dateModified":"2023-03-04T15:20:45+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://fuweid.com/post/2023-containerd-17-userns/"},"publisher":{"@type":"Organization","name":"fuweid","logo":{"@type":"ImageObject","url":"https://fuweid.com/favicon.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fuweid.com/ accesskey=h title="fuweid.com (Alt + H)">fuweid.com</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fuweid.com/>Home</a>&nbsp;»&nbsp;<a href=https://fuweid.com/post/>Posts</a></div><h1 class=post-title>containerd 1.7: UserNamespace Stateless Pod</h1><div class=post-description>Usernamespace 实验特性介绍</div><div class=post-meta><span title='2023-03-04 15:20:45 +0800 HKT'>March 4, 2023</span></div></header><div class=post-content><p>containerd 1.7 版本有比较多的<a href="https://github.com/containerd/containerd/blob/1e0e909dcc4676b2afafe0851a609992482cc006/RELEASES.md?plain=1#L385">实验特性</a>。在这里，我会介绍 containerd 对 <a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/127-user-namespaces#phase-1-pods-without-volumes>UserNamespace Stateless Pod</a> 支持的情况，算是个人对 containerd 1.7 版本特性介绍系列的开篇。</p><h2 id=1-usernamespace-安全特性>1. UserNamespace 安全特性<a hidden class=anchor aria-hidden=true href=#1-usernamespace-安全特性>#</a></h2><p>Linux 内核是基于进程的 <a href=https://man7.org/linux/man-pages/man7/credentials.7.html>credentials(7)</a> 凭证来做访问控制，比如进程的拥有者标识 UID/GID 和用于系统资源访问控制判定的 Effective UID/GID 等凭证。而 <a href=https://man7.org/linux/man-pages/man7/user_namespaces.7.html>user_namespace(7)</a> 提供了安全隔离特性。在不同的 user namespace(userns) 下，同一个进程不仅有不同的 UID/GID，同时还具备了不同的 <a href=https://man7.org/linux/man-pages/man7/capabilities.7.html>capabilities(7)</a> 权限。比如 u1001 用户进程 bash 通过 <code>unshare -r bash</code> 进入到了新的 userns，并将自己映射成了 root 用户，还具备了所有的 capabilities。但这个进程真的就变成了特权进程？这取决于该用户在系统资源所属的 userns 里是否拥有访问权限。</p><p><img loading=lazy src=/img/2023-containerd-17-userns/userns-root-mount-failed.png alt=userns-root-mount-failed></p><p>在介绍具体的判定规则前，先花点时间了解下内核是如何管理 UID/GID 的映射关系。</p><p>每个进程都必须归属于某一个 userns。在初始状态下，进程都属于 <a href=https://elixir.bootlin.com/linux/v6.1.15/source/kernel/user.c#L27>initial userns</a>。Initial userns 比较特殊，它没有任何映射关系；Linux 支持嵌套的 userns，所有正在使用的 userns 组成的关系图将会是以 initial userns 为根的树状图。在 parent userns 里的进程，只要具备 <a href=https://man7.org/linux/man-pages/man2/setuid.2.html>CAP_SET{UID,GID}</a> 能力，这些进程就可以通过 <code>/proc/[pid]/{uid,gid}_map</code> 文件接口，以 <code>ID-inside-ns ID-outside-ns Range-length</code> 的格式，给刚进入 child userns 的进程设置 UID/GID 映射关系，而创建该 userns 进程的 Effective UID(EUID) 将成为 userns 的所有者，如下图所示。</p><p><img loading=lazy src=/img/2023-containerd-17-userns/userns-idmapping-userspace-kernel.svg alt=userns-idmapping-between-userspace-kernel></p><p>在上图中，有两层 userns 映射关系：</p><ul><li><code>uid_map: 0 1001 10</code> 将 initial userns 的 UID <code>[1001, 1010]</code> 映射到 userns X 里的 UID <code>[0, 9]</code></li><li><code>uid_map: 10 0 5</code> 将 userns X 中的 UID <code>[0, 4]</code> 映射成 userns Y 里的 UID <code>[10, 14]</code>。</li></ul><p>但这些都是用户态的映射关系，<code>uid_map</code> 文件接口会将其转化成 <a href=https://elixir.bootlin.com/linux/v6.1.15/source/kernel/user_namespace.c#L1060>内核态的映射关系 <code>userspace-id:kernel-id:range(u:k:r)</code></a>，比如 <code>u1000:k0:r100</code> 映射关系可以把 <code>k10</code> 映射成 <code>u1010 = k10 - k0 + u1000</code>；同样的，<code>u1005</code> 可以转化为 <code>k5 = u1005 - u1000 + k0</code>，其中 <code>r100</code> 是用来判断映射是否超出范围。Initial userns 的 ID 映射关系是 <code>u0:k0:r4294967295</code>，相当于 <code>u</code> 等于 <code>k</code>。Userns X 的 parent userns 是 initial userns，结合 uid_map 的配置，内核态的映射关系应为 <code>u0:k1001:r10</code>；同理 Userns Y 的内核态映射关系是 <code>u10:k1001:r5</code>。在进行权限判断时，内核最终都以 kernel-id 为凭据。</p><p>回到最初的话题，为什么具备了所有 capabilities 还是不能进行 bind-mount？</p><p>Linux 的系统资源都归属于某一个 userns，比如 <a href=https://man7.org/linux/man-pages/man7/mount_namespaces.7.html>mount_namespace(7)</a> 下的挂载资源，<a href=https://man7.org/linux/man-pages/man7/network_namespaces.7.html>network_namespace(7)</a> 下的设备资源等等。当进程想要访问系统资源时，内核会采用下面的策略来决定进程是否有权 (为了方便解释，被访问的系统资源属于 userns X，而访问该系统资源的进程属于 userns Y)：</p><ul><li>在 initial userns 为根的树状关系里，当 userns X 是 userns Y 的祖先或者是兄弟分支，进程无权访问；</li><li>当 userns X 与 userns Y 相等或者 userns Y 是 userns X 的祖先时，只要进程具备资源要求的 capabilities 即可访问；</li><li>当 userns Y 是 userns X 的父节点，且当前进程的 EUID 为 userns X 的创建者，那么该进程可以访问 userns Y 下的所有系统资源。</li></ul><p>判断进程的 EUID 是否为 userns X 的所有者时，内核比较的是 kernel-id。上诉的判断来自 <a href=https://elixir.bootlin.com/linux/v6.1.15/source/security/commoncap.c#L51>cap_capable</a> 函数。大部分的权限判断都包着它来做，比如挂载权限的判断逻辑在 <a href=https://elixir.bootlin.com/linux/v6.1.15/source/fs/namespace.c#L1763>may_mount</a> 等，感兴趣的可以去看看。</p><p><img loading=lazy src=/img/2023-containerd-17-userns/userns-mountns-root-mount.png alt=userns-mountns-root-mount></p><p>如上图所示，虽然 unshare 切换了 userns，但 mount_namespace(mountns) 依然属于 parent userns。根据访问策略来看，当前进程无权访问祖先 userns 的资源，因此挂载失败。如果想要在不提权的情况下进行挂载，最好的方式就是 unshare 切换新的 mountns。全新的 mountns 将属于当前的 userns；当前进程具有 SYS_ADMIN 权限，所以它能进行挂载。</p><p>现在的容器默认会配置独立的 <a href=https://man7.org/linux/man-pages/man7/namespaces.7.html>mount/network/pid/ipc/uts_namespace(7)</a> 资源，没有的独立的 userns，这些系统资源依旧隶属于 initial userns。而大部分容器进程都以 root 用户身份启动，为了防止容器进程逃逸后对系统造成破坏，业界的普遍做法是限制容器进程的 capabilities，同时采用 SELinux/Apparmor 安全规则控制对系统资源的访问。但这毕竟都是后验形式，集群管理员需要对容器进程做大量的行为审计，他们才能得到有效的安全规则。但就目前的结果来看，现在依然有不少 initial userns 的权限泄漏所引发的安全问题。</p><p>既然全新的 userns 可以完全禁止进程访问隶属于 initial userns 的系统资源，那么为什么迟迟不落地呢？</p><h2 id=2-fsuid-映射问题>2. FSUID 映射问题<a hidden class=anchor aria-hidden=true href=#2-fsuid-映射问题>#</a></h2><p>在 Linux 系统里，一个进程有两个关键的身份凭证：一个是前面提到的 EUID，它用于做系统资源的权限判断；而另外一个是 Filesystem UID(FSUID)，它用来判断是否有权限访问文件目录。一般情况下只要不调用 <a href=https://man7.org/linux/man-pages/man2/setfsuid.2.html>setfsuid</a>，进程的 FSUID 都和 EUID 保持一致。</p><p>当进程在创建文件目录时，文件系统会将当前进程 FSUID 的映射结果写入到存储设备。当然，文件系统并不是持久化当前 userns 的映射结果。当进程挂载文件系统时，内核会将该进程所在的 userns <code>caller u:k:r</code> 映射关系作为对应文件系统的 <code>fs u:k:r</code> 映射关系。文件系统会将创建文件进程的 FSUID kernel-id 转化成 <code>fs u:k:r</code> 下的 userspace-id，这个 id 才是最终存储的结果。有了这个概念后，我们看下查看文件拥有者标识的过程。</p><p>假设用户 u1001 HOME 目录所在的文件系统采用了 <code>fs u0:k0:r4294967295</code> 映射，以及当前 stat 进程的 userns 也采用了同样的映射 <code>caller u0:k0:r4294967295</code>。文件系统先将存储设备里的 <code>u1001</code> 转化成 <code>k1001</code>，内核再通过当前进程的映射关系转化，最终得到我们所看到的 <code>u1001</code>。</p><p><img loading=lazy src=/img/2023-containerd-17-userns/initns-stat.png alt=initns-stat></p><p>让我们再看看把 u1001 映射成 root 用户后的显示效果，如下图所示。因为进程已经切换到了新的 userns，但 <code>.bashrc</code> 文件的存储没有发生变化，经过两次映射，我们最终看到的是 <code>u0</code>。原先 <code>/var/lib/containerd</code> 在存储设备里的 FSUID 是 <code>u0</code>，经过 <code>fs u0:k0:r4294967295</code> 映射后得到 <code>k0</code>，但 <code>k0</code> 并不在 <code>caller u0:k1001:r1</code> 的范围内。对于这些不在映射范围内的 UID，内核统一显示成 nobody(65534)。这也意味着，当前 root 用户依然无法访问 <code>/var/lib/containerd</code>。</p><p><img loading=lazy src=/img/2023-containerd-17-userns/userns-stat.png alt=userns-stat></p><p>回到容器的使用场景。首先，绝大多数的容器镜像是以 root 用户构建，这就要求容器进程的 FSUID 经过映射后要和存储对应的 FSUID 一致。为了方便解释，这里假设容器镜像的底层文件系统采用 initial userns 映射方式。如果容器进程采用 <code>caller r0:k1001:r1</code> 映射，那么它是无权访问镜像内容，它将无法启动。解决这个问题的方式，就是在启动容器前，我们通过 <code>chown -R</code> 把容器的根录都修改成 u1001。但这也意味着效率低下。</p><table><thead><tr><th>Image</th><th>Size</th><th>Inodes</th><th>overlayfs w/ metacopy</th><th>overlayfs w/o metacopy</th></tr></thead><tbody><tr><td>tensorflow/tensorflow:latest</td><td>1489MiB</td><td>32596</td><td>1.29s</td><td>54.80s</td></tr><tr><td>library/node:latest</td><td>1425MiB</td><td>33385</td><td>1.18s</td><td>52.86s</td></tr><tr><td>library/ubuntu:22.04</td><td>83.4MiB</td><td>3517</td><td>0.15s</td><td>5.32s</td></tr></tbody></table><p>当我们在修改容器根目录的文件属性时，如果没有 metacopy=on 的属性支持，那么 <code>chown -R</code> 在修改文件属性前，overlayfs 文件系统会将这个文件从只读层拷贝到可写层。如果文件越大，整个修改过程就越慢，同时还产生磁盘压力；带上 metacopy=on 之后，至少 overlayfs 仅拷贝文件的 metadata，效率高不少。但面对小文件特别多的场景，<code>chown -R</code> 操作依旧很耗时。与此同时， <code>chown</code> 还是永久性修改文件属性。</p><p>然而不同容器之间可能会共享同一个数据卷。常见的场景有：容器 A 以 <code>caller r0:k1001:r1</code> 映射关系产生数据，然后容器 B 再进行分析消费。这就要求容器 B 也必须使用 <code>r0:k1001:r1</code> 映射关系，否则只能再次使用 <code>chown</code> 来切换。</p><p>在全民白嫖镜像仓库的形势下，镜像仓库已经变成 <code>免费数据</code> 仓库。个人见过上百 GiB 的容器镜像，在这种容器镜像面前使用 <code>chown</code>，这简直是劝退。</p><h2 id=3-mount-idmapped-特性--kernel-v512>3. Mount idmapped 特性 >= kernel v5.12<a hidden class=anchor aria-hidden=true href=#3-mount-idmapped-特性--kernel-v512>#</a></h2><p>为了解决这个映射的难题，<a href=https://github.com/torvalds/linux/commit/7d6beb71da3cc033649d641e1e608713b8220290>Linux v5.12 版本</a> 引入了挂载点的映射关系 <code>mount u:k:r</code>，用户可以通过它来绕过文件系统原先的 <code>fs u:k:r</code> 映射，其中该特性由 <a href=https://man7.org/linux/man-pages/man2/mount_setattr.2.html>mount_setattr(2)</a> 系统调用提供。我们直接看例子解释吧，如下图所示。</p><p><img loading=lazy src=/img/2023-containerd-17-userns/mount-idmapped-bind.png alt=mount-idmapped-bind></p><p><a href=https://github.com/brauner/mount-idmapped>mount-idmapped</a> 工具把 <code>/var/lib/containerd</code> 挂载到 <code>/mnt</code> 下，并通过 <code>mount u0:k1001:r1</code> 映射关系将其 <code>授权</code> 给 u1001 用户进程访问，u1001 用户无需提权就可以在 <code>/mnt</code> 下访问 <code>/var/lib/containerd</code> 的数据。挂载点 <code>/mnt</code> 上的 <code>mount u0:k1001:r1</code> 映射关系是替代了原先的 <code>fs u0:k0:r4294967295</code>。只是底层文件系统 inode 保存的是 <code>fs u:k:r</code> 映射后的 kernel-id；而 <code>mount u:k:r</code> 由 Virtual filesystem(vfs) 模块管理，vfs 拿不到存储设备上保存的 userspace-id，所以 vfs 需要利用 <code>fs u:k:r</code> 转化回来。这也就是上图里，<code>u0 -> k0 -> u0</code> 转化看似无效，但它其实是真实的处理流程。</p><p>如果 u1001 用户进程在 <code>/mnt</code> 目录里进行写操作，通过上图的映射关系，新文件的 FSUID 最终将以 <code>u0</code> 落盘。</p><p><img loading=lazy src=/img/2023-containerd-17-userns/mount-idmapped-bind-write.png alt=mount-idmapped-bind-write></p><p>无论多大的文件目录，该内核特性都可以很快完成 FSUID 映射，还可以同时支持多个 <code>mount u:k:r</code> 映射，也解决了数据卷共享问题。我想这就是为什么社区开始推进 userns 落地的原因吧。</p><h2 id=4-containerd-目前的集成情况>4. containerd 目前的集成情况<a hidden class=anchor aria-hidden=true href=#4-containerd-目前的集成情况>#</a></h2><p>为了支持 userns，containerd 对 CRI RunPodSandbox 的流程有比较大的改动，但这仅针对 userns 场景的 Pod，其他场景和之前保持一致。</p><h3 id=41-依旧使用-chown-修改容器根目录>4.1 依旧使用 chown 修改容器根目录<a hidden class=anchor aria-hidden=true href=#41-依旧使用-chown-修改容器根目录>#</a></h3><p>containerd 并没有使用 mount_setattr 特性，目前还是使用 chown 的形式。为了减少不必要的 chown 操作，containerd 将首次 chown 之后的容器根目录做成只读 snapshot，而对于后续使用相同镜像以及相同 uid_map 的容器而言，containerd 可以直接用现成的 snapshot 做根目录。也算是一个优化吧。</p><p>没有集成 mount idmapped 的主要原因在于，它对 containerd 现有的 mount 挂载流程影响比较大。</p><p><a href=https://lore.kernel.org/all/20220407112157.1775081-1-brauner@kernel.org/>Linux v5.19</a> overlayfs 文件系统开始支持 mount idmapped，但它是针对只读层设计，用户无法对一个已挂载好的 overlayfs 文件系统进行 mount idmapped，毕竟 overlayfs 并没有像 ext4/xfs/btrfs 那样拥有 <code>FS_ALLOW_IDMAP</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// https://elixir.bootlin.com/linux/v6.1.15/source/fs/namespace.c#L3979
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>int</span> <span class=nf>can_idmap_mount</span><span class=p>(</span><span class=k>const</span> <span class=k>struct</span> <span class=n>mount_kattr</span> <span class=o>*</span><span class=n>kattr</span><span class=p>,</span> <span class=k>struct</span> <span class=n>mount</span> <span class=o>*</span><span class=n>mnt</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* The underlying filesystem doesn&#39;t support idmapped mounts yet. */</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>m</span><span class=o>-&gt;</span><span class=n>mnt_sb</span><span class=o>-&gt;</span><span class=n>s_type</span><span class=o>-&gt;</span><span class=n>fs_flags</span> <span class=o>&amp;</span> <span class=n>FS_ALLOW_IDMAP</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>为此，我们需要将容器镜像的只读层挨个进行 mount idmapped，最后再挂载成 overlayfs。或者是将容器镜像直接解压到已经 mount idmapped 好的挂载点上。但后者对现有 containerd snapshot 管理有比较大的冲击，前者看起来会更容易落地些。</p><p>值得一提的是，新版本内核已经演进出了新的 mount API: fsopen(2)/fsconfig(2)/fsmount(2) 将文件系统挂载拆成多次系统调用，而且 fsmount(2) 仅是生成 <code>anonymous mount</code> 记录，需要 move_mount(2) 将其转化成可见的挂载点。而普通的 bind mount 将由 open_tree(2) 来产生 <code>anonymouns mount</code>。</p><p>mount_setattr 有一个要求就是必须是 anonymouns mount。但除了 fsopen，fsconfig/fsmount/open_tree 都没进入 <code>golang.org/x/sys/unix</code>。整体来看，mount_setattr 在 containerd 上落下来可能还需要几个月的时间。</p><h3 id=42-延后网络初始化>4.2 延后网络初始化<a hidden class=anchor aria-hidden=true href=#42-延后网络初始化>#</a></h3><p>早期 dockerd 的容器网络初始化是在 runC 进入 init 阶段后，runC 通过 <a href="https://github.com/opencontainers/runtime-spec/blob/58ec43f9fc39e0db229b653ae98295bfde74aeab/config.md?plain=1#L478">prestart_hook</a> 回调通知 dockerd， dockerd 再通过 <a href=https://man7.org/linux/man-pages/man2/setns.2.html>setns(2)</a> 进入到容器 network namespace(netns) 进行配置。</p><p>同样，kubelet 在处理 dockershim 的网络时，它也是等待 pause 容器启动后，并通过 <code>/proc/[pause-pid]/ns/net</code> 来进行 CNI 调用。但这里有一个很大的问题就是，一旦 pause 容器进程被意外杀死，同时原先 pause 容器进程 pid 被复用，那么 CNI 将会在错误的 netns 里进行操作。运气不好的话，CNI 可能会操作到 initial userns 下的 netns，造成整机的网络中断。</p><p>而 containerd CRI 当前的设计可以避免 pid 复用所引发的问题。在启动 pause 容器前，containerd 会提前准备好 netns，并将其持久化到 <code>/run/netns</code> 之下。这个行为和 <code>ip netns add</code> 行为一致，如下图所示。CNI 初始化完毕后，containerd 才将持久化后的 netns 地址交给 runC。这完全避免了 pid 复用的问题。</p><p><img loading=lazy src=/img/2023-containerd-17-userns/ip-netns-add.png alt=ip-netns-add></p><p>但这个不适用于 userns 场景，因为 containerd 创建的出来 netns 属于 initial userns，而且它还挂载在属于 initial userns 的 mountns 里。新的 userns 无法操作 netns 下的资源，同时因为 netns 归属问题，<a href=https://github.com/torvalds/linux/commit/7dc5dbc879bd0779924b5132a48b731a0bc04a1e#diff-4839664cd0c8eab716e064323c7cd71fR1164>还导致 runC 无法将 <code>/sys/</code> 挂载容器根目录</a>。</p><p>解决这个问题的唯一途径就是让 runC 创建 netns。为了防止出现 pid 复用问题，在 runC init 阶段结束后，containerd 将 <code>/proc/[pause-pid]/ns/net</code> 持久化到 <code>/run/netns</code> 之下，然后再判断 runC init 进程是否还处于运行状态，避免出现 datarace 的情况。</p><p>为了避免对现有容器运行时集成的影响，这个处理逻辑仅针对使用 userns 的容器，原先支持的场景不受影响。</p><h2 id=5-最后>5. 最后<a hidden class=anchor aria-hidden=true href=#5-最后>#</a></h2><p>目前该特性距离上生产还有很长的路要走，下图是 Kubernetes SIG-Node 之前讨论过<a href="https://docs.google.com/presentation/d/1z4oiZ7v4DjWpZQI2kbFbI8Q6botFaA07KJYaKA-vZpg/edit#slide=id.gfd10976c8b_1_41">规划</a>。除此之外，还得看用户侧是否实时跟进新内核，以及各大 Linux 发行版商是否会及时 backport 新版本特性。</p><p><img loading=lazy src=/img/2023-containerd-17-userns/kep-roadmap.png alt=kep-roadmap></p><p>个人倒是很喜欢这个特性，因为 userns 几乎可以让容器进程更好地享受隔离特性，减少 seccomp 这些作用不大但影响性能的配置干扰。说到这，我想起前同事做过的镜像构建项目，因为安全问题，管理员迟迟不愿意开放 mount 挂载权限。如果这个特性能推广，应该能减少很多不必要的会了吧。。。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://fuweid.com/post/2022-go-unshare-clonefs/><span class=title>Next »</span><br><span>使用 unshare(CLONE_FS) 来优化 OverlayFS 挂载</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://fuweid.com/>fuweid</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>