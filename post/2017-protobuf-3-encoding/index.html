<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Protobuf 3.0 编码 | fuweid</title><meta name=keywords content><meta name=description content="Protobuf 3.0 编码规则初探"><meta name=author content><link rel=canonical href=https://fuweid.com/post/2017-protobuf-3-encoding/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://fuweid.com/favicon.jpg><link rel=icon type=image/png sizes=16x16 href=https://fuweid.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fuweid.com/favicon-32x32.png><link rel=apple-touch-icon href=https://fuweid.com/apple-touch-icon.png><link rel=mask-icon href=https://fuweid.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-1C7VLVHN52"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1C7VLVHN52",{anonymize_ip:!1})}</script><meta property="og:title" content="Protobuf 3.0 编码"><meta property="og:description" content="Protobuf 3.0 编码规则初探"><meta property="og:type" content="article"><meta property="og:url" content="https://fuweid.com/post/2017-protobuf-3-encoding/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-11-15T00:00:00+00:00"><meta property="article:modified_time" content="2017-11-15T00:00:00+00:00"><meta property="og:site_name" content="fuweid"><meta name=twitter:card content="summary"><meta name=twitter:title content="Protobuf 3.0 编码"><meta name=twitter:description content="Protobuf 3.0 编码规则初探"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fuweid.com/post/"},{"@type":"ListItem","position":2,"name":"Protobuf 3.0 编码","item":"https://fuweid.com/post/2017-protobuf-3-encoding/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Protobuf 3.0 编码","name":"Protobuf 3.0 编码","description":"Protobuf 3.0 编码规则初探","keywords":[],"articleBody":"Protobuf 是 G 厂开源的序列化数据的方法，可用来通信或者存储数据。它采用 IDL 描述数据接口，使得不同语言编写的程序可以根据同一接口通信。不同编程语言也可以根据 IDL 的描述来生成对应数据结构，该数据结构用来编解码。为此，G 厂为主流开发语言都提供代码生成器（即 protoc ）。\n为了更好地了解一些细节，本文将主要描述 Protobuf 3.0 的编码规则。 Protobuf 里面主要采用 Varint 和 Zig-Zag 的方式来对整型数字进行编码。在理解 Protobuf 之前，需要先了解这两种编码方式。\nProtobuf 采用是 Little Endian 的方式编码。\n1. Varints int64, int32, uint64, uint32 都有固定的二进制位数。\n如果将这些数字序列化成二进制流的时候，需要额外空间告知接收方数据的长度。对于采用 int64, uint64 这两种类型的数据而言，如果大部分时间都只是使用较小的数值，那么会极大地浪费传输带宽和存储空间。针对这两个问题，Protobuf 采用 Varints 的编码方式。\nVarints 将源数据按照 7 bit 分组，每 7 bit 加 MSB (Most Significant Bit) 标识位来组成一个字节，其中 MSB 标识位用来判断是否存在后序分组。如果出现多组的情况，那么低有效位比特组优先。\n64 有效位为 7 bit，不需要额外的字节，所以 MSB 比特位为 0。\n64 = 0100 0000 =\u003e 0100 0000 16657 有效位为 15 bit，需要分成三组字节，前两组字节为了提示还存在后续字节，所以前两组字节的 MSB 比特位为 1。\n16657 = 0100 0001 0001 0001 =\u003e 001 0001 ++ 000 0010 ++ 000 0001 (reverse the groups of 7 bits) =\u003e 1001 0001 1000 0010 0000 0001 =\u003e 0x91 0x82 0x01 由于负数的最高有效位为 1，int32 类型的负数固定需要 5 字节，而 int64 的负数需要 10 字节，基本上告别了空间效益。所以 Varints 在编码负数时，需要引入 Zig-Zag 编码解决压缩问题。\n2. Zig-Zag Signed Original Encoded As 0 0 -1 1 1 2 -2 3 2 4 2147483647 4294967294 -2147483648 4294967295 Zig-Zag 编码可以将负数转化成正数，如上表所示。根据上述表格可以很快地得出结论，负数 n 编码后的值为 2 * abs(n) - 1，而正数，编码后为 2 * n。\n实际上，Zig-Zag 会采用以下方式来进行编解码。为了简单起见，接下来将使用 int8 类型分析 Zig-Zag 编解码。\nencode(n): int64 =\u003e (n \u003c\u003c 1) ^ (n \u003e\u003e 63) int32 =\u003e (n \u003c\u003c 1) ^ (n \u003e\u003e 31) int64 =\u003e (n \u003c\u003c 1) ^ (n \u003e\u003e 15) int8 =\u003e (n \u003c\u003c 1) ^ (n \u003e\u003e 7) decode(n): (n \u003e\u003e\u003e 1) ^ - (n \u0026 1) NOTE: \u003c\u003c, \u003e\u003e Arithmetic Shift \u003e\u003e\u003e Logical Shift 2.1 Encode Zig-Zag 会将最高符号位算数位移到 LSB（Least significant bit）。\npositive: (n \u003e\u003e 7) =\u003e 0x00 negative: (n \u003e\u003e 7) =\u003e 0xFF 任何数值与 0x00 异或都等到本身，而与 0xFF 异或会现成按位取反。 根据补码互补的原理，一个数 A 与 0xFF 异或就变成 -A - 1。\nA ^ 0xFF = ~A = -A - 1 因此，负数经过运算之后变成 - 2 * n - 1。而正数经过运算只是简单扩大两倍而已，将会 2 * n。\n-2 =\u003e 3 1111 1100 (1111 1110 \u003c\u003c 1) ^ 1111 1111 (1111 1110 \u003e\u003e 7) ----------------- 0000 0011 (-2 \u003c\u003c 1) ^ (-2 \u003e\u003e 7) 2.2 Decode Zig-Zag 编码的时候将最高符号位移位到了 LSB，解码的时候需要还原到 MSB。\npositive: - (n \u0026 1) = 0 =\u003e 0x00 negative: - (n \u0026 1) = -1 =\u003e 0xFF n \u003e\u003e\u003e 1 逻辑右移的过程相当于做了除以 2 的操作，所有奇数的逻辑右移都可以得到 n / 2 = (n - 1)/2，根据解码的表达式可以得到以下推断。\nn \u0026 1 == 0: (n \u003e\u003e\u003e 1) ^ -(n \u0026 1) = (n \u003e\u003e\u003e 1) = n / 2 n \u0026 1 == 1: (n \u003e\u003e\u003e 1) ^ -(n \u0026 1) = ~(n \u003e\u003e\u003e 1) = - (n \u003e\u003e\u003e 1) - 1 = - (n + 1) / 2 255 解码之后的结果为 -128。如果解码过程是通过先加后除的方式，将会出现溢出错误。\n255 =\u003e -128 0111 1111 (1111 1111 \u003e\u003e\u003e 1) ^ 1111 1111 (-(1111 1111 \u0026 1)) ----------------- 1000 0000 (255 \u003e\u003e\u003e 1) ^ -(255 \u0026 1) Protobuf 在编码负数的时候，它提供了 Zig-Zag 编码的可能，可在此基础上在使用 Varints 来达到压缩效果。\n3. Message message Simple { // // _ declared type // / _ field name // / / _ field number, alias tag // / / / int64 o_int64 = 16; } Protobuf Message 是一系列的 Key-Value 二进制数据流。在编码过程中，仅仅使用 field number 和 wire type 为 Key，而 declared type 和 field name 会辅助解码来判断数据的具体类型，其中 wire type 有以下几种类型。\nWire Type Meaning Used For 0 Varint int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 64-bit fixed64, sfixed64, double 2 Length-delimited string, bytes, embedded messages, packed repeated fields 3 Start Group groups (deprecated) 4 End Group groups (deprecated) 5 32-bit fixed32, sfixed64, float 每一个 Key 都是 (field number \u003c\u003c 3 | wire type) 的 Varint 编码值。\n现在按照 Simple 的约定发送来以下数据。接下来，我们将作为人工解码器来分析这份数据。\n80 01 96 01 首先 Protobuf Message 编码之后是一系列的 Key-Value，因此首字节属于 Key 的一部分。Key 首字节 80 的 MSB 标志位为 1，说明 Key 除了 80 外还有后序字节。根据上文 Varints 的介绍，可以得到 Key 中 field number(16) 和 wire type(0)。\n80 01 1000 0000 0000 0001 =\u003e 000 0000 ++ 000 0001 (drop the msb) =\u003e 1000 0000 (reverse the groups of 7 bits) =\u003e (0001 0000 \u003c\u003c 3) | 0 按照同样方式，Value 数据为 96 01。经过 Varints 解码后为 150，所以 80 01 96 01 代表着 Simple.o_int64 = 150。\n96 01 1001 0110 0000 0001 =\u003e 001 0110 ++ 000 0001 (drop the msb) =\u003e 1001 0110 (reverse the groups of 7 bits) =\u003e 128 + 16 + 4 + 2 = 150 4. Wire Type 4.1 Varint - sint32/sint64 对于负数而言，前序比特 1 不能带来压缩上效益，所以 Protobuf 提供 sint32，sint64 类型来使用 Zig-Zag 提高压缩率。\n4.2 32-bit / 64-bit 这两部分 wire type 会使用固定长度去传输数据，其中 64-bit 采用 8 字节传输，而 32-bit 采用 4 字节传输。\n4.3 Length-delimited Length-delimited 会引入 payload size 来辅助说明后序字节数，其中 payload size 的编码采用 Varints 。\nstrings/bytes message SimpleString { string o_string = 1; } 将 o_string 设置成 Hello, world!，会得到以下数据。\n0A 0D 48 65 6C 6C 6F 2C 20 77 6F 72 6C 64 21 Key 0A 可以推断出 field number(1) 和 wire type(2)。payload size(0D) 解码之后为 13 ，后序 13 个字节将代表 o_string。\nembedded messages message SimpleEmbedded { Simple o_embedded = 1; } 将 o_embedded.o_int64 设置成 150，会得到以下数据。\n0A 04 80 01 96 01 Key 0A 可以推断出 field number(1) 和 wire type(2)。payload size(04) 解码之后为 4 ，后序 4 个字节将代表 o_embedded。整个过程基本和 SimpleString 一致，只不过 o_embedded 还需要进一步的解码。\npacked repeated fields Protobuf 3.0 对于 repeated field 默认都采用了 packed 的形式。不过在介绍 packed 特性前，有必要说明一下 unpacked 的编码结构。\nmessage SimpleInt64 { int64 o_int64 = 1; } message SimpleUnpacked { repeated int64 o_ids = 1 [packed = false]; } message SimplePacked { repeated int64 o_ids = 1; } 将 SimpleUnpacked.o_ids 设置成 1,2 数组，会得到以下数据。\n08 01 08 02 08 // field number = 1, wire type = 0 01 // value = 1 08 // field number = 1, wire type = 0 02 // value = 2 Protobuf 编码 unpacked repeated fields 时，并不会将 repeated fields 看成是一个整体，而是单独编码每一个元素。所以在解码 unpacked repeated fileds 时，需要将相同 field number 的数据合并到一起。\n从另外一个角度看，Protobuf 允许将相同 Key 的数据合并到一起。08 01 08 02 数据可以看成是 SimpleInt64.o_int64 = 1 和 SimpleInt64.o_int64 = 2 编码合并的结果。\n让我们来看看 packed repeated fields 编码结果。同样将 SimplePacked.o_ids 设置成 1,2 数组，却得到不同的数据，因为 Protobuf 编码时将 o_ids 看成是一个整体。\n0A 02 01 02 0A // field number = 1, wire type = 2 02 // payload size = 2 01 // first elem = 1 02 // second elem = 2 Protobuf 3.0 packed 的行为仅仅支持基础数据类型，即 Varint/64-bit/32-bit 三种 wire type。\npacked 和 unpacked 编码面对长度为 0 的数据时，它并不会输出任何二进制数据。\n个人认为基础数据类型所占用字节数少，整体字节数相对可控，引入 payload size 能带来压缩效益。一旦使用 embedded message 之后，每一个元素的大小将不可控，可能只有少量元素，但是整体字节数将会很大，payload size 需要大量的字节表示。面对这种场景，unpacked repeated fields 单独编码的方式会带来压缩效益，即使包含了重复的 Key 信息。\n5. Start Group/End Group 由于 Protobuf 放弃使用 Start Group 和 End Group，在此也不再介绍。\n6. Reference Protocol Buffers Encoding ","wordCount":"969","inLanguage":"en","datePublished":"2017-11-15T00:00:00Z","dateModified":"2017-11-15T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://fuweid.com/post/2017-protobuf-3-encoding/"},"publisher":{"@type":"Organization","name":"fuweid","logo":{"@type":"ImageObject","url":"https://fuweid.com/favicon.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fuweid.com/ accesskey=h title="fuweid.com (Alt + H)">fuweid.com</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fuweid.com/>Home</a>&nbsp;»&nbsp;<a href=https://fuweid.com/post/>Posts</a></div><h1 class=post-title>Protobuf 3.0 编码</h1><div class=post-description>Protobuf 3.0 编码规则初探</div><div class=post-meta><span title='2017-11-15 00:00:00 +0000 UTC'>November 15, 2017</span></div></header><div class=post-content><p>Protobuf 是 G 厂开源的序列化数据的方法，可用来通信或者存储数据。它采用 IDL 描述数据接口，使得不同语言编写的程序可以根据同一接口通信。不同编程语言也可以根据 IDL 的描述来生成对应数据结构，该数据结构用来编解码。为此，G 厂为主流开发语言都提供代码生成器（即 protoc ）。</p><p>为了更好地了解一些细节，本文将主要描述 Protobuf 3.0 的编码规则。
Protobuf 里面主要采用 Varint 和 Zig-Zag 的方式来对整型数字进行编码。在理解 Protobuf 之前，需要先了解这两种编码方式。</p><blockquote><p>Protobuf 采用是 Little Endian 的方式编码。</p></blockquote><h3 id=1-varints>1. Varints<a hidden class=anchor aria-hidden=true href=#1-varints>#</a></h3><p>int64, int32, uint64, uint32 都有固定的二进制位数。</p><p>如果将这些数字序列化成二进制流的时候，需要额外空间告知接收方数据的长度。对于采用 int64, uint64 这两种类型的数据而言，如果大部分时间都只是使用较小的数值，那么会极大地浪费传输带宽和存储空间。针对这两个问题，Protobuf 采用 Varints 的编码方式。</p><p>Varints 将源数据按照 <strong>7 bit</strong> 分组，每 <strong>7 bit</strong> 加 <strong>MSB (Most Significant Bit)</strong> 标识位来组成一个字节，其中 MSB 标识位用来判断是否存在后序分组。如果出现多组的情况，那么低有效位比特组优先。</p><p>64 有效位为 7 bit，不需要额外的字节，所以 MSB 比特位为 0。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>64 = 0100 0000
</span></span><span class=line><span class=cl>  =&gt; 0100 0000
</span></span></code></pre></div><p>16657 有效位为 15 bit，需要分成三组字节，前两组字节为了提示还存在后续字节，所以前两组字节的 MSB 比特位为 1。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>16657 = 0100 0001 0001 0001
</span></span><span class=line><span class=cl>  =&gt;  001 0001 ++ 000 0010 ++ 000 0001 (reverse the groups of 7 bits)
</span></span><span class=line><span class=cl>  =&gt;  1001 0001 1000 0010 0000 0001
</span></span><span class=line><span class=cl>  =&gt;  0x91 0x82 0x01
</span></span></code></pre></div><p>由于负数的最高有效位为 1，int32 类型的负数固定需要 5 字节，而 int64 的负数需要 10 字节，基本上告别了空间效益。所以 Varints 在编码负数时，需要引入 Zig-Zag 编码解决压缩问题。</p><h3 id=2-zig-zag>2. Zig-Zag<a hidden class=anchor aria-hidden=true href=#2-zig-zag>#</a></h3><table><thead><tr><th style=text-align:center>Signed Original</th><th style=text-align:center>Encoded As</th></tr></thead><tbody><tr><td style=text-align:center>0</td><td style=text-align:center>0</td></tr><tr><td style=text-align:center>-1</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>2</td></tr><tr><td style=text-align:center>-2</td><td style=text-align:center>3</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>4</td></tr><tr><td style=text-align:center>2147483647</td><td style=text-align:center>4294967294</td></tr><tr><td style=text-align:center>-2147483648</td><td style=text-align:center>4294967295</td></tr></tbody></table><p>Zig-Zag 编码可以将负数转化成正数，如上表所示。根据上述表格可以很快地得出结论，负数 <code>n</code> 编码后的值为 <code>2 * abs(n) - 1</code>，而正数，编码后为 <code>2 * n</code>。</p><p>实际上，Zig-Zag 会采用以下方式来进行编解码。为了简单起见，接下来将使用 <strong>int8</strong> 类型分析 Zig-Zag 编解码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>encode(n):
</span></span><span class=line><span class=cl>  int64 =&gt; (n &lt;&lt; 1) ^ (n &gt;&gt; 63)
</span></span><span class=line><span class=cl>  int32 =&gt; (n &lt;&lt; 1) ^ (n &gt;&gt; 31)
</span></span><span class=line><span class=cl>  int64 =&gt; (n &lt;&lt; 1) ^ (n &gt;&gt; 15)
</span></span><span class=line><span class=cl>  int8  =&gt; (n &lt;&lt; 1) ^ (n &gt;&gt; 7)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>decode(n): 
</span></span><span class=line><span class=cl>  (n &gt;&gt;&gt; 1) ^ - (n &amp; 1)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>NOTE: 
</span></span><span class=line><span class=cl>  &lt;&lt;, &gt;&gt; Arithmetic Shift
</span></span><span class=line><span class=cl>  &gt;&gt;&gt;       Logical Shift
</span></span></code></pre></div><h4 id=21-encode>2.1 Encode<a hidden class=anchor aria-hidden=true href=#21-encode>#</a></h4><p>Zig-Zag 会将最高符号位算数位移到 <strong>LSB（Least significant bit）</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>positive: (n &gt;&gt; 7) =&gt; 0x00
</span></span><span class=line><span class=cl>negative: (n &gt;&gt; 7) =&gt; 0xFF
</span></span></code></pre></div><p>任何数值与 <code>0x00</code> 异或都等到本身，而与 <code>0xFF</code> 异或会现成按位取反。
根据补码互补的原理，一个数 <code>A</code> 与 <code>0xFF</code> 异或就变成 <code>-A - 1</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>A ^ 0xFF = ~A = -A - 1
</span></span></code></pre></div><p>因此，负数经过运算之后变成 <code>- 2 * n - 1</code>。而正数经过运算只是简单扩大两倍而已，将会 <code>2 * n</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>-2 =&gt; 3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  1111 1100 (1111 1110 &lt;&lt; 1)
</span></span><span class=line><span class=cl>^ 1111 1111 (1111 1110 &gt;&gt; 7)
</span></span><span class=line><span class=cl>-----------------
</span></span><span class=line><span class=cl>  0000 0011 (-2 &lt;&lt; 1) ^ (-2 &gt;&gt; 7)
</span></span></code></pre></div><h4 id=22-decode>2.2 Decode<a hidden class=anchor aria-hidden=true href=#22-decode>#</a></h4><p>Zig-Zag 编码的时候将最高符号位移位到了 LSB，解码的时候需要还原到 MSB。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>positive: - (n &amp; 1) = 0  =&gt; 0x00
</span></span><span class=line><span class=cl>negative: - (n &amp; 1) = -1 =&gt; 0xFF
</span></span></code></pre></div><p><code>n >>> 1</code> 逻辑右移的过程相当于做了除以 2 的操作，所有奇数的逻辑右移都可以得到 <code>n / 2 = (n - 1)/2</code>，根据解码的表达式可以得到以下推断。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>n &amp; 1 == 0:
</span></span><span class=line><span class=cl>  (n &gt;&gt;&gt; 1) ^ -(n &amp; 1) = (n &gt;&gt;&gt; 1) = n / 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>n &amp; 1 == 1:
</span></span><span class=line><span class=cl>  (n &gt;&gt;&gt; 1) ^ -(n &amp; 1) = ~(n &gt;&gt;&gt; 1) = - (n &gt;&gt;&gt; 1) - 1 = - (n + 1) / 2
</span></span></code></pre></div><p><code>255</code> 解码之后的结果为 <code>-128</code>。如果解码过程是通过先加后除的方式，将会出现溢出错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>255 =&gt; -128
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  0111 1111 (1111 1111 &gt;&gt;&gt; 1)
</span></span><span class=line><span class=cl>^ 1111 1111 (-(1111 1111 &amp; 1))
</span></span><span class=line><span class=cl>-----------------
</span></span><span class=line><span class=cl>  1000 0000 (255 &gt;&gt;&gt; 1) ^ -(255 &amp; 1)
</span></span></code></pre></div><p>Protobuf 在编码负数的时候，它提供了 Zig-Zag 编码的可能，可在此基础上在使用 Varints 来达到压缩效果。</p><h3 id=3-message>3. Message<a hidden class=anchor aria-hidden=true href=#3-message>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>message Simple {
</span></span><span class=line><span class=cl>  //
</span></span><span class=line><span class=cl>  //     _ declared type
</span></span><span class=line><span class=cl>  //    /      _ field name
</span></span><span class=line><span class=cl>  //   /      /     _ field number, alias tag
</span></span><span class=line><span class=cl>  //  /      /     /
</span></span><span class=line><span class=cl>  int64 o_int64 = 16;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>Protobuf Message 是一系列的 Key-Value 二进制数据流。在编码过程中，仅仅使用 <strong>field number</strong> 和 <strong>wire type</strong> 为 Key，而 <strong>declared type</strong> 和 <strong>field name</strong> 会辅助解码来判断数据的具体类型，其中 wire type 有以下几种类型。</p><table><thead><tr><th style=text-align:center>Wire Type</th><th style=text-align:center>Meaning</th><th style=text-align:center>Used For</th></tr></thead><tbody><tr><td style=text-align:center>0</td><td style=text-align:center>Varint</td><td style=text-align:center>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>64-bit</td><td style=text-align:center>fixed64, sfixed64, double</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>Length-delimited</td><td style=text-align:center>string, bytes, embedded messages, packed repeated fields</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>Start Group</td><td style=text-align:center>groups (deprecated)</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>End Group</td><td style=text-align:center>groups (deprecated)</td></tr><tr><td style=text-align:center>5</td><td style=text-align:center>32-bit</td><td style=text-align:center>fixed32, sfixed64, float</td></tr></tbody></table><p>每一个 Key 都是 <code>(field number &lt;&lt; 3 | wire type)</code> 的 Varint 编码值。</p><p>现在按照 Simple 的约定发送来以下数据。接下来，我们将作为人工解码器来分析这份数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>80 01 96 01
</span></span></code></pre></div><p>首先 Protobuf Message 编码之后是一系列的 Key-Value，因此首字节属于 Key 的一部分。Key 首字节 <code>80</code> 的 MSB 标志位为 1，说明 Key 除了 <code>80</code> 外还有后序字节。根据上文 Varints 的介绍，可以得到 Key 中 field number(<code>16</code>) 和 wire type(<code>0</code>)。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>80 01
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1000 0000 0000 0001
</span></span><span class=line><span class=cl>   =&gt; 000 0000 ++ 000 0001  (drop the msb)
</span></span><span class=line><span class=cl>   =&gt; 1000 0000             (reverse the groups of 7 bits)
</span></span><span class=line><span class=cl>   =&gt; (0001 0000 &lt;&lt; 3) | 0
</span></span></code></pre></div><p>按照同样方式，Value 数据为 <code>96 01</code>。经过 Varints 解码后为 150，所以 <code>80 01 96 01</code> 代表着 <code>Simple.o_int64 = 150</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>96 01
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1001 0110 0000 0001
</span></span><span class=line><span class=cl>  =&gt; 001 0110 ++ 000 0001    (drop the msb)
</span></span><span class=line><span class=cl>  =&gt; 1001 0110               (reverse the groups of 7 bits)
</span></span><span class=line><span class=cl>  =&gt; 128 + 16 + 4 + 2 = 150
</span></span></code></pre></div><h3 id=4-wire-type>4. Wire Type<a hidden class=anchor aria-hidden=true href=#4-wire-type>#</a></h3><h4 id=41-varint---sint32sint64>4.1 Varint - sint32/sint64<a hidden class=anchor aria-hidden=true href=#41-varint---sint32sint64>#</a></h4><p>对于负数而言，前序比特 1 不能带来压缩上效益，所以 Protobuf 提供 <code>sint32</code>，<code>sint64</code> 类型来使用 Zig-Zag 提高压缩率。</p><h4 id=42-32-bit--64-bit>4.2 32-bit / 64-bit<a hidden class=anchor aria-hidden=true href=#42-32-bit--64-bit>#</a></h4><p>这两部分 wire type 会使用固定长度去传输数据，其中 <code>64-bit</code> 采用 8 字节传输，而 <code>32-bit</code> 采用 4 字节传输。</p><h4 id=43-length-delimited>4.3 Length-delimited<a hidden class=anchor aria-hidden=true href=#43-length-delimited>#</a></h4><p>Length-delimited 会引入 <strong>payload size</strong> 来辅助说明后序字节数，其中 <strong>payload size</strong> 的编码采用 Varints 。</p><ul><li>strings/bytes</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>message SimpleString {
</span></span><span class=line><span class=cl>  string o_string = 1;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>将 <code>o_string</code> 设置成 <code>Hello, world!</code>，会得到以下数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0A 0D 48 65 6C 6C 6F 2C 20 77 6F 72 6C 64 21
</span></span></code></pre></div><p>Key <code>0A</code> 可以推断出 field number(<code>1</code>) 和 wire type(<code>2</code>)。payload size(<code>0D</code>) 解码之后为 13 ，后序 13 个字节将代表 <code>o_string</code>。</p><ul><li>embedded messages</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>message SimpleEmbedded {
</span></span><span class=line><span class=cl>  Simple o_embedded = 1; 
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>将 <code>o_embedded.o_int64</code> 设置成 150，会得到以下数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0A 04 80 01 96 01
</span></span></code></pre></div><p>Key <code>0A</code> 可以推断出 field number(<code>1</code>) 和 wire type(<code>2</code>)。payload size(<code>04</code>) 解码之后为 4 ，后序 4 个字节将代表 <code>o_embedded</code>。整个过程基本和 SimpleString 一致，只不过 <code>o_embedded</code> 还需要进一步的解码。</p><ul><li>packed repeated fields</li></ul><p>Protobuf 3.0 对于 repeated field 默认都采用了 packed 的形式。不过在介绍 packed 特性前，有必要说明一下 unpacked 的编码结构。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>message SimpleInt64 {
</span></span><span class=line><span class=cl>  int64 o_int64 = 1;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>message SimpleUnpacked {
</span></span><span class=line><span class=cl>  repeated int64 o_ids = 1 [packed = false];
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>message SimplePacked {
</span></span><span class=line><span class=cl>  repeated int64 o_ids = 1;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>将 <code>SimpleUnpacked.o_ids</code> 设置成 <code>1,2</code> 数组，会得到以下数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>08 01 08 02
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>08 // field number = 1, wire type = 0
</span></span><span class=line><span class=cl>01 // value = 1 
</span></span><span class=line><span class=cl>08 // field number = 1, wire type = 0
</span></span><span class=line><span class=cl>02 // value = 2
</span></span></code></pre></div><p>Protobuf 编码 unpacked repeated fields 时，并不会将 repeated fields 看成是一个整体，而是单独编码每一个元素。所以在解码 unpacked repeated fileds 时，需要将相同 field number 的数据合并到一起。</p><p>从另外一个角度看，Protobuf 允许将相同 Key 的数据合并到一起。<code>08 01 08 02</code> 数据可以看成是 <code>SimpleInt64.o_int64 = 1</code> 和 <code>SimpleInt64.o_int64 = 2</code> 编码合并的结果。</p><p>让我们来看看 packed repeated fields 编码结果。同样将 <code>SimplePacked.o_ids</code> 设置成 <code>1,2</code> 数组，却得到不同的数据，因为 Protobuf 编码时将 <code>o_ids</code> 看成是一个整体。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0A 02 01 02
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0A // field number = 1, wire type = 2
</span></span><span class=line><span class=cl>02 // payload size = 2
</span></span><span class=line><span class=cl>01 // first elem = 1
</span></span><span class=line><span class=cl>02 // second elem = 2
</span></span></code></pre></div><p>Protobuf 3.0 packed 的行为仅仅支持基础数据类型，即 <code>Varint/64-bit/32-bit</code> 三种 wire type。</p><p>packed 和 unpacked 编码面对长度为 0 的数据时，它并不会输出任何二进制数据。</p><blockquote><p>个人认为基础数据类型所占用字节数少，整体字节数相对可控，引入 payload size 能带来压缩效益。一旦使用 embedded message 之后，每一个元素的大小将不可控，可能只有少量元素，但是整体字节数将会很大，payload size 需要大量的字节表示。面对这种场景，unpacked repeated fields 单独编码的方式会带来压缩效益，即使包含了重复的 Key 信息。</p></blockquote><h3 id=5-start-groupend-group>5. Start Group/End Group<a hidden class=anchor aria-hidden=true href=#5-start-groupend-group>#</a></h3><p>由于 Protobuf 放弃使用 <code>Start Group</code> 和 <code>End Group</code>，在此也不再介绍。</p><h3 id=6-reference>6. Reference<a hidden class=anchor aria-hidden=true href=#6-reference>#</a></h3><ul><li><a href=https://developers.google.com/protocol-buffers/docs/encoding>Protocol Buffers Encoding</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://fuweid.com/post/2018-goroutine-scheduler-overview/><span class=title>« Prev</span><br><span>Goroutine Scheduler Overview</span></a>
<a class=next href=https://fuweid.com/post/2017-go-interface-duck-typing/><span class=title>Next »</span><br><span>Go Interface & Duck Typing</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://fuweid.com/>fuweid</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>